================================================================================
PROJECT CONTEXT - Newauto
Generated: 2025-12-24 23:51:14
Extensions: .py
================================================================================


================================================================================
FILE PATH: check_code.py
LINES: 230
================================================================================

#!/usr/bin/env python3
"""
RetroAuto v2 - Code Check Script

Runs all code quality checks:
- Syntax check
- Import check
- Ruff linting
- Mypy type checking
- Pytest tests with coverage

Usage:
    python check_code.py           # Quick check
    python check_code.py --full    # Full check with all tests
    python check_code.py --fix     # Auto-fix issues
    python check_code.py --cov     # Show coverage report
"""

import argparse
import subprocess
import sys
from pathlib import Path

# Directories to check
CHECK_DIRS = ["app", "core", "vision", "input", "infra"]
PROJECT_ROOT = Path(__file__).parent


def run_cmd(cmd: list[str], check: bool = True) -> tuple[int, str]:
    """Run command and return (returncode, output)."""
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            cwd=PROJECT_ROOT,
            encoding="utf-8",
            errors="replace",
        )
        output = result.stdout + result.stderr
        return result.returncode, output
    except Exception as e:
        return 1, str(e)


def check_syntax() -> bool:
    """Check Python syntax."""
    print("\nüîç [1/5] Checking Python syntax...")

    errors = []
    for dir_name in CHECK_DIRS:
        dir_path = PROJECT_ROOT / dir_name
        if not dir_path.exists():
            continue

        for py_file in dir_path.rglob("*.py"):
            code, output = run_cmd([sys.executable, "-m", "py_compile", str(py_file)])
            if code != 0:
                errors.append(f"  ‚ùå {py_file.relative_to(PROJECT_ROOT)}")

    if errors:
        print("\n".join(errors))
        return False

    print("  ‚úÖ Syntax OK")
    return True


def check_imports() -> bool:
    """Check that all modules can be imported."""
    print("\nüîç [2/5] Checking imports...")

    errors = []
    modules = [
        "app.main",
        "app.ui.main_window",
        "core.models",
        "core.engine.runner",
        "vision.capture",
        "input.mouse",
    ]

    for module in modules:
        code, output = run_cmd([sys.executable, "-c", f"import {module}"])
        if code != 0:
            errors.append(f"  ‚ùå {module}: {output.strip()[:100]}")

    if errors:
        print("\n".join(errors))
        return False

    print("  ‚úÖ Imports OK")
    return True


def check_ruff(fix: bool = False) -> bool:
    """Run Ruff linter."""
    print("\nüîç [3/5] Running Ruff linter...")

    cmd = [sys.executable, "-m", "ruff", "check", "."]
    if fix:
        cmd.append("--fix")

    code, output = run_cmd(cmd)

    if code != 0:
        # Filter to show only first 15 issues
        lines = output.strip().split("\n")
        if len(lines) > 15:
            print("\n".join(lines[:15]))
            print(f"  ... and {len(lines) - 15} more issues")
        else:
            print(output)
        return False

    print("  ‚úÖ Ruff OK")
    return True


def check_mypy() -> bool:
    """Run Mypy type checker."""
    print("\nüîç [4/5] Running Mypy type check...")

    cmd = [
        sys.executable,
        "-m",
        "mypy",
        "app",
        "core",
        "--ignore-missing-imports",
        "--no-error-summary",
    ]

    code, output = run_cmd(cmd)

    if code != 0:
        # Filter to show only errors (not notes)
        lines = [line for line in output.strip().split("\n") if ": error:" in line]
        if len(lines) > 10:
            print("\n".join(lines[:10]))
            print(f"  ... and {len(lines) - 10} more errors")
        elif lines:
            print("\n".join(lines))
        else:
            # No errors but non-zero exit (warnings)
            print("  ‚úÖ Mypy OK (with warnings)")
            return True
        return False

    print("  ‚úÖ Mypy OK")
    return True


def check_tests(full: bool = False, coverage: bool = False) -> bool:
    """Run pytest tests."""
    print("\nüîç [5/5] Running tests...")

    cmd = [sys.executable, "-m", "pytest", "tests/", "-q", "--tb=short"]

    if coverage:
        cmd.extend(
            [
                "--cov=app",
                "--cov=core",
                "--cov=vision",
                "--cov=input",
                "--cov-report=term-missing",
                "--cov-fail-under=30",
            ]
        )

    if not full:
        cmd.extend(["-x"])  # Stop on first failure for quick check

    code, output = run_cmd(cmd)

    # Show relevant output
    lines = output.strip().split("\n")
    # Show last 20 lines (summary + coverage)
    relevant = lines[-20:] if len(lines) > 20 else lines
    print("\n".join(relevant))

    if code != 0:
        return False

    print("  ‚úÖ Tests OK")
    return True


def main() -> int:
    parser = argparse.ArgumentParser(description="Code quality checker")
    parser.add_argument("--full", action="store_true", help="Full check with all tests")
    parser.add_argument("--fix", action="store_true", help="Auto-fix issues")
    parser.add_argument("--cov", action="store_true", help="Show coverage report")
    args = parser.parse_args()

    print("=" * 60)
    print("  RetroAuto v2 - Code Quality Check")
    print("=" * 60)

    results = {
        "Syntax": check_syntax(),
        "Imports": check_imports(),
        "Ruff": check_ruff(fix=args.fix),
        "Mypy": check_mypy(),
        "Tests": check_tests(full=args.full, coverage=args.cov),
    }

    print("\n" + "=" * 60)
    print("  Summary")
    print("=" * 60)

    all_passed = True
    for name, passed in results.items():
        status = "‚úÖ PASS" if passed else "‚ùå FAIL"
        print(f"  {name:10s} {status}")
        if not passed:
            all_passed = False

    print()
    if all_passed:
        print("  üéâ All checks passed! Ready to commit.")
        return 0
    else:
        print("  ‚ö†Ô∏è  Some checks failed. Fix before committing.")
        return 1


if __name__ == "__main__":
    sys.exit(main())


================================================================================
FILE PATH: merge_project.py
LINES: 238
================================================================================

"""
RetroAuto v2 - Project Context Merger

G·ªôp to√†n b·ªô source code c·ªßa d·ª± √°n v√†o m·ªôt file vƒÉn b·∫£n duy nh·∫•t.
H·ªØu √≠ch ƒë·ªÉ chia s·∫ª context v·ªõi AI ho·∫∑c review code.

Usage:
    python merge_project.py
    python merge_project.py --output custom_output.txt
    python merge_project.py --extensions .py .js .ts
"""

import argparse
import os
from pathlib import Path
from datetime import datetime

# C√°c th∆∞ m·ª•c c·∫ßn b·ªè qua
IGNORE_DIRS = {
    '.git',
    '__pycache__',
    'venv',
    '.venv',
    'env',
    'node_modules',
    '.idea',
    '.vscode',
    '.mypy_cache',
    '.pytest_cache',
    '.ruff_cache',
    '.coverage',
    'dist',
    'build',
    'eggs',
    '*.egg-info',
    '.tox',
    '.nox',
    'htmlcov',
}

# C√°c ƒëu√¥i file m·∫∑c ƒë·ªãnh
DEFAULT_EXTENSIONS = {'.py'}

# C√°c file c·∫ßn b·ªè qua
IGNORE_FILES = {
    'project_context.txt',  # File output
    '.gitignore',
    '.pre-commit-config.yaml',
    'mypy.ini',
    'pyproject.toml',
    'setup.py',
    'setup.cfg',
}


def should_ignore_dir(dir_name: str) -> bool:
    """Ki·ªÉm tra xem th∆∞ m·ª•c c√≥ n√™n b·ªè qua kh√¥ng."""
    return dir_name in IGNORE_DIRS or dir_name.startswith('.')


def should_ignore_file(file_name: str) -> bool:
    """Ki·ªÉm tra xem file c√≥ n√™n b·ªè qua kh√¥ng."""
    return file_name in IGNORE_FILES


def merge_project(
    root_dir: Path,
    output_file: Path,
    extensions: set[str],
    include_line_numbers: bool = False,
) -> dict:
    """
    G·ªôp t·∫•t c·∫£ source code v√†o m·ªôt file.
    
    Args:
        root_dir: Th∆∞ m·ª•c g·ªëc c·ªßa d·ª± √°n
        output_file: File output
        extensions: C√°c ƒëu√¥i file c·∫ßn l·∫•y
        include_line_numbers: Th√™m s·ªë d√≤ng v√†o m·ªói d√≤ng code
        
    Returns:
        Dict v·ªõi th·ªëng k√™
    """
    stats = {
        'files_processed': 0,
        'files_skipped': 0,
        'total_lines': 0,
        'total_chars': 0,
        'errors': [],
    }
    
    separator = "=" * 80
    
    with open(output_file, 'w', encoding='utf-8') as out:
        # Header
        out.write(f"{separator}\n")
        out.write(f"PROJECT CONTEXT - {root_dir.name}\n")
        out.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        out.write(f"Extensions: {', '.join(sorted(extensions))}\n")
        out.write(f"{separator}\n\n")
        
        # Duy·ªát ƒë·ªá quy
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Lo·∫°i b·ªè c√°c th∆∞ m·ª•c c·∫ßn ignore (in-place ƒë·ªÉ os.walk kh√¥ng ƒëi v√†o)
            dirnames[:] = [d for d in dirnames if not should_ignore_dir(d)]
            
            for filename in sorted(filenames):
                # Ki·ªÉm tra extension
                file_ext = os.path.splitext(filename)[1].lower()
                if file_ext not in extensions:
                    continue
                    
                # Ki·ªÉm tra file ignore
                if should_ignore_file(filename):
                    stats['files_skipped'] += 1
                    continue
                
                filepath = Path(dirpath) / filename
                relative_path = filepath.relative_to(root_dir)
                
                try:
                    # ƒê·ªçc file v·ªõi x·ª≠ l√Ω encoding
                    content = filepath.read_text(encoding='utf-8', errors='replace')
                    lines = content.splitlines()
                    
                    # Ghi header cho file
                    out.write(f"\n{separator}\n")
                    out.write(f"FILE PATH: {relative_path}\n")
                    out.write(f"LINES: {len(lines)}\n")
                    out.write(f"{separator}\n\n")
                    
                    # Ghi n·ªôi dung
                    if include_line_numbers:
                        for i, line in enumerate(lines, 1):
                            out.write(f"{i:4d}: {line}\n")
                    else:
                        out.write(content)
                    
                    out.write("\n")
                    
                    # C·∫≠p nh·∫≠t stats
                    stats['files_processed'] += 1
                    stats['total_lines'] += len(lines)
                    stats['total_chars'] += len(content)
                    
                except Exception as e:
                    stats['errors'].append(f"{relative_path}: {e}")
                    stats['files_skipped'] += 1
        
        # Footer
        out.write(f"\n{separator}\n")
        out.write("END OF PROJECT CONTEXT\n")
        out.write(f"Total files: {stats['files_processed']}\n")
        out.write(f"Total lines: {stats['total_lines']}\n")
        out.write(f"{separator}\n")
    
    return stats


def main():
    parser = argparse.ArgumentParser(
        description='G·ªôp source code d·ª± √°n v√†o m·ªôt file vƒÉn b·∫£n'
    )
    parser.add_argument(
        '--root', '-r',
        type=Path,
        default=Path('.'),
        help='Th∆∞ m·ª•c g·ªëc (m·∫∑c ƒë·ªãnh: th∆∞ m·ª•c hi·ªán t·∫°i)'
    )
    parser.add_argument(
        '--output', '-o',
        type=Path,
        default=Path('project_context.txt'),
        help='File output (m·∫∑c ƒë·ªãnh: project_context.txt)'
    )
    parser.add_argument(
        '--extensions', '-e',
        nargs='+',
        default=['.py'],
        help='C√°c ƒëu√¥i file c·∫ßn l·∫•y (m·∫∑c ƒë·ªãnh: .py)'
    )
    parser.add_argument(
        '--line-numbers', '-n',
        action='store_true',
        help='Th√™m s·ªë d√≤ng v√†o m·ªói d√≤ng code'
    )
    parser.add_argument(
        '--all-code',
        action='store_true',
        help='L·∫•y t·∫•t c·∫£ file code ph·ªï bi·∫øn (.py, .js, .ts, .java, .go, .rs, .cpp, .c, .h)'
    )
    
    args = parser.parse_args()
    
    # X·ª≠ l√Ω extensions
    if args.all_code:
        extensions = {'.py', '.js', '.ts', '.jsx', '.tsx', '.java', '.go', '.rs', '.cpp', '.c', '.h', '.hpp', '.cs', '.rb', '.php'}
    else:
        extensions = {ext if ext.startswith('.') else f'.{ext}' for ext in args.extensions}
    
    root_dir = args.root.resolve()
    output_file = args.output.resolve()
    
    print(f"üîç Scanning: {root_dir}")
    print(f"üìù Output: {output_file}")
    print(f"üìÑ Extensions: {', '.join(sorted(extensions))}")
    print()
    
    stats = merge_project(
        root_dir=root_dir,
        output_file=output_file,
        extensions=extensions,
        include_line_numbers=args.line_numbers,
    )
    
    print(f"‚úÖ Done!")
    print(f"   Files processed: {stats['files_processed']}")
    print(f"   Files skipped: {stats['files_skipped']}")
    print(f"   Total lines: {stats['total_lines']:,}")
    print(f"   Total chars: {stats['total_chars']:,}")
    
    if stats['errors']:
        print(f"\n‚ö†Ô∏è Errors ({len(stats['errors'])}):")
        for err in stats['errors'][:5]:
            print(f"   - {err}")
        if len(stats['errors']) > 5:
            print(f"   ... and {len(stats['errors']) - 5} more")
    
    # Hi·ªÉn th·ªã k√≠ch th∆∞·ªõc file
    size_kb = output_file.stat().st_size / 1024
    if size_kb > 1024:
        print(f"\nüì¶ Output size: {size_kb/1024:.2f} MB")
    else:
        print(f"\nüì¶ Output size: {size_kb:.2f} KB")


if __name__ == '__main__':
    main()


================================================================================
FILE PATH: merge_project.py.py
LINES: 71
================================================================================

import os

# --- C·∫§U H√åNH ---
# T√™n file k·∫øt qu·∫£ ƒë·∫ßu ra
OUTPUT_FILENAME = "FULL_PROJECT_CONTEXT.txt"

# C√°c ƒëu√¥i file mu·ªën g·ªôp (th√™m .js, .html, .css n·∫øu c·∫ßn)
ALLOWED_EXTENSIONS = {'.py', '.ini', '.json', '.yaml', '.md'}

# C√°c th∆∞ m·ª•c mu·ªën B·ªé QUA (r·∫•t quan tr·ªçng ƒë·ªÉ file kh√¥ng b·ªã r√°c)
IGNORE_DIRS = {
    '.git', '__pycache__', 'venv', 'env', '.idea', '.vscode', 
    'build', 'dist', 'migrations', 'node_modules'
}

def merge_files():
    root_dir = os.getcwd() # L·∫•y th∆∞ m·ª•c hi·ªán t·∫°i
    
    # M·ªü file k·∫øt qu·∫£ ƒë·ªÉ ghi (encoding utf-8)
    with open(OUTPUT_FILENAME, 'w', encoding='utf-8') as outfile:
        
        # Vi·∫øt ph·∫ßn m·ªü ƒë·∫ßu cho AI hi·ªÉu context
        outfile.write(f"PROJECT SOURCE CODE SUMMARY\n")
        outfile.write(f"This file contains the merged source code of the project.\n")
        outfile.write(f"Structure: Header with filename -> File Content -> Separator\n\n")

        file_count = 0
        
        # Duy·ªát qua t·∫•t c·∫£ th∆∞ m·ª•c v√† file
        for dirpath, dirnames, filenames in os.walk(root_dir):
            
            # 1. L·ªçc b·ªè c√°c th∆∞ m·ª•c kh√¥ng mong mu·ªën (s·ª≠a tr·ª±c ti·∫øp list dirnames)
            dirnames[:] = [d for d in dirnames if d not in IGNORE_DIRS]
            
            for filename in filenames:
                # B·ªè qua ch√≠nh file script n√†y v√† file output
                if filename in ['merge_project.py', OUTPUT_FILENAME]:
                    continue
                
                # 2. Ki·ªÉm tra ƒëu√¥i file
                ext = os.path.splitext(filename)[1].lower()
                if ext in ALLOWED_EXTENSIONS:
                    full_path = os.path.join(dirpath, filename)
                    relative_path = os.path.relpath(full_path, root_dir)
                    
                    try:
                        # ƒê·ªçc n·ªôi dung file con
                        with open(full_path, 'r', encoding='utf-8', errors='ignore') as infile:
                            content = infile.read()
                            
                            # 3. Ghi ti√™u ƒë·ªÅ r√µ r√†ng cho t·ª´ng file (C·ª∞C QUAN TR·ªåNG V·ªöI AI)
                            outfile.write("\n" + "="*60 + "\n")
                            outfile.write(f"START OF FILE: {relative_path}\n")
                            outfile.write("="*60 + "\n")
                            
                            # Ghi n·ªôi dung
                            outfile.write(content)
                            outfile.write("\n\n") # Th√™m d√≤ng tr·ªëng cu·ªëi file
                            
                            print(f"ƒê√£ g·ªôp: {relative_path}")
                            file_count += 1
                            
                    except Exception as e:
                        print(f"L·ªói khi ƒë·ªçc file {relative_path}: {e}")

    print(f"\n--- HO√ÄN T·∫§T ---")
    print(f"ƒê√£ g·ªôp {file_count} files v√†o: {OUTPUT_FILENAME}")
    print(f"File n√†y ƒë√£ s·∫µn s√†ng ƒë·ªÉ upload cho AI.")

if __name__ == "__main__":
    merge_files()

================================================================================
FILE PATH: package_source.py
LINES: 44
================================================================================

import os
import zipfile
from pathlib import Path


def zip_project(output_filename="RetroAuto_v2_Source.zip", source_dir="."):
    source_path = Path(source_dir).resolve()

    # Exclude these patterns
    excludes = {
        "__pycache__",
        ".git",
        ".idea",
        ".vscode",
        ".DS_Store",
        "venv",
        "env",
        ".pytest_cache",
        "dist",
        "build",
        "retroauto.log",
    }

    with zipfile.ZipFile(output_filename, "w", zipfile.ZIP_DEFLATED) as zipf:
        for root, dirs, files in os.walk(source_path):
            # Modify dirs in-place to skip excluded directories
            dirs[:] = [d for d in dirs if d not in excludes]

            for file in files:
                if file in excludes or file.endswith(".pyc") or file == output_filename:
                    continue

                file_path = Path(root) / file
                archive_name = file_path.relative_to(source_path)

                print(f"Adding: {archive_name}")
                zipf.write(file_path, archive_name)

    print(f"\nSuccessfully created: {output_filename}")
    print(f"Size: {os.path.getsize(output_filename) / 1024 / 1024:.2f} MB")


if __name__ == "__main__":
    zip_project()


================================================================================
FILE PATH: run_ide.py
LINES: 47
================================================================================

"""
MacroIDE 95 - Entry Point

Launches the MacroIDE 95 application with Win95/98 styling.
"""

from __future__ import annotations

import sys

from PySide6.QtWidgets import QApplication

from app.ui.ide_main_window import IDEMainWindow
from app.ui.win95_style import apply_win95_style


def main() -> int:
    """Main entry point."""
    # Initialize stability features first
    from infra.crash_handler import CrashHandler
    CrashHandler.install()

    # Start memory manager for 24/7 operation
    from core.engine.memory_manager import get_memory_manager
    memory_mgr = get_memory_manager()
    memory_mgr.start()

    app = QApplication(sys.argv)

    # Apply Win95/98 styling
    apply_win95_style(app)

    # Create and show main window
    window = IDEMainWindow()
    window.show()

    result = app.exec()

    # Cleanup
    memory_mgr.stop()

    return result


if __name__ == "__main__":
    sys.exit(main())



================================================================================
FILE PATH: run_qa.py
LINES: 75
================================================================================

#!/usr/bin/env python3
"""
RetroAuto QA Runner
Executes Project Quality Gates: Lint, Test, Security, Build.
"""
import os
import subprocess
import sys
import time


def run_step(name, command, shell=True, allow_fail=False):
    print(f"\n[QA] Running: {name}...")
    start = time.time()
    try:
        # Check if command exists (simple check)
        cmd_parts = command.split()
        if not allow_fail and cmd_parts[0] != "python" and not os.path.exists(cmd_parts[0]):
            # Just a heuristic, shell=True handles path lookup usually
            pass

        result = subprocess.run(command, shell=shell, check=not allow_fail)
        duration = time.time() - start

        if result.returncode == 0:
            print(f"‚úÖ {name} PASSED ({duration:.2f}s)")
            return True
        else:
            print(f"‚ùå {name} FAILED ({duration:.2f}s)")
            return False

    except subprocess.CalledProcessError:
        print(f"‚ùå {name} FAILED")
        return False
    except FileNotFoundError:
        print(f"‚ö†Ô∏è  Tool not found for: {name} (Skipping)")
        return True  # Treat missing tool as warning if not critical? Or fail? Let's fail for strictness.
        return False


def main():
    print("üöÄ Starting RetroAuto QA Pipeline")
    print("================================")

    success = True

    # 1. Static Analysis
    success &= run_step("Ruff Lint", "ruff check .")
    success &= run_step("Black Format Check", "black --check .")
    success &= run_step("Type Check (Core)", "mypy core")

    # 2. Security
    success &= run_step(
        "Bandit Security Scan", "bandit -r core -ll", allow_fail=True
    )  # Warning only for now

    # 3. Validation
    success &= run_step("Smoke Verification", "python verify_all.py")
    success &= run_step("Security Tests", "python -m tests.test_security")

    # 4. Performance
    if os.path.exists("bench_vision.py"):
        success &= run_step("Vision Benchmark", "python bench_vision.py")

    print("\n================================")
    if success:
        print("‚úÖ QA PIPELINE PASSED")
        sys.exit(0)
    else:
        print("‚ùå QA PIPELINE FAILED")
        sys.exit(1)


if __name__ == "__main__":
    main()


================================================================================
FILE PATH: verify_all.py
LINES: 149
================================================================================

"""
RetroAuto v2 - Comprehensive Verification Script
Verifies all implemented phases (1-20).
"""

import sys
import unittest
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent))


class TestRetroAutoIntegration(unittest.TestCase):
    def test_phase_01_11_core(self):
        """Verify Core DSL components."""
        print("\n[Phase 1-11] Core DSL...", end=" ")
        try:
            from core.dsl.parser import Parser

            code = "flow main { let x = 10; log(x); }"
            parser = Parser(code)
            program = parser.parse()

            if parser.errors:
                for err in parser.errors:
                    print(f"Parser Error: {err.message} at {err.span}")

            self.assertEqual(len(parser.errors), 0)
            self.assertIsNotNone(program)
            self.assertEqual(len(program.flows), 1)
            print("OK")
        except Exception as e:
            self.fail(f"Failed: {e}")

    def test_phase_12_lsp(self):
        """Verify LSP Server."""
        print("[Phase 12] LSP Server...", end=" ")
        try:
            from core.lsp.server import RetroScriptLanguageServer

            server = RetroScriptLanguageServer()
            self.assertIsNotNone(server)
            print("OK")
        except Exception as e:
            self.fail(f"Failed: {e}")

    def test_phase_13_packaging(self):
        """Verify Package Management."""
        print("[Phase 13] Packaging...", end=" ")
        try:
            from core.package.manifest import PackageMetadata
            from core.package.resolver import VersionReq

            meta = PackageMetadata("test-pkg", "1.0.0")
            self.assertEqual(meta.name, "test-pkg")

            req = VersionReq("^1.2.0")
            self.assertTrue(req.kind == "caret")
            print("OK")
        except Exception as e:
            self.fail(f"Failed: {e}")

    def test_phase_14_visual(self):
        """Verify Visual Components."""
        print("[Phase 14] Visual Editor...", end=" ")
        try:
            from PySide6.QtWidgets import QApplication

            from app.ui.roi_selector import ROISelector
            from app.ui.variable_watch import VariableWatch

            # App might be running, check if instance exists
            QApplication.instance() or QApplication([])

            roi = ROISelector()
            watch = VariableWatch()
            self.assertIsNotNone(roi)
            self.assertIsNotNone(watch)
            print("OK")
        except Exception as e:
            self.fail(f"Failed: {e}")

    def test_phase_16_network(self):
        """Verify Network Features (Mock/Local)."""
        print("[Phase 16] Network...", end=" ")
        try:
            from core.network.http_client import HttpClient
            from core.network.remote import RemoteController

            client = HttpClient()
            # P1 Fix: Don't connect to external echo server
            # ws = WebSocketClient("wss://echo.websocket.org")

            # Just verify class instantiation and interface
            remote = RemoteController(port=0, auth_token="test")

            self.assertIsNotNone(client)
            # self.assertIsNotNone(ws)
            self.assertIsNotNone(remote)

            # Verify Auth Check
            self.assertFalse(remote.check_auth(None))
            self.assertTrue(remote.check_auth("Bearer test"))

            print("OK")
        except Exception as e:
            self.fail(f"Failed: {e}")

    def test_phase_17_analytics(self):
        """Verify Analytics."""
        print("[Phase 17] Analytics...", end=" ")
        try:
            from core.analytics.metrics import MetricsRegistry, ScriptMetrics

            registry = MetricsRegistry()
            ctr = registry.counter("test_counter")
            ctr.inc()
            self.assertEqual(ctr.get(), 1)

            metrics = ScriptMetrics(registry)
            metrics.script_started("test")
            print("OK")
        except Exception as e:
            self.fail(f"Failed: {e}")

    def test_phase_20_game(self):
        """Verify Game Features."""
        print("[Phase 20] Game Features...", end=" ")
        try:
            from core.game.anti_detect import AntiDetection
            from core.game.macro import MacroRecorder
            from core.game.pixel_detect import Color

            color = Color(255, 0, 0)
            self.assertEqual(color.to_hex(), "#ff0000")

            anti = AntiDetection()
            recorder = MacroRecorder()

            self.assertIsNotNone(anti)
            self.assertIsNotNone(recorder)
            print("OK")
        except Exception as e:
            self.fail(f"Failed: {e}")


if __name__ == "__main__":
    unittest.main(verbosity=0)


================================================================================
FILE PATH: watch_code.py
LINES: 142
================================================================================

#!/usr/bin/env python3
"""
RetroAuto v2 - File Watcher for Real-time Code Checking

Watches for .py file changes and automatically runs code checks.

Usage:
    python watch_code.py           # Watch and run quick checks
    python watch_code.py --full    # Watch and run full checks
    python watch_code.py --fix     # Watch and auto-fix on change
"""

import argparse
import subprocess
import sys
import time
from pathlib import Path

try:
    from watchdog.events import FileSystemEventHandler
    from watchdog.observers import Observer
except ImportError:
    print("‚ùå watchdog not installed. Run: pip install watchdog")
    sys.exit(1)

PROJECT_ROOT = Path(__file__).parent
WATCH_DIRS = ["app", "core", "vision", "input", "infra", "tests"]
DEBOUNCE_SECONDS = 2  # Wait before running check after change


class CodeCheckHandler(FileSystemEventHandler):
    """Handler that runs code checks on Python file changes."""

    def __init__(self, full: bool = False, fix: bool = False):
        super().__init__()
        self.full = full
        self.fix = fix
        self._last_run = 0
        self._pending_check = False

    def on_modified(self, event):
        if event.is_directory:
            return

        path = Path(event.src_path)

        # Only react to .py files
        if path.suffix != ".py":
            return

        # Skip __pycache__ and other generated files
        if "__pycache__" in str(path):
            return

        # Debounce: don't run check too frequently
        now = time.time()
        if now - self._last_run < DEBOUNCE_SECONDS:
            return

        self._last_run = now
        self._run_check(path)

    def _run_check(self, changed_file: Path):
        """Run code check."""
        rel_path = changed_file.relative_to(PROJECT_ROOT)

        print()
        print("=" * 60)
        print(f"  üìù File changed: {rel_path}")
        print(f"  ‚è∞ {time.strftime('%H:%M:%S')}")
        print("=" * 60)

        # Build command
        cmd = [sys.executable, "check_code.py"]
        if self.full:
            cmd.append("--full")
        if self.fix:
            cmd.append("--fix")

        # Run check
        try:
            result = subprocess.run(
                cmd,
                cwd=PROJECT_ROOT,
                timeout=120,
            )

            if result.returncode == 0:
                print("\n  üîî Ready to commit!")
            else:
                print("\n  ‚ö†Ô∏è Fix issues before committing")

        except subprocess.TimeoutExpired:
            print("\n  ‚è±Ô∏è Check timed out")
        except Exception as e:
            print(f"\n  ‚ùå Error: {e}")

        print("\n  üëÄ Watching for changes... (Ctrl+C to stop)")


def main():
    parser = argparse.ArgumentParser(description="Watch files and run code checks")
    parser.add_argument("--full", action="store_true", help="Run full tests")
    parser.add_argument("--fix", action="store_true", help="Auto-fix issues")
    args = parser.parse_args()

    print("=" * 60)
    print("  RetroAuto v2 - File Watcher")
    print("=" * 60)
    print()
    print(f"  Watching: {', '.join(WATCH_DIRS)}")
    print(f"  Mode: {'Full' if args.full else 'Quick'}")
    print(f"  Auto-fix: {'Yes' if args.fix else 'No'}")
    print()
    print("  üëÄ Watching for changes... (Ctrl+C to stop)")
    print()

    # Setup watcher
    event_handler = CodeCheckHandler(full=args.full, fix=args.fix)
    observer = Observer()

    for dir_name in WATCH_DIRS:
        dir_path = PROJECT_ROOT / dir_name
        if dir_path.exists():
            observer.schedule(event_handler, str(dir_path), recursive=True)

    # Start watching
    observer.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\n\n  üëã Stopping watcher...")
        observer.stop()

    observer.join()
    print("  ‚úÖ Watcher stopped")


if __name__ == "__main__":
    main()


================================================================================
FILE PATH: app\__init__.py
LINES: 1
================================================================================

"""RetroAuto v2 - Application package."""


================================================================================
FILE PATH: app\cli.py
LINES: 383
================================================================================

"""
RetroAuto v2 - CLI Tool

Command-line interface for RetroScript.
Part of RetroScript Phase 8 - Runtime + Distribution.

Usage:
    retro run script.retro
    retro build project/
    retro test project/
    retro new my_project
    retro docs script.retro
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path


def create_parser() -> argparse.ArgumentParser:
    """Create the argument parser."""
    parser = argparse.ArgumentParser(
        prog="retro",
        description="RetroScript CLI - Automation scripting tool",
    )
    parser.add_argument(
        "--version",
        "-v",
        action="version",
        version="RetroScript 1.0.0",
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # run command
    run_parser = subparsers.add_parser("run", help="Run a RetroScript file")
    run_parser.add_argument("file", help="Script file to run")
    run_parser.add_argument("--profile", action="store_true", help="Enable profiling")
    run_parser.add_argument("--debug", action="store_true", help="Enable debug mode")
    run_parser.add_argument("--watch", action="store_true", help="Watch for changes")

    # build command
    build_parser = subparsers.add_parser("build", help="Build/bundle a project")
    build_parser.add_argument("project", help="Project directory")
    build_parser.add_argument("-o", "--output", help="Output path")
    build_parser.add_argument("--no-assets", action="store_true", help="Exclude assets")

    # test command
    test_parser = subparsers.add_parser("test", help="Run tests")
    test_parser.add_argument("path", nargs="?", default=".", help="Project or test file")
    test_parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")

    # new command
    new_parser = subparsers.add_parser("new", help="Create new project")
    new_parser.add_argument("name", help="Project name")
    new_parser.add_argument(
        "--template",
        "-t",
        choices=["basic", "game_bot", "scraper", "testing"],
        default="basic",
        help="Project template",
    )

    # docs command
    docs_parser = subparsers.add_parser("docs", help="Generate documentation")
    docs_parser.add_argument("path", help="File or directory")
    docs_parser.add_argument("-o", "--output", help="Output path")

    # format command
    fmt_parser = subparsers.add_parser("fmt", help="Format code")
    fmt_parser.add_argument("path", help="File or directory")
    fmt_parser.add_argument("--check", action="store_true", help="Check only, don't modify")

    # lint command
    lint_parser = subparsers.add_parser("lint", help="Lint code")
    lint_parser.add_argument("path", help="File or directory")

    # parse command
    parse_parser = subparsers.add_parser("parse", help="Parse and show AST")
    parse_parser.add_argument("file", help="Script file")
    parse_parser.add_argument("--json", action="store_true", help="Output as JSON")

    return parser


def cmd_run(args: argparse.Namespace) -> int:
    """Run a script."""
    file_path = Path(args.file)
    if not file_path.exists():
        print(f"Error: File not found: {file_path}", file=sys.stderr)
        return 1

    print(f"Running: {file_path}")

    # Read and parse
    source = file_path.read_text(encoding="utf-8")

    try:
        from core.dsl.parser import Parser

        parser = Parser(source)
        program = parser.parse()

        if parser.errors:
            print("Parse errors:")
            for err in parser.errors:
                print(f"  {err}")
            return 1

        print(f"Parsed successfully: {len(program.flows)} flows")

        if args.profile:
            from core.runtime.profiler import get_profiler

            profiler = get_profiler()
            profiler.reset()
            print("Profiling enabled")

        if args.watch:
            from core.runtime.hot_reload import HotReloader

            reloader = HotReloader()
            reloader.watch(file_path)
            reloader.on_reload = lambda p: print(f"Reloaded: {p}")
            reloader.start()
            print("Hot reload enabled. Press Ctrl+C to stop.")
            try:
                while True:
                    import time

                    time.sleep(1)
            except KeyboardInterrupt:
                reloader.stop()

        return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


def cmd_build(args: argparse.Namespace) -> int:
    """Build/bundle a project."""
    project_dir = Path(args.project)
    if not project_dir.exists():
        print(f"Error: Project not found: {project_dir}", file=sys.stderr)
        return 1

    try:
        from app.tools.bundler import BundleOptions, Bundler

        options = BundleOptions(include_assets=not args.no_assets)
        bundler = Bundler(options)
        output = bundler.bundle(project_dir, args.output)
        print(f"Bundle created: {output}")
        return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


def cmd_test(args: argparse.Namespace) -> int:
    """Run tests."""
    path = Path(args.path)
    print(f"Running tests in: {path}")

    # Find test files
    if path.is_file():
        test_files = [path]
    else:
        test_files = list(path.glob("**/test_*.retro"))
        test_files.extend(path.glob("**/*_test.retro"))

    print(f"Found {len(test_files)} test file(s)")

    passed = 0
    failed = 0

    for test_file in test_files:
        if args.verbose:
            print(f"  {test_file}")
        # TODO: Run actual tests
        passed += 1

    print(f"\nResults: {passed} passed, {failed} failed")
    return 0 if failed == 0 else 1


def cmd_new(args: argparse.Namespace) -> int:
    """Create new project."""
    try:
        from app.tools.scaffold import create_project

        project_path = create_project(args.name, args.template)
        print(f"Created project: {project_path}")
        print("\nNext steps:")
        print(f"  cd {args.name}")
        print("  retro run main.retro")
        return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


def cmd_docs(args: argparse.Namespace) -> int:
    """Generate documentation."""
    path = Path(args.path)
    if not path.exists():
        print(f"Error: Path not found: {path}", file=sys.stderr)
        return 1

    try:
        from app.tools.doc_generator import DocGenerator

        gen = DocGenerator()

        if path.is_file():
            source = path.read_text(encoding="utf-8")
            doc = gen.generate(source)
            doc.name = path.stem
            markdown = gen.to_markdown(doc)

            if args.output:
                output_path = Path(args.output)
                output_path.write_text(markdown, encoding="utf-8")
                print(f"Documentation written to: {output_path}")
            else:
                print(markdown)
        else:
            # Directory of files
            modules = []
            for file in path.glob("**/*.retro"):
                source = file.read_text(encoding="utf-8")
                doc = gen.generate(source)
                doc.name = file.stem
                modules.append(doc)

            index = gen.generate_index(modules)
            print(index)

        return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


def cmd_fmt(args: argparse.Namespace) -> int:
    """Format code."""
    path = Path(args.path)
    if not path.exists():
        print(f"Error: Path not found: {path}", file=sys.stderr)
        return 1

    try:
        from app.ide.formatter import Formatter

        formatter = Formatter()

        files = [path] if path.is_file() else list(path.glob("**/*.retro"))

        for file in files:
            source = file.read_text(encoding="utf-8")
            formatted = formatter.format(source)

            if args.check:
                if source != formatted:
                    print(f"Would format: {file}")
            else:
                file.write_text(formatted, encoding="utf-8")
                print(f"Formatted: {file}")

        return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


def cmd_lint(args: argparse.Namespace) -> int:
    """Lint code."""
    path = Path(args.path)
    if not path.exists():
        print(f"Error: Path not found: {path}", file=sys.stderr)
        return 1

    try:
        from app.ide.quick_fixes import LiveValidator

        validator = LiveValidator()

        files = [path] if path.is_file() else list(path.glob("**/*.retro"))

        total_issues = 0

        for file in files:
            source = file.read_text(encoding="utf-8")
            errors = validator.validate(source)

            if errors:
                print(f"\n{file}:")
                for err in errors:
                    print(f"  L{err.line}: [{err.severity}] {err.message}")
                    total_issues += 1

        if total_issues:
            print(f"\n{total_issues} issue(s) found")
            return 1
        else:
            print("No issues found")
            return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


def cmd_parse(args: argparse.Namespace) -> int:
    """Parse and show AST."""
    file_path = Path(args.file)
    if not file_path.exists():
        print(f"Error: File not found: {file_path}", file=sys.stderr)
        return 1

    source = file_path.read_text(encoding="utf-8")

    try:
        from core.dsl.parser import Parser

        parser = Parser(source)
        program = parser.parse()

        if parser.errors:
            print("Parse errors:")
            for err in parser.errors:
                print(f"  {err}")
            return 1

        print(f"Flows: {[f.name for f in program.flows]}")
        print(f"Imports: {len(program.imports)}")
        print(f"Constants: {len(program.constants)}")

        return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


def main(argv: list[str] | None = None) -> int:
    """Main entry point."""
    parser = create_parser()
    args = parser.parse_args(argv)

    if not args.command:
        parser.print_help()
        return 0

    commands = {
        "run": cmd_run,
        "build": cmd_build,
        "test": cmd_test,
        "new": cmd_new,
        "docs": cmd_docs,
        "fmt": cmd_fmt,
        "lint": cmd_lint,
        "parse": cmd_parse,
    }

    handler = commands.get(args.command)
    if handler:
        return handler(args)

    print(f"Unknown command: {args.command}", file=sys.stderr)
    return 1


if __name__ == "__main__":
    sys.exit(main())


================================================================================
FILE PATH: app\controller.py
LINES: 307
================================================================================

"""
RetroAuto v2 - IDE Controller

Central controller that wires:
- Code Editor ‚Üî Document ‚Üî IR
- GUI Panels ‚Üî Document ‚Üî IR
- Runner ‚Üî Document

This keeps the IDE main window clean and handles all coordination.
"""

from __future__ import annotations

from pathlib import Path
from typing import Any

from PySide6.QtCore import QObject, Signal

from core.dsl.diagnostics import Diagnostic
from core.dsl.document import ScriptDocument
from core.dsl.ir import ActionIR, AssetIR, FlowIR
from core.dsl.parser import Parser
from core.dsl.semantic import analyze


class IDEController(QObject):
    """
    Central controller for MacroIDE 95.

    Signals:
        document_changed: Document was loaded/updated
        code_updated: Code was regenerated from GUI
        ir_updated: IR was updated from code
        errors_found: Parse/semantic errors found
        run_started: Script execution started
        run_stopped: Script execution stopped
    """

    document_changed = Signal()
    code_updated = Signal(str)  # new code
    ir_updated = Signal(str)  # change type
    errors_found = Signal(list)  # list of Diagnostic
    run_started = Signal()
    run_stopped = Signal()

    def __init__(self) -> None:
        super().__init__()
        self._document = ScriptDocument()
        self._is_running = False
        self._setup_callbacks()

    @property
    def document(self) -> ScriptDocument:
        """Get the current document."""
        return self._document

    @property
    def is_running(self) -> bool:
        """Check if script is running."""
        return self._is_running

    def _setup_callbacks(self) -> None:
        """Set up document callbacks."""
        self._document.on_ir_changed(self._on_ir_changed)
        self._document.on_code_changed(self._on_code_changed)
        self._document.on_error(self._on_errors)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Document Operations
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def new_project(self, folder: Path) -> None:
        """Create a new project in folder."""
        # Create directory structure
        (folder / "assets").mkdir(parents=True, exist_ok=True)
        (folder / "scripts").mkdir(exist_ok=True)
        (folder / "flows").mkdir(exist_ok=True)

        # Create main.dsl
        main_path = folder / "scripts" / "main.dsl"
        self._document.new()
        self._document.save_as(main_path)

        self.document_changed.emit()

    def open_file(self, path: Path) -> bool:
        """Open a DSL file."""
        success = self._document.load_from_file(path)
        if success:
            self.document_changed.emit()
            # Run validation
            self.validate()
        return success

    def save(self) -> bool:
        """Save the current document."""
        return self._document.save()

    def save_as(self, path: Path) -> bool:
        """Save to a new file."""
        return self._document.save_as(path)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Code ‚Üî IR Sync
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def update_code(self, new_code: str) -> None:
        """
        Update document from code editor.

        Called when user types in the editor.
        """
        self._document.update_from_code(new_code, source="editor")

    def update_from_gui(self, path: str, value: Any) -> None:
        """
        Update document from GUI change.

        Called when user changes properties in inspector.
        """
        self._document.update_from_gui(path, value)

    def _on_code_changed(self, source: str) -> None:
        """Handle code change from document."""
        if source != "editor":
            # Code was regenerated from GUI, update editor
            self.code_updated.emit(self._document.code)

    def _on_ir_changed(self, change_type: str) -> None:
        """Handle IR change from document."""
        self.ir_updated.emit(change_type)

    def _on_errors(self, errors: list[str]) -> None:
        """Handle parse errors from document."""
        # Convert to diagnostics
        diagnostics = [
            Diagnostic(
                code="E1000",
                severity="error",
                message=e,
                span=None,  # TODO: Extract span
            )
            for e in errors
        ]
        self.errors_found.emit(diagnostics)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Validation
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def validate(self) -> list[Diagnostic]:
        """
        Validate the current document.

        Returns list of diagnostics.
        """
        code = self._document.code
        parser = Parser(code)
        program = parser.parse()

        # Collect all diagnostics
        diagnostics: list[Diagnostic] = list(parser.errors)

        if not parser.errors:
            # Run semantic analysis
            asset_ids = [a.id for a in self._document.ir.assets]
            semantic_errors = analyze(program, known_assets=asset_ids)
            diagnostics.extend(semantic_errors)

        self.errors_found.emit(diagnostics)
        return diagnostics

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Flow Operations (from GUI)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def add_flow(self, name: str) -> FlowIR | None:
        """Add a new flow."""
        if self._document.ir.get_flow(name):
            return None  # Already exists
        return self._document.add_flow(name)

    def remove_flow(self, name: str) -> None:
        """Remove a flow."""
        self._document.remove_flow(name)

    def add_action(self, flow_name: str, action_type: str, params: dict) -> None:
        """Add an action to a flow."""
        action = ActionIR(action_type=action_type, params=params)
        self._document.add_action_to_flow(flow_name, action)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Asset Operations
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def add_asset(self, asset_id: str, path: str, threshold: float = 0.8) -> None:
        """Add a new asset."""
        asset = AssetIR(id=asset_id, path=path, threshold=threshold)
        self._document.add_asset(asset)

    def remove_asset(self, asset_id: str) -> None:
        """Remove an asset."""
        self._document.remove_asset(asset_id)

    def update_asset(self, asset_id: str, **kwargs: Any) -> None:
        """Update asset properties."""
        asset = self._document.ir.get_asset(asset_id)
        if asset:
            for key, value in kwargs.items():
                if hasattr(asset, key):
                    setattr(asset, key, value)
            self._document._notify_ir_changed("asset_updated")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Run Operations
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def start_run(self) -> bool:
        """
        Start script execution.

        Returns True if started successfully.
        """
        if self._is_running:
            return False

        # Validate first
        errors = self.validate()
        if any(d.severity.value == "error" for d in errors):
            return False

        self._is_running = True
        self.run_started.emit()

        # Convert IR to Script and start runner in thread
        from threading import Thread

        from core.dsl.adapter import ir_to_script

        try:
            script = ir_to_script(self._document.ir)

            # Create context and runner
            # Note: Real implementation needs vision/input services
            self._run_thread = Thread(
                target=self._run_worker,
                args=(script,),
                daemon=True,
            )
            self._run_thread.start()
        except Exception as e:
            self._is_running = False
            self.errors_found.emit([str(e)])
            return False

        return True

    def _run_worker(self, script: Any) -> None:
        """Worker thread for script execution."""
        try:
            # For now, just simulate execution
            import time

            from infra import get_logger

            logger = get_logger("IDEController")

            for flow in script.flows:
                if not self._is_running:
                    break
                logger.info(f"Executing flow: {flow.name}")
                for i, action in enumerate(flow.actions):
                    if not self._is_running:
                        break
                    logger.info(f"Step {i}: {action.action}")
                    time.sleep(0.1)  # Simulated execution

        finally:
            self._is_running = False
            self.run_stopped.emit()

    def stop_run(self) -> None:
        """Stop script execution."""
        if self._is_running:
            self._is_running = False
            self.run_stopped.emit()

    def pause_run(self) -> None:
        """Toggle pause on script execution."""
        # TODO: Implement pause with context
        pass

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Formatting
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def format_code(self) -> str:
        """
        Format the current code.

        Returns the formatted code.
        """
        from core.dsl.formatter import format_code

        formatted = format_code(self._document.code)
        self._document.update_from_code(formatted, source="format")
        return formatted


================================================================================
FILE PATH: app\main.py
LINES: 85
================================================================================

"""
RetroAuto v2 - Windows Automation Tool

Entry point for the application.
"""

import sys
from pathlib import Path

# Add project root to path for direct execution
_project_root = Path(__file__).parent.parent
if str(_project_root) not in sys.path:
    sys.path.insert(0, str(_project_root))

from PySide6.QtWidgets import QApplication, QStyleFactory  # noqa: E402

from app.ui.main_window import MainWindow  # noqa: E402
from infra import setup_logging  # noqa: E402
from infra.crash_handler import CrashHandler  # noqa: E402


def main() -> int:
    """Application entry point."""
    # Setup logging first
    logger = setup_logging()

    # Install Global Crash Handler
    CrashHandler.install()

    # Register cleanup handler for global hotkey listener
    import atexit
    def cleanup_hotkey_listener() -> None:
        """Ensure hotkey listener is stopped on exit."""
        try:
            from core.engine.hotkey_listener import get_hotkey_listener
            listener = get_hotkey_listener()
            if listener.is_running():
                listener.stop()
                logger.info("Hotkey listener cleaned up on exit")
        except Exception:
            pass  # Ignore errors during cleanup

    atexit.register(cleanup_hotkey_listener)

    logger.info("RetroAuto v2 starting...")

    # Check OCR availability
    try:
        from vision.ocr import TextReader

        reader = TextReader()
        if not reader.available:
            logger.warning("OCR (Tesseract) not available - ReadText actions will be disabled")
            logger.info(
                "To enable OCR, install Tesseract: https://github.com/tesseract-ocr/tesseract"
            )
        else:
            logger.info("OCR initialized successfully")
    except Exception as e:
        logger.warning(f"OCR initialization failed: {e}")

    # Create Qt application
    app = QApplication(sys.argv)

    # Apply Windows 95/98 style (Fusion for better QSS support, or keep Windows)
    app.setStyle(QStyleFactory.create("Fusion"))

    # Load Dark Theme
    theme_path = _project_root / "app" / "resources" / "dark_theme.qss"
    if theme_path.exists():
        app.setStyleSheet(theme_path.read_text(encoding="utf-8"))
        logger.info("Dark theme loaded")
    else:
        logger.warning(f"Theme file not found: {theme_path}")

    # Create and show main window
    window = MainWindow()
    window.show()

    logger.info("Main window displayed")
    return app.exec()


if __name__ == "__main__":
    sys.exit(main())


================================================================================
FILE PATH: app\ide\completion_provider.py
LINES: 241
================================================================================

"""
RetroAuto v2 - Auto-Completion Provider

Provides intelligent code completion for RetroScript.
Part of RetroScript Phase 5 - Advanced IDE Features.
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum, auto
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from core.dsl.ast import Program


class CompletionKind(Enum):
    """Types of completion items."""

    KEYWORD = auto()
    BUILTIN = auto()
    VARIABLE = auto()
    FLOW = auto()
    IMPORT = auto()
    SNIPPET = auto()


@dataclass
class CompletionItem:
    """A single completion suggestion."""

    label: str  # Display text
    kind: CompletionKind
    detail: str = ""  # Description
    insert_text: str | None = None  # Text to insert (if different from label)
    snippet: str | None = None  # Snippet with placeholders


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# RetroScript Keywords and Builtins
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

KEYWORDS = [
    # Core
    CompletionItem("flow", CompletionKind.KEYWORD, "Define a flow", "flow ${1:name} {\n\t$0\n}"),
    CompletionItem("hotkeys", CompletionKind.KEYWORD, "Define hotkeys"),
    CompletionItem("interrupt", CompletionKind.KEYWORD, "Define interrupt handler"),
    CompletionItem("const", CompletionKind.KEYWORD, "Constant declaration", "const ${1:NAME} = $0"),
    CompletionItem("let", CompletionKind.KEYWORD, "Variable declaration", "let ${1:name} = $0"),
    # Control flow
    CompletionItem("if", CompletionKind.KEYWORD, "Conditional", "if ${1:condition} {\n\t$0\n}"),
    CompletionItem("elif", CompletionKind.KEYWORD, "Else if"),
    CompletionItem("else", CompletionKind.KEYWORD, "Else branch"),
    CompletionItem(
        "while", CompletionKind.KEYWORD, "While loop", "while ${1:condition} {\n\t$0\n}"
    ),
    CompletionItem(
        "for", CompletionKind.KEYWORD, "For loop", "for ${1:i} in ${2:range(10)} {\n\t$0\n}"
    ),
    # RetroScript Phase 1
    CompletionItem("repeat", CompletionKind.KEYWORD, "Repeat N times", "repeat ${1:3} {\n\t$0\n}"),
    CompletionItem("retry", CompletionKind.KEYWORD, "Retry on error", "retry ${1:5} {\n\t$0\n}"),
    CompletionItem(
        "match", CompletionKind.KEYWORD, "Pattern matching", "match ${1:$result}: {\n\t$0\n}"
    ),
    CompletionItem("and", CompletionKind.KEYWORD, "Logical AND"),
    CompletionItem("or", CompletionKind.KEYWORD, "Logical OR"),
    CompletionItem("not", CompletionKind.KEYWORD, "Logical NOT"),
    CompletionItem("end", CompletionKind.KEYWORD, "End block"),
    # Phase 2
    CompletionItem("test", CompletionKind.KEYWORD, "Test block"),
    CompletionItem("mock", CompletionKind.KEYWORD, "Mock function"),
    CompletionItem("assert", CompletionKind.KEYWORD, "Assertion"),
    # Phase 3
    CompletionItem(
        "import", CompletionKind.KEYWORD, "Import module", 'import "${1:path}" as ${2:alias}'
    ),
    CompletionItem("as", CompletionKind.KEYWORD, "Alias"),
    # Control
    CompletionItem("break", CompletionKind.KEYWORD, "Break loop"),
    CompletionItem("continue", CompletionKind.KEYWORD, "Continue loop"),
    CompletionItem("return", CompletionKind.KEYWORD, "Return from flow"),
    CompletionItem("goto", CompletionKind.KEYWORD, "Jump to label"),
    CompletionItem("label", CompletionKind.KEYWORD, "Define label"),
    # Literals
    CompletionItem("true", CompletionKind.KEYWORD, "Boolean true"),
    CompletionItem("false", CompletionKind.KEYWORD, "Boolean false"),
    CompletionItem("null", CompletionKind.KEYWORD, "Null value"),
]

BUILTINS = [
    # Image functions
    CompletionItem("find", CompletionKind.BUILTIN, "Find image on screen", "find(${1:image})"),
    CompletionItem(
        "wait", CompletionKind.BUILTIN, "Wait for image", "wait(${1:image}, timeout=${2:10s})"
    ),
    CompletionItem("wait_image", CompletionKind.BUILTIN, "Wait for image (legacy)"),
    CompletionItem("find_image", CompletionKind.BUILTIN, "Find image (legacy)"),
    CompletionItem("image_exists", CompletionKind.BUILTIN, "Check if image exists"),
    CompletionItem("wait_any", CompletionKind.BUILTIN, "Wait for any of multiple images"),
    # Mouse actions
    CompletionItem("click", CompletionKind.BUILTIN, "Click at position", "click(${1:x}, ${2:y})"),
    CompletionItem("move", CompletionKind.BUILTIN, "Move mouse", "move(${1:x}, ${2:y})"),
    CompletionItem(
        "drag", CompletionKind.BUILTIN, "Drag from to", "drag(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2})"
    ),
    CompletionItem("scroll", CompletionKind.BUILTIN, "Scroll wheel", "scroll(${1:amount})"),
    # Keyboard actions
    CompletionItem("type", CompletionKind.BUILTIN, "Type text", 'type("${1:text}")'),
    CompletionItem("press", CompletionKind.BUILTIN, "Press key", 'press("${1:key}")'),
    CompletionItem("hotkey", CompletionKind.BUILTIN, "Key combination", 'hotkey("${1:ctrl+c}")'),
    # Utility
    CompletionItem("sleep", CompletionKind.BUILTIN, "Pause execution", "sleep(${1:1s})"),
    CompletionItem("log", CompletionKind.BUILTIN, "Log message", 'log("${1:message}")'),
    CompletionItem("run", CompletionKind.BUILTIN, "Run another flow", "run(${1:flow_name})"),
    CompletionItem("range", CompletionKind.BUILTIN, "Generate range", "range(${1:10})"),
]

DECORATORS = [
    CompletionItem("@test", CompletionKind.SNIPPET, "Test block", '@test "${1:name}" {\n\t$0\n}'),
    CompletionItem("@config", CompletionKind.SNIPPET, "Configuration", "@config {\n\t$0\n}"),
    CompletionItem(
        "@permissions", CompletionKind.SNIPPET, "Permissions", "@permissions {\n\t$0\n}"
    ),
    CompletionItem("@meta", CompletionKind.SNIPPET, "Metadata", "@meta {\n\t$0\n}"),
]


class CompletionProvider:
    """Provides auto-completion suggestions for RetroScript.

    Usage:
        provider = CompletionProvider()
        completions = provider.get_completions(code, cursor_position)
    """

    def __init__(self) -> None:
        self._all_items = KEYWORDS + BUILTINS + DECORATORS
        self._variables: set[str] = set()
        self._flows: set[str] = set()
        self._imports: dict[str, str] = {}  # alias -> path

    def update_context(self, program: Program | None) -> None:
        """Update completion context from parsed program."""
        if not program:
            return

        self._variables.clear()
        self._flows.clear()
        self._imports.clear()

        # Extract flows
        for flow in program.flows:
            self._flows.add(flow.name)

        # Extract imports
        for imp in program.imports:
            alias = imp.alias or imp.path.split("/")[-1]
            self._imports[alias] = imp.path

    def get_completions(
        self,
        prefix: str = "",
        include_variables: bool = True,
        include_flows: bool = True,
    ) -> list[CompletionItem]:
        """Get completion suggestions filtered by prefix.

        Args:
            prefix: Text to filter by (e.g., "re" -> "repeat", "retry")
            include_variables: Include $variables
            include_flows: Include flow names

        Returns:
            List of matching completion items
        """
        results: list[CompletionItem] = []
        prefix_lower = prefix.lower()

        # Filter static items
        for item in self._all_items:
            if item.label.lower().startswith(prefix_lower):
                results.append(item)

        # Add variables
        if include_variables and prefix.startswith("$"):
            var_prefix = prefix[1:].lower()
            for var in self._variables:
                if var.lower().startswith(var_prefix):
                    results.append(
                        CompletionItem(
                            f"${var}",
                            CompletionKind.VARIABLE,
                            "Variable",
                        )
                    )

        # Add flows
        if include_flows:
            for flow in self._flows:
                if flow.lower().startswith(prefix_lower):
                    results.append(
                        CompletionItem(
                            flow,
                            CompletionKind.FLOW,
                            "Flow",
                        )
                    )

        # Add imports
        for alias in self._imports:
            if alias.lower().startswith(prefix_lower):
                results.append(
                    CompletionItem(
                        alias,
                        CompletionKind.IMPORT,
                        f'import "{self._imports[alias]}"',
                    )
                )

        return results

    def add_variable(self, name: str) -> None:
        """Track a variable for completion."""
        # Remove $ prefix if present
        if name.startswith("$"):
            name = name[1:]
        self._variables.add(name)

    def get_decorator_completions(self) -> list[CompletionItem]:
        """Get decorator-specific completions."""
        return DECORATORS.copy()

    def get_keyword_completions(self) -> list[CompletionItem]:
        """Get all keyword completions."""
        return KEYWORDS.copy()

    def get_builtin_completions(self) -> list[CompletionItem]:
        """Get all builtin function completions."""
        return BUILTINS.copy()


================================================================================
FILE PATH: app\ide\debugger.py
LINES: 267
================================================================================

"""
RetroAuto v2 - Visual Debugger

Debugger foundation for RetroScript with breakpoints and step execution.
Part of RetroScript Phase 5 - Advanced IDE Features.
"""

from __future__ import annotations

from collections.abc import Callable
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from core.dsl.ast import ASTNode, Program


class DebugState(Enum):
    """Debugger execution state."""

    STOPPED = auto()  # Not running
    RUNNING = auto()  # Running normally
    PAUSED = auto()  # Paused at breakpoint
    STEPPING = auto()  # Single-step mode


class StepMode(Enum):
    """Step execution modes."""

    STEP_IN = auto()  # Step into function calls
    STEP_OVER = auto()  # Step over function calls
    STEP_OUT = auto()  # Step out of current function


@dataclass
class Breakpoint:
    """A debug breakpoint."""

    line: int
    file: str = ""
    condition: str | None = None  # Optional conditional expression
    enabled: bool = True
    hit_count: int = 0


@dataclass
class StackFrame:
    """A call stack frame."""

    name: str  # Flow/function name
    line: int
    file: str = ""
    locals: dict[str, Any] = field(default_factory=dict)


@dataclass
class DebugContext:
    """Current debug context with variables and call stack."""

    variables: dict[str, Any] = field(default_factory=dict)
    stack: list[StackFrame] = field(default_factory=list)
    current_line: int = 0
    current_file: str = ""


class Debugger:
    """Visual debugger for RetroScript.

    Provides:
    - Breakpoint management
    - Step execution (in/over/out)
    - Variable inspection
    - Call stack navigation

    Usage:
        debugger = Debugger()
        debugger.add_breakpoint(10)
        debugger.on_break = lambda ctx: print(f"Hit line {ctx.current_line}")
        debugger.start(program)
    """

    def __init__(self) -> None:
        self._breakpoints: dict[int, Breakpoint] = {}  # line -> breakpoint
        self._state = DebugState.STOPPED
        self._step_mode: StepMode | None = None
        self._context = DebugContext()

        # Callbacks
        self.on_break: Callable[[DebugContext], None] | None = None
        self.on_step: Callable[[DebugContext], None] | None = None
        self.on_variable_change: Callable[[str, Any], None] | None = None

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Breakpoint Management
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def add_breakpoint(
        self,
        line: int,
        file: str = "",
        condition: str | None = None,
    ) -> Breakpoint:
        """Add a breakpoint at the specified line."""
        bp = Breakpoint(line=line, file=file, condition=condition)
        self._breakpoints[line] = bp
        return bp

    def remove_breakpoint(self, line: int) -> bool:
        """Remove breakpoint at line. Returns True if removed."""
        if line in self._breakpoints:
            del self._breakpoints[line]
            return True
        return False

    def toggle_breakpoint(self, line: int) -> bool:
        """Toggle breakpoint at line. Returns new state."""
        if line in self._breakpoints:
            self._breakpoints[line].enabled = not self._breakpoints[line].enabled
            return self._breakpoints[line].enabled
        else:
            self.add_breakpoint(line)
            return True

    def get_breakpoints(self) -> list[Breakpoint]:
        """Get all breakpoints."""
        return list(self._breakpoints.values())

    def clear_breakpoints(self) -> None:
        """Remove all breakpoints."""
        self._breakpoints.clear()

    def has_breakpoint(self, line: int, enabled_only: bool = True) -> bool:
        """Check if line has a (enabled) breakpoint."""
        if line not in self._breakpoints:
            return False
        bp = self._breakpoints[line]
        return bp.enabled if enabled_only else True

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Execution Control
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def start(self, program: Program | None = None) -> None:
        """Start debugging session."""
        self._state = DebugState.RUNNING
        self._context = DebugContext()
        if program:
            self._context.stack.append(
                StackFrame(
                    name="<main>",
                    line=1,
                )
            )

    def stop(self) -> None:
        """Stop debugging session."""
        self._state = DebugState.STOPPED
        self._step_mode = None

    def pause(self) -> None:
        """Pause execution."""
        self._state = DebugState.PAUSED

    def resume(self) -> None:
        """Resume execution from pause."""
        self._state = DebugState.RUNNING
        self._step_mode = None

    def step_in(self) -> None:
        """Step into next statement."""
        self._state = DebugState.STEPPING
        self._step_mode = StepMode.STEP_IN

    def step_over(self) -> None:
        """Step over to next statement."""
        self._state = DebugState.STEPPING
        self._step_mode = StepMode.STEP_OVER

    def step_out(self) -> None:
        """Step out of current function."""
        self._state = DebugState.STEPPING
        self._step_mode = StepMode.STEP_OUT

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Runtime Hooks (called by engine)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def on_line(self, line: int, node: ASTNode | None = None) -> bool:
        """Called before executing each line.

        Returns:
            True to continue, False to pause
        """
        self._context.current_line = line

        # Check for breakpoint
        if self.has_breakpoint(line):
            bp = self._breakpoints[line]
            bp.hit_count += 1

            # Check condition if any
            if bp.condition:
                try:
                    if not self._evaluate_condition(bp.condition):
                        return True  # Condition not met
                except Exception:
                    pass  # Ignore condition errors

            self._state = DebugState.PAUSED
            if self.on_break:
                self.on_break(self._context)
            return False

        # Check for step mode
        if self._state == DebugState.STEPPING:
            self._state = DebugState.PAUSED
            if self.on_step:
                self.on_step(self._context)
            return False

        return True

    def on_enter_flow(self, name: str, line: int) -> None:
        """Called when entering a flow/function."""
        self._context.stack.append(StackFrame(name=name, line=line))

    def on_exit_flow(self) -> None:
        """Called when exiting a flow/function."""
        if self._context.stack:
            self._context.stack.pop()

    def set_variable(self, name: str, value: Any) -> None:
        """Track variable value."""
        old_value = self._context.variables.get(name)
        self._context.variables[name] = value

        if self.on_variable_change and old_value != value:
            self.on_variable_change(name, value)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Inspection
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def get_variables(self) -> dict[str, Any]:
        """Get all tracked variables."""
        return self._context.variables.copy()

    def get_stack(self) -> list[StackFrame]:
        """Get current call stack."""
        return self._context.stack.copy()

    def get_state(self) -> DebugState:
        """Get current debugger state."""
        return self._state

    def get_context(self) -> DebugContext:
        """Get full debug context."""
        return self._context

    def _evaluate_condition(self, condition: str) -> bool:
        """Evaluate a breakpoint condition."""
        # Simple evaluation using current variables
        try:
            return bool(eval(condition, {}, self._context.variables))
        except Exception:
            return False


================================================================================
FILE PATH: app\ide\formatter.py
LINES: 203
================================================================================

"""
RetroAuto v2 - Code Formatter

Code formatting for RetroScript with configurable style options.
Part of RetroScript Phase 5 - Advanced IDE Features.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    pass


@dataclass
class FormatOptions:
    """Code formatting options."""

    indent_size: int = 4
    use_tabs: bool = False
    max_line_length: int = 100
    space_before_colon: bool = False
    space_after_colon: bool = True
    blank_lines_between_flows: int = 2
    trailing_newline: bool = True


class Formatter:
    """Code formatter for RetroScript.

    Provides:
    - Indentation normalization
    - Statement spacing
    - Block formatting
    - Configurable style

    Usage:
        formatter = Formatter()
        formatted = formatter.format(code)
    """

    def __init__(self, options: FormatOptions | None = None) -> None:
        self.options = options or FormatOptions()

    def format(self, source: str) -> str:
        """Format RetroScript source code.

        Args:
            source: The source code to format

        Returns:
            Formatted source code
        """
        lines = source.split("\n")
        result: list[str] = []
        indent_level = 0
        last_line_blank = False
        last_was_block_end = False

        for line in lines:
            stripped = line.strip()

            # Handle empty lines
            if not stripped:
                if not last_line_blank and result:
                    result.append("")
                    last_line_blank = True
                continue

            last_line_blank = False

            # Handle multiline comments
            if "/*" in stripped and "*/" not in stripped:
                pass
            if "*/" in stripped:
                pass

            # Check for block end
            is_block_end = stripped.startswith("}") or stripped == "end"

            # Decrease indent before closing braces
            if is_block_end and indent_level > 0:
                indent_level -= 1

            # Format the line
            formatted_line = self._format_line(stripped, indent_level)

            # Add blank line before flow if needed
            if stripped.startswith("flow ") and result and not last_was_block_end:
                for _ in range(self.options.blank_lines_between_flows):
                    if result and result[-1] != "":
                        result.append("")

            result.append(formatted_line)

            # Increase indent after opening braces/colons
            if stripped.endswith("{") or (stripped.endswith(":") and not stripped.startswith("#")):
                indent_level += 1

            last_was_block_end = is_block_end

        # Trailing newline
        if self.options.trailing_newline and result and result[-1] != "":
            result.append("")

        return "\n".join(result)

    def _format_line(self, line: str, indent_level: int) -> str:
        """Format a single line with proper indentation."""
        # Create indent
        if self.options.use_tabs:
            indent = "\t" * indent_level
        else:
            indent = " " * (self.options.indent_size * indent_level)

        # Format the content
        formatted = self._format_content(line)

        return indent + formatted

    def _format_content(self, content: str) -> str:
        """Format the content of a line (operators, spacing)."""
        result = content

        # Format colon spacing
        if ":" in result and not result.startswith("#") and not result.startswith("//"):
            parts = result.split(":")
            if len(parts) == 2 and not parts[1].startswith("/"):  # Not a URL
                before = (
                    parts[0].rstrip()
                    if not self.options.space_before_colon
                    else parts[0].rstrip() + " "
                )
                after = (
                    " " + parts[1].strip() if self.options.space_after_colon else parts[1].strip()
                )
                if parts[1].strip():  # Only if there's content after  # noqa: SIM108
                    result = before + ":" + after
                else:
                    result = before + ":"

        # Normalize operator spacing
        operators = ["==", "!=", "<=", ">=", "&&", "||", "->", "‚Üí"]
        for op in operators:
            if op in result:
                result = result.replace(f" {op}", op)
                result = result.replace(f"{op} ", op)
                result = result.replace(op, f" {op} ")

        # Clean up multiple spaces
        while "  " in result:
            result = result.replace("  ", " ")

        return result.strip()

    def format_selection(self, source: str, start_line: int, end_line: int) -> str:
        """Format only a selection of lines.

        Preserves structure outside the selection.
        """
        lines = source.split("\n")

        # Calculate base indent from first selected line
        if start_line < len(lines):
            first_line = lines[start_line]
            base_indent = len(first_line) - len(first_line.lstrip())
        else:
            base_indent = 0

        # Format selected lines
        selected = "\n".join(lines[start_line : end_line + 1])
        formatted_selected = self.format(selected)
        formatted_lines = formatted_selected.split("\n")

        # Re-apply base indent
        reindented = []
        for line in formatted_lines:
            if line.strip():
                reindented.append(" " * base_indent + line)
            else:
                reindented.append("")

        # Combine with rest
        result = lines[:start_line] + reindented + lines[end_line + 1 :]
        return "\n".join(result)

    def get_indent(self, line: str) -> int:
        """Get the indentation level of a line."""
        stripped = line.lstrip()
        indent_chars = len(line) - len(stripped)

        if self.options.use_tabs:
            return indent_chars  # Each tab is one level
        else:
            return indent_chars // self.options.indent_size


# Convenience function
def format_code(source: str, options: FormatOptions | None = None) -> str:
    """Format RetroScript code with optional style settings."""
    return Formatter(options).format(source)


================================================================================
FILE PATH: app\ide\quick_fixes.py
LINES: 427
================================================================================

"""
RetroAuto v2 - Error Quick-Fixes

Provides intelligent error detection and fix suggestions.
Part of RetroScript Phase 6 - Error Handling + Templates.
"""

from __future__ import annotations

import re
from collections.abc import Callable
from dataclasses import dataclass
from difflib import get_close_matches
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from core.dsl.diagnostics import Diagnostic


@dataclass
class QuickFix:
    """A suggested fix for an error."""

    title: str  # Display title
    description: str  # Detailed description
    replacement: str  # Text to replace with
    start_line: int
    end_line: int
    start_col: int = 0
    end_col: int = -1  # -1 means end of line


@dataclass
class ErrorPattern:
    """Pattern for detecting common errors."""

    code: str  # Error code to match
    pattern: str | None  # Regex pattern for message
    fixer: Callable[[str, int, int], list[QuickFix]]  # Fix generator


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# RetroScript Keywords for typo detection
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

KEYWORDS = [
    "flow",
    "interrupt",
    "hotkeys",
    "const",
    "let",
    "if",
    "elif",
    "else",
    "while",
    "for",
    "in",
    "try",
    "catch",
    "break",
    "continue",
    "return",
    "repeat",
    "retry",
    "match",
    "and",
    "or",
    "not",
    "end",
    "import",
    "as",
    "test",
    "mock",
    "assert",
    "config",
    "permissions",
    "meta",
    "true",
    "false",
    "null",
]

BUILTINS = [
    "find",
    "wait",
    "click",
    "type",
    "press",
    "sleep",
    "scroll",
    "drag",
    "run",
    "log",
    "range",
    "wait_image",
    "find_image",
    "image_exists",
    "move",
    "hotkey",
    "type_text",
]


class QuickFixProvider:
    """Provides quick fixes for common RetroScript errors.

    Usage:
        provider = QuickFixProvider()
        fixes = provider.get_fixes(diagnostic, source_line)
    """

    def __init__(self) -> None:
        self._patterns: list[ErrorPattern] = []
        self._init_patterns()

    def _init_patterns(self) -> None:
        """Initialize error patterns."""
        # Undefined variable/function
        self._patterns.append(
            ErrorPattern(
                code="E1001",
                pattern=r"Unexpected token '(\w+)'",
                fixer=self._fix_typo,
            )
        )

        # Missing semicolon
        self._patterns.append(
            ErrorPattern(
                code="E1002",
                pattern=r"Expected ';'",
                fixer=self._fix_missing_semicolon,
            )
        )

        # Missing brace
        self._patterns.append(
            ErrorPattern(
                code="E1003",
                pattern=r"Expected '\}'",
                fixer=self._fix_missing_brace,
            )
        )

        # Missing colon
        self._patterns.append(
            ErrorPattern(
                code="E1004",
                pattern=r"Expected ':'",
                fixer=self._fix_missing_colon,
            )
        )

    def get_fixes(
        self,
        diagnostic: Diagnostic,
        source_line: str,
    ) -> list[QuickFix]:
        """Get quick fixes for a diagnostic.

        Args:
            diagnostic: The error diagnostic
            source_line: The source line with the error

        Returns:
            List of applicable quick fixes
        """
        fixes: list[QuickFix] = []

        for pattern in self._patterns:
            if pattern.code and diagnostic.code != pattern.code:
                continue

            if pattern.pattern:
                match = re.search(pattern.pattern, diagnostic.message)
                if not match:
                    continue

            try:
                pattern_fixes = pattern.fixer(
                    source_line,
                    diagnostic.span.start_line,
                    diagnostic.span.start_col,
                )
                fixes.extend(pattern_fixes)
            except Exception:
                pass  # Silently ignore fixer errors

        return fixes

    def _fix_typo(
        self,
        source_line: str,
        line: int,
        col: int,
    ) -> list[QuickFix]:
        """Suggest fixes for potential typos."""
        fixes: list[QuickFix] = []

        # Extract word at error position
        words = re.findall(r"\b\w+\b", source_line)
        if not words:
            return fixes

        # Find word at position
        pos = 0
        typo_word = None
        typo_start = 0
        for word in words:
            start = source_line.find(word, pos)
            end = start + len(word)
            if start <= col < end:
                typo_word = word
                typo_start = start
                break
            pos = end

        if not typo_word:
            return fixes

        # Find similar keywords
        all_words = KEYWORDS + BUILTINS
        matches = get_close_matches(typo_word.lower(), all_words, n=3, cutoff=0.6)

        for match in matches:
            fixes.append(
                QuickFix(
                    title=f"Change to '{match}'",
                    description=f"Did you mean '{match}'?",
                    replacement=match,
                    start_line=line,
                    end_line=line,
                    start_col=typo_start,
                    end_col=typo_start + len(typo_word),
                )
            )

        return fixes

    def _fix_missing_semicolon(
        self,
        source_line: str,
        line: int,
        col: int,
    ) -> list[QuickFix]:
        """Suggest adding missing semicolon."""
        return [
            QuickFix(
                title="Add semicolon",
                description="Add ';' at end of statement",
                replacement=source_line.rstrip() + ";",
                start_line=line,
                end_line=line,
            )
        ]

    def _fix_missing_brace(
        self,
        source_line: str,
        line: int,
        col: int,
    ) -> list[QuickFix]:
        """Suggest adding missing closing brace."""
        # Count opening braces in line
        opens = source_line.count("{")
        closes = source_line.count("}")

        if opens > closes:
            return [
                QuickFix(
                    title="Add closing brace",
                    description="Add '}' to close block",
                    replacement=source_line.rstrip() + "\n}",
                    start_line=line,
                    end_line=line,
                )
            ]
        return []

    def _fix_missing_colon(
        self,
        source_line: str,
        line: int,
        col: int,
    ) -> list[QuickFix]:
        """Suggest adding missing colon for RetroScript blocks."""
        # Check if line ends with block keyword
        stripped = source_line.rstrip()
        block_keywords = ["repeat", "retry", "match", "if", "elif", "else", "while", "for"]

        for kw in block_keywords:
            if (
                stripped.startswith(kw)
                and not stripped.endswith(":")
                and not stripped.endswith("{")
            ):
                return [
                    QuickFix(
                        title="Add colon",
                        description="Add ':' after block keyword",
                        replacement=stripped + ":",
                        start_line=line,
                        end_line=line,
                    )
                ]
        return []


class LiveValidator:
    """Real-time validation for RetroScript code.

    Usage:
        validator = LiveValidator()
        errors = validator.validate(source)
    """

    def __init__(self) -> None:
        self._defined_variables: set[str] = set()
        self._defined_flows: set[str] = set()

    def validate(self, source: str) -> list[ValidationError]:
        """Validate source code and return errors.

        Args:
            source: RetroScript source code

        Returns:
            List of validation errors
        """
        errors: list[ValidationError] = []
        lines = source.split("\n")

        self._defined_variables.clear()
        self._defined_flows.clear()

        # First pass: collect definitions
        for _, line in enumerate(lines, 1):
            self._collect_definitions(line)

        # Second pass: validate usage
        for i, line in enumerate(lines, 1):
            line_errors = self._validate_line(line, i)
            errors.extend(line_errors)

        return errors

    def _collect_definitions(self, line: str) -> None:
        """Collect variable and flow definitions from a line."""
        stripped = line.strip()

        # Flow definitions
        if stripped.startswith("flow "):
            match = re.match(r"flow\s+(\w+)", stripped)
            if match:
                self._defined_flows.add(match.group(1))

        # Variable assignments
        var_match = re.match(r"\$(\w+)\s*=", stripped)
        if var_match:
            self._defined_variables.add(var_match.group(1))

        # let declarations
        let_match = re.match(r"let\s+(\w+)", stripped)
        if let_match:
            self._defined_variables.add(let_match.group(1))

    def _validate_line(self, line: str, line_num: int) -> list[ValidationError]:
        """Validate a single line."""
        errors: list[ValidationError] = []
        stripped = line.strip()

        # Skip comments
        if stripped.startswith("//") or stripped.startswith("#"):
            return errors

        # Check for undefined variables
        var_uses = re.findall(r"\$(\w+)", stripped)
        for var in var_uses:
            # Skip if it's an assignment
            if re.match(rf"\${var}\s*=", stripped):
                continue
            if var not in self._defined_variables:
                errors.append(
                    ValidationError(
                        message=f"Undefined variable: ${var}",
                        line=line_num,
                        severity="warning",
                        suggestion=f"Did you mean to define it? Use: ${var} = value",
                    )
                )

        # Check for unclosed braces
        if stripped.count("{") > stripped.count("}") and not stripped.endswith("{"):
            errors.append(
                ValidationError(
                    message="Possible unclosed brace",
                    line=line_num,
                    severity="warning",
                )
            )

        # Check for typos in keywords
        words = re.findall(r"\b([a-z_]+)\b", stripped.lower())
        all_keywords = set(KEYWORDS + BUILTINS)
        for word in words:
            if len(word) > 3 and word not in all_keywords:
                matches = get_close_matches(word, list(all_keywords), n=1, cutoff=0.85)
                if matches and matches[0] != word:
                    errors.append(
                        ValidationError(
                            message=f"Possible typo: '{word}'. Did you mean '{matches[0]}'?",
                            line=line_num,
                            severity="hint",
                        )
                    )

        return errors


@dataclass
class ValidationError:
    """A validation error or warning."""

    message: str
    line: int
    severity: str = "error"  # error, warning, hint
    suggestion: str | None = None


================================================================================
FILE PATH: app\ide\snippets.py
LINES: 402
================================================================================

"""
RetroAuto v2 - Code Snippets Library

Pre-built code templates and patterns for common automation tasks.
Part of RetroScript Phase 6 - Error Handling + Templates.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum, auto


class SnippetCategory(Enum):
    """Categories for code snippets."""

    BASIC = auto()  # Basic patterns
    GAME_BOT = auto()  # Game automation
    SCRAPER = auto()  # Data scraping
    UTILITY = auto()  # Utility functions
    ERROR_HANDLING = auto()  # Error handling patterns
    TESTING = auto()  # Test patterns


@dataclass
class Snippet:
    """A code snippet template."""

    name: str
    description: str
    category: SnippetCategory
    prefix: str  # Trigger prefix (e.g., "repeat")
    body: str  # Template body with ${placeholders}
    placeholders: dict[str, str] = field(default_factory=dict)  # Default values


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Basic Patterns
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

BASIC_SNIPPETS = [
    Snippet(
        name="Flow Definition",
        description="Create a new flow",
        category=SnippetCategory.BASIC,
        prefix="flow",
        body="""flow ${1:name} {
    ${0}
}""",
    ),
    Snippet(
        name="Repeat Loop",
        description="Repeat block N times",
        category=SnippetCategory.BASIC,
        prefix="repeat",
        body="""repeat ${1:3} {
    ${0}
}""",
    ),
    Snippet(
        name="Retry Block",
        description="Retry on error with count",
        category=SnippetCategory.BASIC,
        prefix="retry",
        body="""retry ${1:5} {
    ${0}
}""",
    ),
    Snippet(
        name="If Statement",
        description="Conditional statement",
        category=SnippetCategory.BASIC,
        prefix="if",
        body="""if ${1:condition} {
    ${0}
}""",
    ),
    Snippet(
        name="If-Else Statement",
        description="Conditional with else branch",
        category=SnippetCategory.BASIC,
        prefix="ifelse",
        body="""if ${1:condition} {
    ${2}
} else {
    ${0}
}""",
    ),
    Snippet(
        name="For Loop",
        description="Iterate over range",
        category=SnippetCategory.BASIC,
        prefix="for",
        body="""for ${1:i} in range(${2:10}) {
    ${0}
}""",
    ),
    Snippet(
        name="While Loop",
        description="Loop while condition",
        category=SnippetCategory.BASIC,
        prefix="while",
        body="""while ${1:condition} {
    ${0}
}""",
    ),
    Snippet(
        name="Try-Catch",
        description="Error handling block",
        category=SnippetCategory.BASIC,
        prefix="try",
        body="""try {
    ${1}
} catch ${2:err} {
    log("Error: " + ${2:err})
    ${0}
}""",
    ),
    Snippet(
        name="Import Module",
        description="Import external module",
        category=SnippetCategory.BASIC,
        prefix="import",
        body="""import "${1:path/to/module}" as ${2:alias}""",
    ),
]

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Game Bot Patterns
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

GAME_BOT_SNIPPETS = [
    Snippet(
        name="Click Target",
        description="Find and click target",
        category=SnippetCategory.GAME_BOT,
        prefix="clicktarget",
        body="""$target = find(${1:button_img})
if $target {
    click($target.x, $target.y)
    sleep(${2:500ms})
}""",
    ),
    Snippet(
        name="Combat Loop",
        description="Basic combat automation loop",
        category=SnippetCategory.GAME_BOT,
        prefix="combat",
        body="""# Combat automation loop
repeat ${1:100} {
    $enemy = find(enemy_img)
    if $enemy {
        click($enemy.x, $enemy.y)
        sleep(${2:200ms})

        # Use skills
        press("${3:1}")
        sleep(${4:1s})
    }

    # Random delay for anti-detection
    sleep(${5:500ms})
}""",
    ),
    Snippet(
        name="Resource Gathering",
        description="Gather resources in game",
        category=SnippetCategory.GAME_BOT,
        prefix="gather",
        body="""# Resource gathering loop
flow gather_resources {
    repeat ${1:50} {
        $resource = find(${2:ore_img})
        if $resource {
            click($resource.x, $resource.y)
            sleep(${3:3s})  # Wait for gathering
        } else {
            # Move to next area
            press("w")
            sleep(${4:2s})
        }
    }
}""",
    ),
    Snippet(
        name="Anti-AFK",
        description="Prevent AFK detection",
        category=SnippetCategory.GAME_BOT,
        prefix="antiafk",
        body="""# Anti-AFK movement
flow anti_afk {
    while true {
        # Random movement
        $keys = ["w", "a", "s", "d"]
        $key = $keys[random(0, 3)]
        press($key)
        sleep(${1:100ms})

        # Wait before next action
        sleep(${2:30s})
    }
}""",
    ),
    Snippet(
        name="Inventory Check",
        description="Check and manage inventory",
        category=SnippetCategory.GAME_BOT,
        prefix="inventory",
        body="""# Open and check inventory
press("${1:i}")  # Open inventory
sleep(${2:500ms})

$item = find(${3:target_item})
if $item {
    click($item.x, $item.y)
    ${0}
}

press("${1:i}")  # Close inventory""",
    ),
]

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Error Handling Patterns
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

ERROR_HANDLING_SNIPPETS = [
    Snippet(
        name="Retry with Fallback",
        description="Retry with fallback action",
        category=SnippetCategory.ERROR_HANDLING,
        prefix="retryfallback",
        body="""retry ${1:3} {
    ${2:primary_action}
} else {
    log("Retry failed, using fallback")
    ${0:fallback_action}
}""",
    ),
    Snippet(
        name="Safe Click",
        description="Click with existence check",
        category=SnippetCategory.ERROR_HANDLING,
        prefix="safeclick",
        body="""$target = find(${1:button})
if $target {
    click($target.x, $target.y)
} else {
    log("Target not found: ${1:button}")
    ${0}
}""",
    ),
    Snippet(
        name="Wait with Timeout",
        description="Wait for target with timeout",
        category=SnippetCategory.ERROR_HANDLING,
        prefix="waittimeout",
        body="""$result = wait(${1:target}, timeout=${2:10s})
match $result:
    Found: ${3:success_action}
    Timeout: ${0:timeout_action}""",
    ),
]

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Testing Patterns
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

TESTING_SNIPPETS = [
    Snippet(
        name="Test Block",
        description="Create a test block",
        category=SnippetCategory.TESTING,
        prefix="test",
        body="""@test "${1:test name}" {
    ${0}
    assert ${2:condition}
}""",
    ),
    Snippet(
        name="Mock Function",
        description="Mock a function for testing",
        category=SnippetCategory.TESTING,
        prefix="mock",
        body="""@test "${1:test name}" {
    mock find(${2:target}) -> Found(${3:100}, ${4:200})
    ${0}
}""",
    ),
]

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Utility Patterns
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

UTILITY_SNIPPETS = [
    Snippet(
        name="Random Delay",
        description="Sleep for random duration",
        category=SnippetCategory.UTILITY,
        prefix="randomsleep",
        body="""sleep(${1:500ms} + random(0, ${2:500})ms)""",
    ),
    Snippet(
        name="Log with Timestamp",
        description="Log message with timestamp",
        category=SnippetCategory.UTILITY,
        prefix="logts",
        body="""log("[" + timestamp() + "] ${1:message}")""",
    ),
    Snippet(
        name="Screen Region",
        description="Search in specific region",
        category=SnippetCategory.UTILITY,
        prefix="region",
        body="""$result = find(${1:target}, roi=(${2:x}, ${3:y}, ${4:width}, ${5:height}))""",
    ),
]


class SnippetLibrary:
    """Library of code snippets for RetroScript.

    Usage:
        library = SnippetLibrary()
        snippets = library.search("combat")
        snippet = library.get_by_prefix("repeat")
    """

    def __init__(self) -> None:
        self._snippets: list[Snippet] = []
        self._by_prefix: dict[str, Snippet] = {}
        self._load_default_snippets()

    def _load_default_snippets(self) -> None:
        """Load all default snippets."""
        all_snippets = (
            BASIC_SNIPPETS
            + GAME_BOT_SNIPPETS
            + ERROR_HANDLING_SNIPPETS
            + TESTING_SNIPPETS
            + UTILITY_SNIPPETS
        )
        for snippet in all_snippets:
            self.add(snippet)

    def add(self, snippet: Snippet) -> None:
        """Add a snippet to the library."""
        self._snippets.append(snippet)
        self._by_prefix[snippet.prefix] = snippet

    def get_by_prefix(self, prefix: str) -> Snippet | None:
        """Get snippet by trigger prefix."""
        return self._by_prefix.get(prefix)

    def search(self, query: str) -> list[Snippet]:
        """Search snippets by name, description, or prefix."""
        query_lower = query.lower()
        results = []
        for snippet in self._snippets:
            if (
                query_lower in snippet.name.lower()
                or query_lower in snippet.description.lower()
                or query_lower in snippet.prefix.lower()
            ):
                results.append(snippet)
        return results

    def get_by_category(self, category: SnippetCategory) -> list[Snippet]:
        """Get all snippets in a category."""
        return [s for s in self._snippets if s.category == category]

    def get_all(self) -> list[Snippet]:
        """Get all snippets."""
        return self._snippets.copy()

    def expand(self, prefix: str, values: dict[str, str] | None = None) -> str | None:
        """Expand a snippet with given placeholder values.

        Args:
            prefix: Snippet trigger prefix
            values: Dict of placeholder index to value (e.g., {"1": "my_value"})

        Returns:
            Expanded snippet body or None if not found
        """
        snippet = self.get_by_prefix(prefix)
        if not snippet:
            return None

        result = snippet.body
        if values:
            for key, value in values.items():
                result = result.replace(f"${{{key}}}", value)
                result = result.replace(f"${key}", value)

        # Remove remaining placeholders
        import re

        result = re.sub(r"\$\{?\d+:?[^}]*\}?", "", result)

        return result


================================================================================
FILE PATH: app\tools\bundler.py
LINES: 299
================================================================================

"""
RetroAuto v2 - Script Bundler

Package scripts for distribution with dependencies.
Part of RetroScript Phase 8 - Runtime + Distribution.
"""

from __future__ import annotations

import json
import shutil
import zipfile
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any


@dataclass
class BundleManifest:
    """Manifest for a bundled script package."""

    name: str
    version: str
    entry_point: str
    created_at: str = ""
    author: str = ""
    description: str = ""
    dependencies: list[str] = field(default_factory=list)
    files: list[str] = field(default_factory=list)
    assets: list[str] = field(default_factory=list)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "name": self.name,
            "version": self.version,
            "entry_point": self.entry_point,
            "created_at": self.created_at,
            "author": self.author,
            "description": self.description,
            "dependencies": self.dependencies,
            "files": self.files,
            "assets": self.assets,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> BundleManifest:
        """Create from dictionary."""
        return cls(
            name=data.get("name", "unknown"),
            version=data.get("version", "1.0.0"),
            entry_point=data.get("entry_point", "main.retro"),
            created_at=data.get("created_at", ""),
            author=data.get("author", ""),
            description=data.get("description", ""),
            dependencies=data.get("dependencies", []),
            files=data.get("files", []),
            assets=data.get("assets", []),
        )


@dataclass
class BundleOptions:
    """Options for bundling scripts."""

    include_assets: bool = True
    include_libs: bool = True
    compress: bool = True
    minify: bool = False  # Future: minify code
    output_format: str = "zip"  # zip, folder


class Bundler:
    """Bundle RetroScript projects for distribution.

    Usage:
        bundler = Bundler()
        bundler.bundle("/path/to/project", "/path/to/output.zip")
    """

    def __init__(self, options: BundleOptions | None = None) -> None:
        self.options = options or BundleOptions()

    def bundle(
        self,
        project_dir: str | Path,
        output_path: str | Path | None = None,
    ) -> Path:
        """Bundle a project.

        Args:
            project_dir: Path to project directory
            output_path: Output file/directory path

        Returns:
            Path to created bundle
        """
        project_dir = Path(project_dir)
        if not project_dir.exists():
            raise BundleError(f"Project directory not found: {project_dir}")

        # Read project config
        config = self._read_config(project_dir)

        # Create manifest
        manifest = BundleManifest(
            name=config.get("name", project_dir.name),
            version=config.get("version", "1.0.0"),
            entry_point=config.get("entry_point", "main.retro"),
            created_at=datetime.now().isoformat(),
            author=config.get("author", ""),
            description=config.get("description", ""),
        )

        # Collect files
        files_to_bundle: list[tuple[Path, str]] = []

        # Main entry point
        entry_path = project_dir / manifest.entry_point
        if entry_path.exists():
            files_to_bundle.append((entry_path, manifest.entry_point))
            manifest.files.append(manifest.entry_point)

        # Collect .retro files
        for retro_file in project_dir.glob("**/*.retro"):
            if retro_file != entry_path:
                rel_path = retro_file.relative_to(project_dir)
                files_to_bundle.append((retro_file, str(rel_path)))
                manifest.files.append(str(rel_path))

        # Collect lib files
        if self.options.include_libs:
            lib_dir = project_dir / "lib"
            if lib_dir.exists():
                for lib_file in lib_dir.glob("**/*.retro"):
                    rel_path = lib_file.relative_to(project_dir)
                    files_to_bundle.append((lib_file, str(rel_path)))
                    manifest.files.append(str(rel_path))
                    manifest.dependencies.append(str(rel_path))

        # Collect assets
        if self.options.include_assets:
            assets_dir = project_dir / "assets"
            if assets_dir.exists():
                for asset in assets_dir.glob("**/*"):
                    if asset.is_file():
                        rel_path = asset.relative_to(project_dir)
                        files_to_bundle.append((asset, str(rel_path)))
                        manifest.assets.append(str(rel_path))

        # Determine output path
        if not output_path:
            output_path = project_dir.parent / f"{manifest.name}-{manifest.version}.retrobundle"
        else:
            output_path = Path(output_path)

        # Create bundle
        if self.options.output_format == "folder":
            return self._bundle_to_folder(output_path, files_to_bundle, manifest)
        else:
            return self._bundle_to_zip(output_path, files_to_bundle, manifest)

    def _read_config(self, project_dir: Path) -> dict[str, Any]:
        """Read project configuration."""
        config_path = project_dir / "retro.toml"
        if not config_path.exists():
            return {}

        # Simple TOML-like parsing
        config: dict[str, Any] = {}
        current_section = config

        for line in config_path.read_text(encoding="utf-8").splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue

            if line.startswith("[") and line.endswith("]"):
                section_name = line[1:-1]
                config[section_name] = {}
                current_section = config[section_name]
            elif "=" in line:
                key, value = line.split("=", 1)
                key = key.strip()
                value = value.strip().strip('"')
                current_section[key] = value

        # Flatten for simple access
        if "project" in config:
            config.update(config["project"])
        if "script" in config:
            config.update(config["script"])

        return config

    def _bundle_to_zip(
        self,
        output_path: Path,
        files: list[tuple[Path, str]],
        manifest: BundleManifest,
    ) -> Path:
        """Create ZIP bundle."""
        output_path = output_path.with_suffix(".retrobundle")

        compression = zipfile.ZIP_DEFLATED if self.options.compress else zipfile.ZIP_STORED

        with zipfile.ZipFile(output_path, "w", compression) as zf:
            # Add manifest
            manifest_json = json.dumps(manifest.to_dict(), indent=2)
            zf.writestr("manifest.json", manifest_json)

            # Add files
            for file_path, archive_name in files:
                zf.write(file_path, archive_name)

        return output_path

    def _bundle_to_folder(
        self,
        output_path: Path,
        files: list[tuple[Path, str]],
        manifest: BundleManifest,
    ) -> Path:
        """Create folder bundle."""
        output_path.mkdir(parents=True, exist_ok=True)

        # Write manifest
        manifest_path = output_path / "manifest.json"
        manifest_path.write_text(json.dumps(manifest.to_dict(), indent=2), encoding="utf-8")

        # Copy files
        for file_path, rel_name in files:
            dest = output_path / rel_name
            dest.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(file_path, dest)

        return output_path

    def unbundle(
        self,
        bundle_path: str | Path,
        output_dir: str | Path | None = None,
    ) -> Path:
        """Extract a bundle.

        Args:
            bundle_path: Path to bundle file
            output_dir: Output directory

        Returns:
            Path to extracted directory
        """
        bundle_path = Path(bundle_path)
        if not bundle_path.exists():
            raise BundleError(f"Bundle not found: {bundle_path}")

        # Determine output directory
        output_dir = bundle_path.parent / bundle_path.stem if not output_dir else Path(output_dir)

        output_dir.mkdir(parents=True, exist_ok=True)

        # Extract
        with zipfile.ZipFile(bundle_path, "r") as zf:
            zf.extractall(output_dir)

        return output_dir

    def get_manifest(self, bundle_path: str | Path) -> BundleManifest:
        """Read manifest from a bundle.

        Args:
            bundle_path: Path to bundle file

        Returns:
            Bundle manifest
        """
        bundle_path = Path(bundle_path)

        with zipfile.ZipFile(bundle_path, "r") as zf:
            manifest_data = json.loads(zf.read("manifest.json"))
            return BundleManifest.from_dict(manifest_data)


class BundleError(Exception):
    """Error during bundling operations."""

    pass


def bundle_project(project_dir: str | Path, output: str | Path | None = None) -> str:
    """Convenience function to bundle a project.

    Returns:
        Path to created bundle
    """
    bundler = Bundler()
    result = bundler.bundle(project_dir, output)
    return str(result)


================================================================================
FILE PATH: app\tools\doc_generator.py
LINES: 299
================================================================================

"""
RetroAuto v2 - Documentation Generator

Generate documentation from RetroScript code and comments.
Part of RetroScript Phase 7 - Tools + Productivity.
"""

from __future__ import annotations

import re
from dataclasses import dataclass, field
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    pass


@dataclass
class FlowDoc:
    """Documentation for a single flow."""

    name: str
    description: str = ""
    params: list[tuple[str, str]] = field(default_factory=list)  # (name, desc)
    returns: str = ""
    examples: list[str] = field(default_factory=list)
    tags: list[str] = field(default_factory=list)


@dataclass
class ModuleDoc:
    """Documentation for a module/file."""

    name: str
    description: str = ""
    flows: list[FlowDoc] = field(default_factory=list)
    constants: list[tuple[str, str, str]] = field(default_factory=list)  # (name, value, desc)
    imports: list[str] = field(default_factory=list)


class DocGenerator:
    """Generate documentation from RetroScript code.

    Usage:
        gen = DocGenerator()
        doc = gen.generate(source)
        markdown = gen.to_markdown(doc)
    """

    def __init__(self) -> None:
        self._doc_comment_pattern = re.compile(r"^\s*#\s*(.*)$")
        self._tag_pattern = re.compile(r"@(\w+)\s*(.*)")

    def generate(self, source: str) -> ModuleDoc:
        """Generate documentation from source code.

        Args:
            source: RetroScript source code

        Returns:
            ModuleDoc with extracted documentation
        """
        lines = source.split("\n")
        doc = ModuleDoc(name="module")

        i = 0
        current_comments: list[str] = []

        while i < len(lines):
            line = lines[i].strip()

            # Collect doc comments
            if line.startswith("#"):
                comment = line[1:].strip()
                current_comments.append(comment)
                i += 1
                continue

            # Flow definition
            if line.startswith("flow "):
                flow_doc = self._parse_flow(line, current_comments)
                doc.flows.append(flow_doc)
                current_comments = []

            # Constant definition
            elif line.startswith("const "):
                const_doc = self._parse_const(line, current_comments)
                if const_doc:
                    doc.constants.append(const_doc)
                current_comments = []

            # Import statement
            elif line.startswith("import "):
                match = re.search(r'import\s+"([^"]+)"', line)
                if match:
                    doc.imports.append(match.group(1))
                current_comments = []

            # Module-level description (first comment block)
            elif not doc.description and current_comments:
                doc.description = "\n".join(current_comments)
                current_comments = []

            else:
                current_comments = []

            i += 1

        return doc

    def _parse_flow(self, line: str, comments: list[str]) -> FlowDoc:
        """Parse a flow definition with its doc comments."""
        # Extract flow name
        match = re.match(r"flow\s+(\w+)", line)
        name = match.group(1) if match else "unknown"

        flow_doc = FlowDoc(name=name)

        # Parse doc comments
        description_lines = []
        for comment in comments:
            # Check for tags
            tag_match = self._tag_pattern.match(comment)
            if tag_match:
                tag, value = tag_match.groups()
                if tag == "param":
                    parts = value.split(" ", 1)
                    param_name = parts[0] if parts else ""
                    param_desc = parts[1] if len(parts) > 1 else ""
                    flow_doc.params.append((param_name, param_desc))
                elif tag == "returns" or tag == "return":
                    flow_doc.returns = value
                elif tag == "example":
                    flow_doc.examples.append(value)
                elif tag == "tag":
                    flow_doc.tags.append(value)
                else:
                    flow_doc.tags.append(f"{tag}: {value}")
            else:
                description_lines.append(comment)

        flow_doc.description = "\n".join(description_lines)
        return flow_doc

    def _parse_const(
        self,
        line: str,
        comments: list[str],
    ) -> tuple[str, str, str] | None:
        """Parse a constant definition."""
        match = re.match(r"const\s+(\w+)\s*=\s*(.+)", line)
        if not match:
            return None

        name = match.group(1)
        value = match.group(2).rstrip(";")
        description = " ".join(comments) if comments else ""

        return (name, value, description)

    def to_markdown(self, doc: ModuleDoc) -> str:
        """Convert ModuleDoc to Markdown format.

        Args:
            doc: The documentation to convert

        Returns:
            Markdown formatted documentation
        """
        lines: list[str] = []

        # Title
        lines.append(f"# {doc.name}")
        lines.append("")

        # Description
        if doc.description:
            lines.append(doc.description)
            lines.append("")

        # Imports
        if doc.imports:
            lines.append("## Imports")
            lines.append("")
            for imp in doc.imports:
                lines.append(f"- `{imp}`")
            lines.append("")

        # Constants
        if doc.constants:
            lines.append("## Constants")
            lines.append("")
            lines.append("| Name | Value | Description |")
            lines.append("|------|-------|-------------|")
            for name, value, desc in doc.constants:
                lines.append(f"| `{name}` | `{value}` | {desc} |")
            lines.append("")

        # Flows
        if doc.flows:
            lines.append("## Flows")
            lines.append("")
            for flow in doc.flows:
                lines.extend(self._flow_to_markdown(flow))
                lines.append("")

        return "\n".join(lines)

    def _flow_to_markdown(self, flow: FlowDoc) -> list[str]:
        """Convert a FlowDoc to Markdown."""
        lines: list[str] = []

        # Heading
        lines.append(f"### `{flow.name}`")
        lines.append("")

        # Description
        if flow.description:
            lines.append(flow.description)
            lines.append("")

        # Parameters
        if flow.params:
            lines.append("**Parameters:**")
            lines.append("")
            for name, desc in flow.params:
                lines.append(f"- `{name}`: {desc}")
            lines.append("")

        # Returns
        if flow.returns:
            lines.append(f"**Returns:** {flow.returns}")
            lines.append("")

        # Examples
        if flow.examples:
            lines.append("**Examples:**")
            lines.append("")
            for example in flow.examples:
                lines.append("```retro")
                lines.append(example)
                lines.append("```")
                lines.append("")

        # Tags
        if flow.tags:
            lines.append(f"**Tags:** {', '.join(flow.tags)}")
            lines.append("")

        return lines

    def generate_index(self, modules: list[ModuleDoc]) -> str:
        """Generate index page for multiple modules.

        Args:
            modules: List of module documentation

        Returns:
            Markdown index page
        """
        lines: list[str] = []

        lines.append("# RetroScript API Documentation")
        lines.append("")
        lines.append("## Modules")
        lines.append("")

        for mod in modules:
            lines.append(f"### [{mod.name}]({mod.name}.md)")
            if mod.description:
                # First line of description
                first_line = mod.description.split("\n")[0]
                lines.append(f"  {first_line}")
            lines.append("")

            # List flows
            if mod.flows:
                lines.append("  **Flows:**")
                for flow in mod.flows:
                    lines.append(f"  - `{flow.name}`")
                lines.append("")

        return "\n".join(lines)


def generate_docs(source: str, module_name: str = "script") -> str:
    """Convenience function to generate documentation.

    Args:
        source: RetroScript source code
        module_name: Name for the module

    Returns:
        Markdown documentation
    """
    gen = DocGenerator()
    doc = gen.generate(source)
    doc.name = module_name
    return gen.to_markdown(doc)


================================================================================
FILE PATH: app\tools\recorder.py
LINES: 319
================================================================================

"""
RetroAuto v2 - Script Recorder

Record mouse/keyboard events and generate RetroScript code.
Part of RetroScript Phase 7 - Tools + Productivity.
"""

from __future__ import annotations

import time
from collections.abc import Callable
from dataclasses import dataclass
from enum import Enum, auto


class EventType(Enum):
    """Types of recorded events."""

    MOUSE_CLICK = auto()
    MOUSE_MOVE = auto()
    MOUSE_DRAG = auto()
    MOUSE_SCROLL = auto()
    KEY_PRESS = auto()
    KEY_RELEASE = auto()
    KEY_TYPE = auto()  # Text input
    DELAY = auto()


@dataclass
class RecordedEvent:
    """A single recorded event."""

    event_type: EventType
    timestamp: float  # Seconds since recording start
    x: int = 0
    y: int = 0
    button: str = ""  # left, right, middle
    key: str = ""  # Key name
    text: str = ""  # Typed text
    scroll_delta: int = 0


@dataclass
class RecorderOptions:
    """Options for script recording."""

    record_mouse_moves: bool = False  # Record all mouse movements
    record_delays: bool = True  # Include sleep() between actions
    min_delay: float = 0.1  # Minimum delay to record (seconds)
    max_delay: float = 5.0  # Maximum delay to cap at
    merge_clicks: bool = True  # Merge rapid clicks
    merge_typing: bool = True  # Merge key presses into type()
    include_comments: bool = True  # Add descriptive comments
    indent_size: int = 4


class ScriptRecorder:
    """Records user actions and generates RetroScript code.

    Usage:
        recorder = ScriptRecorder()
        recorder.start()
        # User performs actions...
        recorder.stop()
        code = recorder.generate()
    """

    def __init__(self, options: RecorderOptions | None = None) -> None:
        self.options = options or RecorderOptions()
        self._events: list[RecordedEvent] = []
        self._recording = False
        self._start_time = 0.0

        # Callbacks
        self.on_event: Callable[[RecordedEvent], None] | None = None

    def start(self) -> None:
        """Start recording events."""
        self._events.clear()
        self._recording = True
        self._start_time = time.time()

    def stop(self) -> None:
        """Stop recording events."""
        self._recording = False

    def is_recording(self) -> bool:
        """Check if currently recording."""
        return self._recording

    def record_click(self, x: int, y: int, button: str = "left") -> None:
        """Record a mouse click event."""
        if not self._recording:
            return
        self._add_event(
            RecordedEvent(
                event_type=EventType.MOUSE_CLICK,
                timestamp=self._get_timestamp(),
                x=x,
                y=y,
                button=button,
            )
        )

    def record_move(self, x: int, y: int) -> None:
        """Record a mouse move event."""
        if not self._recording or not self.options.record_mouse_moves:
            return
        self._add_event(
            RecordedEvent(
                event_type=EventType.MOUSE_MOVE,
                timestamp=self._get_timestamp(),
                x=x,
                y=y,
            )
        )

    def record_drag(self, x1: int, y1: int, x2: int, y2: int) -> None:
        """Record a drag event."""
        if not self._recording:
            return
        # Store start in x,y and end in button as "x2,y2"
        self._add_event(
            RecordedEvent(
                event_type=EventType.MOUSE_DRAG,
                timestamp=self._get_timestamp(),
                x=x1,
                y=y1,
                button=f"{x2},{y2}",
            )
        )

    def record_scroll(self, x: int, y: int, delta: int) -> None:
        """Record a scroll event."""
        if not self._recording:
            return
        self._add_event(
            RecordedEvent(
                event_type=EventType.MOUSE_SCROLL,
                timestamp=self._get_timestamp(),
                x=x,
                y=y,
                scroll_delta=delta,
            )
        )

    def record_key(self, key: str) -> None:
        """Record a key press event."""
        if not self._recording:
            return
        self._add_event(
            RecordedEvent(
                event_type=EventType.KEY_PRESS,
                timestamp=self._get_timestamp(),
                key=key,
            )
        )

    def record_text(self, text: str) -> None:
        """Record typed text."""
        if not self._recording:
            return
        self._add_event(
            RecordedEvent(
                event_type=EventType.KEY_TYPE,
                timestamp=self._get_timestamp(),
                text=text,
            )
        )

    def _add_event(self, event: RecordedEvent) -> None:
        """Add event and trigger callback."""
        self._events.append(event)
        if self.on_event:
            self.on_event(event)

    def _get_timestamp(self) -> float:
        """Get timestamp relative to recording start."""
        return time.time() - self._start_time

    def get_events(self) -> list[RecordedEvent]:
        """Get all recorded events."""
        return self._events.copy()

    def clear(self) -> None:
        """Clear all recorded events."""
        self._events.clear()

    def generate(self, flow_name: str = "recorded_script") -> str:
        """Generate RetroScript code from recorded events.

        Args:
            flow_name: Name for the generated flow

        Returns:
            RetroScript source code
        """
        if not self._events:
            return f"flow {flow_name} {{\n    # No events recorded\n}}"

        lines: list[str] = []
        indent = " " * self.options.indent_size

        # Header
        if self.options.include_comments:
            lines.append(f"# Recorded script - {len(self._events)} events")
            lines.append(f"# Duration: {self._events[-1].timestamp:.1f}s")
            lines.append("")

        lines.append(f"flow {flow_name} {{")

        # Process events
        processed = self._process_events()
        last_time = 0.0

        for event in processed:
            # Add delay if needed
            if self.options.record_delays:
                delay = event.timestamp - last_time
                if delay >= self.options.min_delay:
                    delay = min(delay, self.options.max_delay)
                    lines.append(f"{indent}sleep({self._format_duration(delay)})")
                last_time = event.timestamp

            # Generate event code
            code = self._generate_event_code(event)
            if code:
                lines.append(f"{indent}{code}")

        lines.append("}")
        return "\n".join(lines)

    def _process_events(self) -> list[RecordedEvent]:
        """Process events: merge typing, merge clicks, etc."""
        if not self._events:
            return []

        result: list[RecordedEvent] = []
        i = 0

        while i < len(self._events):
            event = self._events[i]

            # Merge consecutive key presses into text
            if self.options.merge_typing and event.event_type == EventType.KEY_PRESS:
                text = ""
                start_time = event.timestamp
                while i < len(self._events) and self._events[i].event_type == EventType.KEY_PRESS:
                    key = self._events[i].key
                    if len(key) == 1:  # Single character
                        text += key
                    else:
                        break  # Special key ends merge
                    i += 1
                if text:
                    result.append(
                        RecordedEvent(
                            event_type=EventType.KEY_TYPE,
                            timestamp=start_time,
                            text=text,
                        )
                    )
                    continue

            result.append(event)
            i += 1

        return result

    def _generate_event_code(self, event: RecordedEvent) -> str:
        """Generate RetroScript code for a single event."""
        if event.event_type == EventType.MOUSE_CLICK:
            if event.button == "left":
                return f"click({event.x}, {event.y})"
            else:
                return f'click({event.x}, {event.y}, button="{event.button}")'

        elif event.event_type == EventType.MOUSE_MOVE:
            return f"move({event.x}, {event.y})"

        elif event.event_type == EventType.MOUSE_DRAG:
            x2, y2 = event.button.split(",")
            return f"drag({event.x}, {event.y}, {x2}, {y2})"

        elif event.event_type == EventType.MOUSE_SCROLL:
            return f"scroll({event.scroll_delta})"

        elif event.event_type == EventType.KEY_PRESS:
            return f'press("{event.key}")'

        elif event.event_type == EventType.KEY_TYPE:
            # Escape quotes in text
            text = event.text.replace('"', '\\"')
            return f'type("{text}")'

        return ""

    def _format_duration(self, seconds: float) -> str:
        """Format duration as RetroScript time literal."""
        if seconds < 1:
            return f"{int(seconds * 1000)}ms"
        elif seconds == int(seconds):
            return f"{int(seconds)}s"
        else:
            return f"{seconds:.1f}s"


def record_and_generate(duration: float = 10.0, flow_name: str = "recorded") -> str:
    """Convenience function to record for a duration and generate code.

    Note: This is a placeholder. Actual recording requires
    platform-specific event hooks (pynput, pyautogui, etc.)
    """
    recorder = ScriptRecorder()
    recorder.start()
    # In real implementation, would hook into system events
    time.sleep(min(duration, 0.1))  # Placeholder
    recorder.stop()
    return recorder.generate(flow_name)


================================================================================
FILE PATH: app\tools\scaffold.py
LINES: 426
================================================================================

"""
RetroAuto v2 - Project Scaffolding

Create new RetroScript project structures with templates.
Part of RetroScript Phase 7 - Tools + Productivity.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path


class ProjectTemplate(Enum):
    """Available project templates."""

    BASIC = auto()  # Simple single-file project
    GAME_BOT = auto()  # Game automation project
    SCRAPER = auto()  # Data scraping project
    TESTING = auto()  # Testing-focused project


@dataclass
class ProjectConfig:
    """Project configuration (retro.toml)."""

    name: str
    version: str = "1.0.0"
    description: str = ""
    author: str = ""
    entry_point: str = "main.retro"
    assets_dir: str = "assets"
    timeout: str = "30s"
    permissions: list[str] = field(default_factory=list)
    dependencies: dict[str, str] = field(default_factory=dict)


class ProjectScaffold:
    """Create new RetroScript project structures.

    Usage:
        scaffold = ProjectScaffold()
        scaffold.create("my_project", ProjectTemplate.GAME_BOT)
    """

    def __init__(self, base_path: str | Path | None = None) -> None:
        self.base_path = Path(base_path) if base_path else Path.cwd()

    def create(
        self,
        name: str,
        template: ProjectTemplate = ProjectTemplate.BASIC,
        config: ProjectConfig | None = None,
    ) -> Path:
        """Create a new project.

        Args:
            name: Project name (and directory name)
            template: Project template to use
            config: Optional project configuration

        Returns:
            Path to created project directory
        """
        project_dir = self.base_path / name

        # Create directory structure
        project_dir.mkdir(parents=True, exist_ok=True)
        (project_dir / "assets").mkdir(exist_ok=True)
        (project_dir / "lib").mkdir(exist_ok=True)
        (project_dir / "tests").mkdir(exist_ok=True)

        # Create config
        cfg = config or ProjectConfig(name=name)
        self._write_config(project_dir / "retro.toml", cfg)

        # Create template files
        self._create_template_files(project_dir, template, cfg)

        # Create README
        self._write_readme(project_dir, cfg)

        # Create .gitignore
        self._write_gitignore(project_dir)

        return project_dir

    def _write_config(self, path: Path, config: ProjectConfig) -> None:
        """Write retro.toml configuration file."""
        lines = [
            "[project]",
            f'name = "{config.name}"',
            f'version = "{config.version}"',
            f'description = "{config.description}"',
            f'author = "{config.author}"',
            "",
            "[script]",
            f'entry_point = "{config.entry_point}"',
            f'assets_dir = "{config.assets_dir}"',
            f'timeout = "{config.timeout}"',
            "",
            "[permissions]",
        ]

        for perm in config.permissions or ["mouse", "keyboard", "screen"]:
            lines.append(f"{perm} = true")

        lines.append("")
        lines.append("[dependencies]")
        for dep, ver in config.dependencies.items():
            lines.append(f'{dep} = "{ver}"')

        path.write_text("\n".join(lines), encoding="utf-8")

    def _create_template_files(
        self,
        project_dir: Path,
        template: ProjectTemplate,
        config: ProjectConfig,
    ) -> None:
        """Create template-specific files."""
        main_file = project_dir / config.entry_point

        if template == ProjectTemplate.BASIC:
            main_file.write_text(self._get_basic_template(config.name), encoding="utf-8")

        elif template == ProjectTemplate.GAME_BOT:
            main_file.write_text(self._get_game_bot_template(config.name), encoding="utf-8")
            # Create utility lib
            lib_file = project_dir / "lib" / "utils.retro"
            lib_file.write_text(self._get_utils_template(), encoding="utf-8")

        elif template == ProjectTemplate.SCRAPER:
            main_file.write_text(self._get_scraper_template(config.name), encoding="utf-8")

        elif template == ProjectTemplate.TESTING:
            main_file.write_text(self._get_testing_template(config.name), encoding="utf-8")
            # Create example test
            test_file = project_dir / "tests" / "test_main.retro"
            test_file.write_text(self._get_test_template(), encoding="utf-8")

    def _write_readme(self, project_dir: Path, config: ProjectConfig) -> None:
        """Write README.md file."""
        content = f"""# {config.name}

{config.description or 'A RetroScript automation project.'}

## Quick Start

1. Open this project in RetroAuto
2. Add your image assets to the `assets/` folder
3. Edit `{config.entry_point}` to customize the script
4. Run with F5 or the Run button

## Project Structure

```
{config.name}/
‚îú‚îÄ‚îÄ {config.entry_point}    # Main script
‚îú‚îÄ‚îÄ assets/                  # Image assets
‚îú‚îÄ‚îÄ lib/                     # Utility modules
‚îú‚îÄ‚îÄ tests/                   # Test scripts
‚îú‚îÄ‚îÄ retro.toml              # Project config
‚îî‚îÄ‚îÄ README.md               # This file
```

## Configuration

See `retro.toml` for project settings.

## License

MIT
"""
        (project_dir / "README.md").write_text(content, encoding="utf-8")

    def _write_gitignore(self, project_dir: Path) -> None:
        """Write .gitignore file."""
        content = """# RetroScript
*.log
*.tmp
__pycache__/
.cache/

# IDE
.vscode/
.idea/

# OS
.DS_Store
Thumbs.db
"""
        (project_dir / ".gitignore").write_text(content, encoding="utf-8")

    def _get_basic_template(self, name: str) -> str:
        """Get basic project template."""
        return f"""# {name} - Main Script
# Created with RetroAuto

@config {{
    timeout = 30s
}}

flow main {{
    log("Starting {name}...")

    # Your automation code here
    $target = find(button_img)
    if $target {{
        click($target.x, $target.y)
    }}

    log("Done!")
}}
"""

    def _get_game_bot_template(self, name: str) -> str:
        """Get game bot project template."""
        return f"""# {name} - Game Bot
# Created with RetroAuto

import "lib/utils" as utils

@config {{
    timeout = 60s
}}

@permissions {{
    mouse = true
    keyboard = true
    screen = true
}}

# Constants
const RETRY_COUNT = 5
const COMBAT_DELAY = 500ms

# Main entry point
flow main {{
    log("Starting {name}...")

    repeat 100 {{
        run(combat_loop)
        run(check_health)
        utils.random_pause()
    }}
}}

# Combat automation
flow combat_loop {{
    $enemy = find(enemy_img)
    if $enemy {{
        click($enemy.x, $enemy.y)
        sleep(COMBAT_DELAY)

        # Use skills
        press("1")
        sleep(200ms)
    }}
}}

# Health check
flow check_health {{
    $health_low = find(health_low_img)
    if $health_low {{
        log("Health low, using potion")
        press("h")
        sleep(1s)
    }}
}}
"""

    def _get_scraper_template(self, name: str) -> str:
        """Get scraper project template."""
        return f"""# {name} - Data Scraper
# Created with RetroAuto

@config {{
    timeout = 120s
}}

flow main {{
    log("Starting {name} scraper...")

    # Navigate to target
    $nav = find(nav_button)
    if $nav {{
        click($nav.x, $nav.y)
        sleep(2s)
    }}

    # Collect data
    repeat 10 {{
        run(collect_item)
        run(next_page)
    }}

    log("Scraping complete!")
}}

flow collect_item {{
    $item = find(item_img)
    if $item {{
        click($item.x, $item.y)
        sleep(500ms)
        # Copy data
        hotkey("ctrl+c")
    }}
}}

flow next_page {{
    $next = find(next_page_img)
    if $next {{
        click($next.x, $next.y)
        sleep(1s)
    }}
}}
"""

    def _get_testing_template(self, name: str) -> str:
        """Get testing project template."""
        return f"""# {name} - With Tests
# Created with RetroAuto

@config {{
    timeout = 30s
}}

flow main {{
    log("Running {name}...")
    $result = run(do_action)
    log("Result: " + $result)
}}

# Main action to test
flow do_action {{
    $target = find(button_img)
    if $target {{
        click($target.x, $target.y)
        return "success"
    }}
    return "not_found"
}}
"""

    def _get_test_template(self) -> str:
        """Get test file template."""
        return """# Test suite for main script

@test "do_action finds button" {
    mock find(button_img) -> Found(100, 200)
    $result = run(do_action)
    assert $result == "success"
}

@test "do_action handles missing button" {
    mock find(button_img) -> NotFound
    $result = run(do_action)
    assert $result == "not_found"
}
"""

    def _get_utils_template(self) -> str:
        """Get utility library template."""
        return """# Utility functions

# Random pause for anti-detection
flow random_pause {
    $delay = 500 + random(0, 1000)
    sleep($delay ms)
}

# Safe click with retry
flow safe_click($target) {
    retry 3 {
        $found = find($target)
        if $found {
            click($found.x, $found.y)
            return true
        }
    }
    return false
}

# Wait for any of multiple targets
flow wait_any_of($targets) {
    retry 30 {
        for $t in $targets {
            $found = find($t)
            if $found {
                return $found
            }
        }
        sleep(100ms)
    }
    return null
}
"""


def create_project(
    name: str,
    template: str = "basic",
    path: str | None = None,
) -> str:
    """Convenience function to create a new project.

    Args:
        name: Project name
        template: Template name (basic, game_bot, scraper, testing)
        path: Base path for project

    Returns:
        Path to created project
    """
    template_map = {
        "basic": ProjectTemplate.BASIC,
        "game_bot": ProjectTemplate.GAME_BOT,
        "scraper": ProjectTemplate.SCRAPER,
        "testing": ProjectTemplate.TESTING,
    }

    scaffold = ProjectScaffold(path)
    project_path = scaffold.create(name, template_map.get(template, ProjectTemplate.BASIC))
    return str(project_path)


================================================================================
FILE PATH: app\ui\__init__.py
LINES: 1
================================================================================

"""RetroAuto v2 - UI components package."""


================================================================================
FILE PATH: app\ui\actions_panel.py
LINES: 1509
================================================================================

"""
RetroAuto v2 - Actions Panel

Manages the list of actions in a flow.
"""

from PySide6.QtCore import QSize, Qt, Signal
from PySide6.QtGui import QColor, QKeySequence, QPainter, QPen, QShortcut
from PySide6.QtWidgets import (
    QGroupBox,
    QHBoxLayout,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMenu,
    QPushButton,
    QStyle,
    QStyledItemDelegate,
    QStyleOptionViewItem,
    QVBoxLayout,
    QWidget,
)

from core.models import (
    ROI,
    Action,
    Click,
    ClickImage,
    ClickRandom,
    ClickUntil,
    Delay,
    DelayRandom,
    Drag,
    Else,
    EndIf,
    EndLoop,
    EndWhile,
    Goto,
    Hotkey,
    IfImage,
    IfNotImage,
    IfAllImages,
    IfAnyImage,
    IfPixel,
    IfText,
    Label,
    Loop,
    Notify,
    PixelColor,
    ReadText,
    RunFlow,
    Scroll,
    TypeText,
    WaitImage,
    WaitPixel,
    WhileImage,
)
from infra import get_logger

logger = get_logger("ActionsPanel")

# Categorized action types for better discoverability
ACTION_CATEGORIES = {
    "üéØ Clicks & Mouse": [
        ("ClickImage", "üéØ Click Image"),
        ("ClickUntil", "üîÑ Click Until"),
        ("ClickRandom", "üé≤ Click Random"),
        ("Click", "üñ±Ô∏è Click"),
        ("Drag", "‚ÜîÔ∏è Drag"),
        ("Scroll", "üìú Scroll"),
    ],
    "üëÅÔ∏è Vision & Wait": [
        ("WaitImage", "üëÅÔ∏è Wait Image"),
        ("IfImage", "‚ùì If Image"),
        ("IfNotImage", "‚ùå If Not Image"),
        ("IfAllImages", "‚úÖ If All Images (AND)"),
        ("IfAnyImage", "üîÄ If Any Image (OR)"),
        ("WhileImage", "üîÑ While Image"),
        ("WaitPixel", "üé® Wait Pixel"),
        ("IfPixel", "üéØ If Pixel"),
        ("ReadText", "üß† Read Text"),
    ],
    "‚å®Ô∏è Keyboard & Input": [
        ("Hotkey", "‚å®Ô∏è Hotkey"),
        ("TypeText", "üìù Type Text"),
    ],
    "‚è±Ô∏è Timing & Delays": [
        ("Delay", "‚è±Ô∏è Delay"),
        ("DelayRandom", "üé≤ Random Delay"),
    ],
    "üîÑ Flow Control": [
        ("IfText", "üìù If Text"),
        ("Loop", "üîÅ Loop"),
        ("Label", "üè∑Ô∏è Label"),
        ("Goto", "‚Ü©Ô∏è Goto"),
        ("RunFlow", "‚ñ∂Ô∏è Run Flow"),
    ],
    "üì° Remote & Notify": [
        ("Notify", "üì¢ Notify"),
    ],
    "üìê Structure Markers": [
        ("Else", "‚Ü©Ô∏è Else"),
        ("EndIf", "üîö EndIf"),
        ("EndLoop", "üîö EndLoop"),
        ("EndWhile", "üîö EndWhile"),
    ],
}

# Smart templates for common patterns
ACTION_TEMPLATES = {
    "üéØ Wait & Click": [
        ("WaitImage", {"asset_id": "[target]", "appear": True}),
        ("ClickImage", {"asset_id": "[target]"}),
    ],
    "üîÑ Loop Until Found": [
        ("Loop", {"iterations": 100}),
        ("WaitImage", {"asset_id": "[target]", "timeout_ms": 500}),
        ("ClickImage", {"asset_id": "[target]"}),
        ("EndLoop", {}),
    ],
    "‚ùì Check & React": [
        ("IfImage", {"asset_id": "[condition]"}),
        ("ClickImage", {"asset_id": "[action_true]"}),
        ("Else", {}),
        ("ClickImage", {"asset_id": "[action_false]"}),
        ("EndIf", {}),
    ],
    "üìù Read & Check Value": [
        ("ReadText", {"variable_name": "$value", "roi": {"x": 0, "y": 0, "w": 100, "h": 30}}),
        ("IfText", {"variable_name": "$value", "operator": "numeric_lt", "value": "50"}),
        ("ClickImage", {"asset_id": "[action]"}),
        ("EndIf", {}),
    ],
    "‚è±Ô∏è Timed Sequence": [
        ("ClickImage", {"asset_id": "[step1]"}),
        ("Delay", {"ms": 1000}),
        ("ClickImage", {"asset_id": "[step2]"}),
        ("Delay", {"ms": 1000}),
        ("ClickImage", {"asset_id": "[step3]"}),
    ],
    "üéÆ Farming Loop": [
        ("Loop", {"iterations": 999}),
        ("WaitImage", {"asset_id": "[enemy]", "timeout_ms": 5000}),
        ("ClickImage", {"asset_id": "[attack]"}),
        ("Delay", {"ms": 3000}),
        ("EndLoop", {}),
    ],
    "üíä Auto Heal": [
        ("ReadText", {"variable_name": "$hp", "roi": {"x": 10, "y": 10, "w": 100, "h": 30}}),
        ("IfText", {"variable_name": "$hp", "operator": "numeric_lt", "value": "30"}),
        ("ClickImage", {"asset_id": "[potion]"}),
        ("Delay", {"ms": 500}),
        ("EndIf", {}),
    ],
    "‚öîÔ∏è Skill Combo": [
        ("ClickImage", {"asset_id": "[skill1]"}),
        ("Delay", {"ms": 500}),
        ("ClickImage", {"asset_id": "[skill2]"}),
        ("Delay", {"ms": 500}),
        ("ClickImage", {"asset_id": "[skill3]"}),
        ("Delay", {"ms": 500}),
    ],
}

# Build flattened lookup for backward compatibility
ACTION_TYPES = []
for _category_name, actions in ACTION_CATEGORIES.items():
    ACTION_TYPES.extend(actions)

# Action factory functions
ACTION_DEFAULTS = {
    "ClickImage": lambda: ClickImage(asset_id=""),
    "ClickUntil": lambda: ClickUntil(click_asset_id="", until_asset_id=""),
    "WaitImage": lambda: WaitImage(asset_id=""),
    "WaitPixel": lambda: WaitPixel(x=0, y=0, color=PixelColor(r=255, g=0, b=0)),
    "Click": lambda: Click(),
    "IfImage": lambda: IfImage(asset_id=""),
    "IfNotImage": lambda: IfNotImage(asset_id=""),
    "IfAllImages": lambda: IfAllImages(asset_ids=[]),
    "IfAnyImage": lambda: IfAnyImage(asset_ids=[]),
    "IfText": lambda: IfText(variable_name="$var", value="0"),
    "Else": lambda: Else(),
    "EndIf": lambda: EndIf(),
    "Loop": lambda: Loop(),
    "EndLoop": lambda: EndLoop(),
    "WhileImage": lambda: WhileImage(asset_id=""),
    "EndWhile": lambda: EndWhile(),
    "IfPixel": lambda: IfPixel(x=0, y=0, color=PixelColor(r=255, g=0, b=0)),
    "Hotkey": lambda: Hotkey(keys=[]),
    "TypeText": lambda: TypeText(text=""),
    "Label": lambda: Label(name=""),
    "Goto": lambda: Goto(label=""),
    "RunFlow": lambda: RunFlow(flow_name=""),
    "Delay": lambda: Delay(ms=1000),
    "DelayRandom": lambda: DelayRandom(),
    "ReadText": lambda: ReadText(variable_name="$var", roi=ROI(x=0, y=0, w=100, h=30)),
    "Drag": lambda: Drag(from_x=0, from_y=0, to_x=100, to_y=100),
    "Scroll": lambda: Scroll(),
    "ClickRandom": lambda: ClickRandom(roi=ROI(x=0, y=0, w=100, h=100)),
    "Notify": lambda: Notify(message="Notification"),
}

# Color scheme by action category
ACTION_COLORS = {
    "click": QColor("#4CAF50"),  # Green - click actions
    "wait": QColor("#2196F3"),  # Blue - wait/check actions
    "control": QColor("#FF9800"),  # Orange - control flow
    "input": QColor("#9C27B0"),  # Purple - input actions
    "timing": QColor("#607D8B"),  # Gray-blue - timing
    "marker": QColor("#888888"),  # Gray - block markers
}

ACTION_CATEGORY = {
    "ClickImage": "click",
    "Click": "click",
    "ClickUntil": "click",
    "WaitImage": "wait",
    "WaitPixel": "wait",
    "IfImage": "control",
    "Else": "control",
    "EndIf": "marker",
    "IfText": "control",
    "Loop": "control",
    "EndLoop": "marker",
    "WhileImage": "control",
    "EndWhile": "marker",
    "Goto": "control",
    "Label": "control",
    "RunFlow": "control",
    "Hotkey": "input",
    "TypeText": "input",
    "ReadText": "input",
    "Delay": "timing",
    "DelayRandom": "timing",
    "IfPixel": "control",
    "Drag": "click",
    "Scroll": "click",
}


class ActionItemDelegate(QStyledItemDelegate):
    """Custom delegate to draw tree lines and expand indicators."""

    def __init__(self, parent=None):  # type: ignore
        super().__init__(parent)
        self.line_color = QColor("#555555")
        self.indent_width = 20

    def paint(self, painter: QPainter, option: QStyleOptionViewItem, index) -> None:  # type: ignore
        """Draw item with visual tree lines."""
        painter.save()

        # Get item data
        depth = index.data(257) or 0  # Qt.UserRole + 1
        is_block_start = index.data(258) or False  # Qt.UserRole + 2
        category = index.data(259) or "timing"  # Qt.UserRole + 3
        text = index.data(Qt.ItemDataRole.DisplayRole) or ""

        # Draw selection background
        if option.state & QStyle.StateFlag.State_Selected:
            painter.fillRect(option.rect, option.palette.highlight())
            text_color = option.palette.highlightedText().color()
        else:
            text_color = ACTION_COLORS.get(category, QColor("#CCCCCC"))

        # Calculate tree line area
        tree_width = depth * self.indent_width
        text_x = option.rect.x() + tree_width + 4
        y_center = option.rect.y() + option.rect.height() // 2

        # Draw tree lines
        pen = QPen(self.line_color, 1)
        painter.setPen(pen)

        for i in range(depth):
            x = option.rect.x() + (i * self.indent_width) + self.indent_width // 2
            # Vertical line
            painter.drawLine(x, option.rect.y(), x, option.rect.y() + option.rect.height())
            # Horizontal connector for last level
            if i == depth - 1:
                painter.drawLine(x, y_center, x + self.indent_width // 2, y_center)

        # Draw expand indicator for block starters
        if is_block_start:
            indicator = "‚ñæ "
            painter.setPen(QColor("#888888"))
            painter.drawText(
                text_x,
                option.rect.y(),
                20,
                option.rect.height(),
                Qt.AlignmentFlag.AlignVCenter,
                indicator,
            )
            text_x += 14

        # Draw text
        painter.setPen(text_color)
        text_rect = option.rect.adjusted(text_x - option.rect.x(), 0, 0, 0)
        painter.drawText(text_rect, Qt.AlignmentFlag.AlignVCenter, text)

        painter.restore()

    def sizeHint(self, option: QStyleOptionViewItem, index) -> QSize:  # type: ignore
        """Return size with space for tree lines."""
        size = super().sizeHint(option, index)
        depth = index.data(257) or 0
        return QSize(size.width() + depth * self.indent_width, max(size.height(), 22))


# Custom MIME type for asset drag
ASSET_MIME_TYPE = "application/x-retroauto-asset"


class ActionListWidget(QListWidget):
    """
    Custom list widget with external drop support from Assets panel.
    - Drop ON an item: update that action's asset_id (if applicable)
    - Drop BETWEEN items: shows blue indicator line (insert position)
    """

    asset_dropped_on_item = Signal(str, int)  # asset_id, item_index (update existing)
    asset_dropped_insert = Signal(str, int, str)  # asset_id, insert_index, action_type (create new)
    about_to_reorder = Signal()  # Before internal move
    reordered = Signal()  # After internal move

    def __init__(self, parent=None) -> None:  # type: ignore
        super().__init__(parent)
        self._drop_indicator_index = -1
        self._drop_on_item_index = -1  # -1 = insert mode, >=0 = update mode
        self.setAcceptDrops(True)
        self.setDefaultDropAction(Qt.DropAction.MoveAction)
        self.viewport().setAcceptDrops(True)

    def keyPressEvent(self, event) -> None:  # type: ignore
        """Handle keyboard shortcuts directly when list has focus."""
        from PySide6.QtCore import Qt
        from PySide6.QtGui import QKeySequence

        # Del key - emit signal to parent to delete
        if event.key() == Qt.Key.Key_Delete:
            parent = self.parent()
            while parent:
                if hasattr(parent, "_on_delete"):
                    parent._on_delete()
                    return
                parent = parent.parent()

        # Ctrl+A - select all
        if event.key() == Qt.Key.Key_A and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            self.selectAll()
            return

        # Pass to base class for default handling
        super().keyPressEvent(event)

    def dragEnterEvent(self, event) -> None:  # type: ignore
        """Accept drag from Assets panel or internal move."""
        mime = event.mimeData()
        if mime.hasFormat(ASSET_MIME_TYPE):
            event.acceptProposedAction()
        elif mime.hasFormat("application/x-qabstractitemmodeldatalist"):
            # Internal move
            super().dragEnterEvent(event)
        else:
            event.ignore()

    def dragMoveEvent(self, event) -> None:  # type: ignore
        """Update drop indicator - detect if dropping ON item or BETWEEN items."""
        mime = event.mimeData()
        if mime.hasFormat(ASSET_MIME_TYPE):
            pos = event.position().toPoint()
            item = self.itemAt(pos)

            if item:
                rect = self.visualItemRect(item)
                index = self.row(item)
                # Check if in center 60% of item (update mode) or edge 20% (insert mode)
                item_height = rect.height()
                edge_zone = item_height * 0.2

                if pos.y() < rect.top() + edge_zone:
                    # Top edge - insert before
                    self._drop_on_item_index = -1
                    self._drop_indicator_index = index
                elif pos.y() > rect.bottom() - edge_zone:
                    # Bottom edge - insert after
                    self._drop_on_item_index = -1
                    self._drop_indicator_index = index + 1
                else:
                    # Center - update this item
                    self._drop_on_item_index = index
                    self._drop_indicator_index = -1
            else:
                # Below all items - insert at end
                self._drop_on_item_index = -1
                self._drop_indicator_index = self.count()

            self.viewport().update()
            event.acceptProposedAction()
        else:
            self._drop_indicator_index = -1
            self._drop_on_item_index = -1
            super().dragMoveEvent(event)

    def dragLeaveEvent(self, event) -> None:  # type: ignore
        """Clear drop indicators."""
        self._drop_indicator_index = -1
        self._drop_on_item_index = -1
        self.viewport().update()
        super().dragLeaveEvent(event)

    def dropEvent(self, event) -> None:  # type: ignore
        """Handle drop from Assets panel - show action chooser menu."""
        mime = event.mimeData()
        if mime.hasFormat(ASSET_MIME_TYPE):
            asset_id = mime.data(ASSET_MIME_TYPE).data().decode("utf-8")

            if self._drop_on_item_index >= 0:
                # Update existing action
                self.asset_dropped_on_item.emit(asset_id, self._drop_on_item_index)
            else:
                # Insert new action - show menu to choose type
                insert_index = self._drop_indicator_index
                if insert_index < 0:
                    insert_index = self.count()

                # Show menu to choose action type
                from PySide6.QtGui import QCursor
                from PySide6.QtWidgets import QMenu

                menu = QMenu(self)
                menu.setStyleSheet("QMenu { font-size: 12px; }")

                # Image-related actions
                actions_list = [
                    ("üëÅÔ∏è Wait Image", "WaitImage"),
                    ("üéØ Click Image", "ClickImage"),
                    ("‚ùì If Image", "IfImage"),
                    ("üîÑ While Image", "WhileImage"),
                ]

                for label, action_type in actions_list:
                    action = menu.addAction(label)
                    action.triggered.connect(
                        lambda checked=False, aid=asset_id, idx=insert_index, at=action_type: self.asset_dropped_insert.emit(
                            aid, idx, at
                        )
                    )

                # Show menu at cursor
                menu.exec(QCursor.pos())

            self._drop_indicator_index = -1
            self._drop_on_item_index = -1
            self.viewport().update()
            event.acceptProposedAction()
        else:
            # Internal move
            self.about_to_reorder.emit()
            self._drop_indicator_index = -1
            self._drop_on_item_index = -1
            super().dropEvent(event)
            self.reordered.emit()

    def paintEvent(self, event) -> None:  # type: ignore
        """Paint drop indicator line or item highlight."""
        super().paintEvent(event)

        # Draw item highlight for update mode
        if self._drop_on_item_index >= 0:
            item = self.item(self._drop_on_item_index)
            if item:
                painter = QPainter(self.viewport())
                rect = self.visualItemRect(item)
                # Semi-transparent blue highlight
                painter.fillRect(rect, QColor(0, 120, 212, 60))  # #0078d4 with alpha
                # Blue border
                pen = QPen(QColor("#0078d4"), 2)
                painter.setPen(pen)
                painter.drawRect(rect.adjusted(1, 1, -1, -1))
                painter.end()

        # Draw insert line indicator
        elif self._drop_indicator_index >= 0:
            painter = QPainter(self.viewport())
            pen = QPen(QColor("#0078d4"), 3)  # Blue line, 3px thick
            painter.setPen(pen)

            # Calculate Y position for indicator
            if self._drop_indicator_index < self.count():
                item = self.item(self._drop_indicator_index)
                if item:
                    rect = self.visualItemRect(item)
                    y = rect.top()
                else:
                    y = 0
            else:
                # After last item
                if self.count() > 0:
                    item = self.item(self.count() - 1)
                    if item:
                        rect = self.visualItemRect(item)
                        y = rect.bottom()
                    else:
                        y = 0
                else:
                    y = 0

            # Draw horizontal line across widget
            painter.drawLine(0, y, self.viewport().width(), y)
            painter.end()


class ActionsPanel(QWidget):
    """
    Panel for managing actions in a flow.

    Features:
    - List of actions with icons
    - Add action menu (WaitImage, Click, etc.)
    - Reorder (up/down)
    - Context menu: Run Step, Run From Here
    - Drop from Assets panel to create WaitImage
    """

    action_selected = Signal(dict)  # action data for properties panel
    action_changed = Signal()  # when list changes
    run_step_requested = Signal(int)  # step index

    def __init__(self) -> None:
        super().__init__()
        self._actions: list[Action] = []
        self._current_highlight: int = -1
        self._clipboard: list[Action] = []  # For copy/paste
        self._undo_stack: list[list[Action]] = []  # Undo history
        self._redo_stack: list[list[Action]] = []  # Redo history
        self._max_undo = 50  # Max undo steps

        # Performance: debounced refresh
        from PySide6.QtCore import QTimer

        self._refresh_timer = QTimer()
        self._refresh_timer.setSingleShot(True)
        self._refresh_timer.timeout.connect(self._do_refresh)
        self._refresh_pending = False

        self._init_ui()

    def _init_ui(self) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(4, 4, 4, 4)

        # Group box
        group = QGroupBox("Actions")
        group_layout = QVBoxLayout(group)

        # Quick Add Bar - 1-click common actions
        quick_bar = QHBoxLayout()
        quick_bar.setSpacing(2)

        # Common action quick buttons
        quick_actions = [
            ("üéØ", "ClickImage", "Click Image"),
            ("üñ±Ô∏è", "Click", "Click"),
            ("üëÅÔ∏è", "WaitImage", "Wait Image"),
            ("üëª", "WaitGone", "Wait Gone"),
            ("‚è±Ô∏è", "Delay", "Delay"),
            ("üîÅ", "Loop", "Loop"),
        ]

        for icon, action_type, tooltip in quick_actions:
            btn = QPushButton(icon)
            btn.setFixedSize(28, 24)
            btn.setToolTip(f"Add {tooltip}")
            btn.clicked.connect(lambda checked, t=action_type: self._quick_add(t))
            quick_bar.addWidget(btn)

        quick_bar.addStretch()

        # Search input (filter actions)
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("üîç Filter...")
        self.search_input.setFixedWidth(100)
        self.search_input.setClearButtonEnabled(True)
        self.search_input.textChanged.connect(self._on_search_changed)
        quick_bar.addWidget(self.search_input)

        # More menu button
        self.btn_more = QPushButton("+ More")
        self.btn_more.clicked.connect(self._show_add_menu)
        quick_bar.addWidget(self.btn_more)

        group_layout.addLayout(quick_bar)

        # Action list with extended selection and drop support
        self.action_list = ActionListWidget(self)
        self.action_list.setItemDelegate(ActionItemDelegate(self.action_list))
        self.action_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection)
        self.action_list.setDragDropMode(QListWidget.DragDropMode.InternalMove)
        self.action_list.currentItemChanged.connect(self._on_selection_changed)
        self.action_list.itemDoubleClicked.connect(self._on_double_click)
        self.action_list.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.action_list.customContextMenuRequested.connect(self._show_context_menu)
        self.action_list.asset_dropped_on_item.connect(self._on_asset_dropped_on_item)
        self.action_list.asset_dropped_insert.connect(self._on_asset_drop_insert)
        self.action_list.about_to_reorder.connect(self._save_state)
        self.action_list.reordered.connect(self._sync_actions_order)
        group_layout.addWidget(self.action_list)

        # Bottom buttons (Add, Delete, Clear, Move)
        btn_layout = QHBoxLayout()

        self.btn_add = QPushButton("+ Add")
        self.btn_add.clicked.connect(self._show_add_menu)

        self.btn_delete = QPushButton("Delete")
        self.btn_delete.clicked.connect(self._on_delete)
        self.btn_delete.setEnabled(False)

        self.btn_clear = QPushButton("Clear")
        self.btn_clear.clicked.connect(self._on_clear_all)

        self.btn_up = QPushButton("‚ñ≤")
        self.btn_up.setFixedWidth(30)
        self.btn_up.clicked.connect(self._on_move_up)
        self.btn_up.setEnabled(False)

        self.btn_down = QPushButton("‚ñº")
        self.btn_down.setFixedWidth(30)
        self.btn_down.clicked.connect(self._on_move_down)
        self.btn_down.setEnabled(False)

        btn_layout.addWidget(self.btn_add)
        btn_layout.addWidget(self.btn_delete)
        btn_layout.addWidget(self.btn_clear)
        btn_layout.addStretch()
        btn_layout.addWidget(self.btn_up)
        btn_layout.addWidget(self.btn_down)
        group_layout.addLayout(btn_layout)

        layout.addWidget(group)

        # Setup keyboard shortcuts
        self._setup_shortcuts()

    def _setup_shortcuts(self) -> None:
        """Setup keyboard shortcuts for gamer-friendly workflow."""
        # Use WidgetWithChildrenShortcut so shortcuts work when panel or any child has focus

        # Delete key
        self.del_shortcut = QShortcut(QKeySequence(Qt.Key.Key_Delete), self)
        self.del_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.del_shortcut.activated.connect(self._on_delete)

        # Ctrl+A to select all
        self.select_all_shortcut = QShortcut(QKeySequence.StandardKey.SelectAll, self)
        self.select_all_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.select_all_shortcut.activated.connect(self.action_list.selectAll)

        # Ctrl+D to duplicate
        self.dup_shortcut = QShortcut(QKeySequence("Ctrl+D"), self)
        self.dup_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.dup_shortcut.activated.connect(self._on_duplicate)

        # Ctrl+C to copy
        self.copy_shortcut = QShortcut(QKeySequence.StandardKey.Copy, self)
        self.copy_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.copy_shortcut.activated.connect(self._on_copy)

        # Ctrl+V to paste
        self.paste_shortcut = QShortcut(QKeySequence.StandardKey.Paste, self)
        self.paste_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.paste_shortcut.activated.connect(self._on_paste)

        # Ctrl+Shift+Up to move up
        self.move_up_shortcut = QShortcut(QKeySequence("Ctrl+Shift+Up"), self)
        self.move_up_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.move_up_shortcut.activated.connect(self._on_move_up)

        # Ctrl+Shift+Down to move down
        self.move_down_shortcut = QShortcut(QKeySequence("Ctrl+Shift+Down"), self)
        self.move_down_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.move_down_shortcut.activated.connect(self._on_move_down)

        # Ctrl+Z to undo
        self.undo_shortcut = QShortcut(QKeySequence.StandardKey.Undo, self)
        self.undo_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.undo_shortcut.activated.connect(self._on_undo)

        # Ctrl+Y to redo
        self.redo_shortcut = QShortcut(QKeySequence.StandardKey.Redo, self)
        self.redo_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.redo_shortcut.activated.connect(self._on_redo)

        # Space to test current step
        self.test_shortcut = QShortcut(QKeySequence(Qt.Key.Key_Space), self)
        self.test_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.test_shortcut.activated.connect(self._on_test_step)

    def load_actions(self, actions: list[Action]) -> None:
        """Load actions from script flow."""
        self._actions = list(actions)
        self._refresh_list()

    def get_actions(self) -> list[Action]:
        """Get current actions list."""
        return list(self._actions)

    def _refresh_list(self, immediate: bool = False) -> None:
        """
        Schedule a list refresh. Uses debouncing to batch rapid changes.

        Args:
            immediate: If True, refresh now without debouncing.
        """
        if immediate:
            self._refresh_timer.stop()
            self._do_refresh()
        else:
            # Debounce: wait 16ms (1 frame at 60fps) before refreshing
            self._refresh_pending = True
            self._refresh_timer.start(16)

    def _do_refresh(self) -> None:
        """Actually perform the list refresh (called by timer or immediate)."""
        self._refresh_pending = False

        # SAVE current state to restore after refresh
        current_row = self.action_list.currentRow()
        scroll_value = self.action_list.verticalScrollBar().value()

        # Optimization: only clear if count differs significantly
        if abs(self.action_list.count() - len(self._actions)) > 10:
            self.action_list.clear()
            self._rebuild_all_items()
        else:
            # Incremental update - faster for small changes
            self._incremental_update()

        # RESTORE scroll position and selection
        self.action_list.verticalScrollBar().setValue(scroll_value)
        if current_row >= 0 and current_row < self.action_list.count():
            self.action_list.setCurrentRow(current_row)

    def _rebuild_all_items(self) -> None:
        """Rebuild all items from scratch (used after clear)."""
        block_depth = 0

        for i, action in enumerate(self._actions):
            action_type = type(action).__name__
            label = next(
                (label_text for t, label_text in ACTION_TYPES if t == action_type), action_type
            )

            # Add details to label
            detail = self._get_action_detail(action)
            if detail:
                label = f"{label}: {detail}"

            # Determine depth and flags for this item
            is_block_start = action_type in (
                "IfImage", "IfNotImage", "IfAllImages", "IfAnyImage",
                "IfPixel", "IfText", "Loop", "WhileImage"
            )
            item_depth = block_depth

            # Block openers increase depth AFTER this item
            if is_block_start:
                block_depth += 1

            # Block closers decrease depth BEFORE this item
            elif action_type in ("EndIf", "EndLoop", "EndWhile"):
                block_depth = max(0, block_depth - 1)
                item_depth = block_depth

            # Get category for color
            category = ACTION_CATEGORY.get(action_type, "timing")

            # Create item with data roles for delegate
            item = QListWidgetItem(label)
            item.setData(256, i)  # Qt.UserRole - index
            item.setData(257, item_depth)  # Qt.UserRole + 1 - depth
            item.setData(258, is_block_start)  # Qt.UserRole + 2 - is_block_start
            item.setData(259, category)  # Qt.UserRole + 3 - category

            self.action_list.addItem(item)

    def _incremental_update(self) -> None:
        """Update items incrementally - much faster for small changes."""
        self.action_list.count()
        target_count = len(self._actions)

        # Add or remove items to match count
        while self.action_list.count() < target_count:
            self.action_list.addItem(QListWidgetItem(""))
        while self.action_list.count() > target_count:
            self.action_list.takeItem(self.action_list.count() - 1)

        # Update each item
        block_depth = 0
        for i, action in enumerate(self._actions):
            item = self.action_list.item(i)
            if not item:
                continue

            action_type = type(action).__name__
            label = next(
                (label_text for t, label_text in ACTION_TYPES if t == action_type), action_type
            )

            detail = self._get_action_detail(action)
            if detail:
                label = f"{label}: {detail}"

            is_block_start = action_type in (
                "IfImage", "IfNotImage", "IfAllImages", "IfAnyImage",
                "IfPixel", "IfText", "Loop", "WhileImage"
            )
            item_depth = block_depth

            if is_block_start:
                block_depth += 1
            elif action_type in ("EndIf", "EndLoop", "EndWhile"):
                block_depth = max(0, block_depth - 1)
                item_depth = block_depth

            category = ACTION_CATEGORY.get(action_type, "timing")

            # Only update if changed
            if item.text() != label:
                item.setText(label)
            item.setData(256, i)
            item.setData(257, item_depth)
            item.setData(258, is_block_start)
            item.setData(259, category)

    def _get_action_detail(self, action: Action) -> str:
        """Get short detail string for action."""
        if isinstance(action, ClickImage):
            return action.asset_id or "?"
        elif isinstance(action, ClickUntil):
            click = action.click_asset_id or "?"
            until = action.until_asset_id or "?"
            return f"{click} ‚Üí {until}"
        elif isinstance(action, ClickRandom):
            r = action.roi
            return f"ROI({r.x},{r.y}, {r.w}x{r.h})"
        elif isinstance(action, WaitImage):
            return action.asset_id or "?"
        elif isinstance(action, Click):
            # Show specific click type
            click_type = ""
            if action.clicks == 2:
                click_type = "Double "
            elif action.button == "right":
                click_type = "Right "
            elif action.button == "middle":
                click_type = "Middle "
            else:
                click_type = "Left "

            if action.use_match:
                return f"{click_type}@ match"
            elif action.x is not None:
                return f"{click_type}({action.x}, {action.y})"
            return click_type.strip()
        elif isinstance(action, IfImage):
            return action.asset_id or "?"
        elif isinstance(action, Hotkey):
            return "+".join(action.keys) if action.keys else "?"
        elif isinstance(action, TypeText):
            return action.text[:15] + "..." if len(action.text) > 15 else action.text
        elif isinstance(action, Label):
            return action.name or "?"
        elif isinstance(action, Goto):
            return action.label or "?"
        elif isinstance(action, RunFlow):
            return action.flow_name or "?"
        elif isinstance(action, Delay):
            return f"{action.ms}ms"
        elif isinstance(action, DelayRandom):
            return f"{action.min_ms}-{action.max_ms}ms"
        elif isinstance(action, Drag):
            return f"({action.from_x},{action.from_y})‚Üí({action.to_x},{action.to_y})"
        elif isinstance(action, Scroll):
            direction = "‚Üë" if action.amount > 0 else "‚Üì"
            return f"{direction} {abs(action.amount)}"
        elif isinstance(action, Loop):
            count = action.count if action.count else "‚àû"
            return f"{count}x [{len(action.actions)} actions]"
        elif isinstance(action, WhileImage):
            mode = "present" if action.while_present else "absent"
            return f"{action.asset_id} ({mode})"
        elif isinstance(action, WaitPixel):
            c = action.color
            mode = "appear" if action.appear else "disappear"
            return f"({action.x},{action.y}) RGB({c.r},{c.g},{c.b}) {mode}"
        elif isinstance(action, IfPixel):
            c = action.color
            return f"({action.x},{action.y}) RGB({c.r},{c.g},{c.b})"
        elif isinstance(action, ReadText):
            return f"{action.variable_name} = OCR"
        elif isinstance(action, IfText):
            return f"if {action.variable_name} {action.operator} {action.value}"
        return ""

    def highlight_step(self, idx: int) -> None:
        """Highlight currently executing step."""
        # Clear previous highlight
        if 0 <= self._current_highlight < self.action_list.count():
            item = self.action_list.item(self._current_highlight)
            if item:
                item.setBackground(QColor(255, 255, 255))

        # Set new highlight
        self._current_highlight = idx
        if 0 <= idx < self.action_list.count():
            item = self.action_list.item(idx)
            if item:
                item.setBackground(QColor(255, 255, 200))  # Light yellow
                self.action_list.scrollToItem(item)

    def _on_selection_changed(
        self, current: QListWidgetItem | None, _: QListWidgetItem | None
    ) -> None:
        has_selection = current is not None
        self.btn_delete.setEnabled(has_selection)
        self.btn_up.setEnabled(has_selection and self.action_list.currentRow() > 0)
        self.btn_down.setEnabled(
            has_selection and self.action_list.currentRow() < self.action_list.count() - 1
        )

        if current:
            idx = self.action_list.row(current)
            if idx < len(self._actions):
                action = self._actions[idx]
                # Convert to dict for properties panel
                data = {
                    "index": idx,
                    "type": type(action).__name__,
                    "action": action,
                }
                self.action_selected.emit(data)

    def _show_add_menu(self) -> None:
        """Show categorized add action menu with templates."""
        menu = QMenu(self)

        # Add Templates submenu first (most common use case)
        templates_menu = menu.addMenu("‚ú® Templates")
        for template_name in ACTION_TEMPLATES:
            action = templates_menu.addAction(template_name)
            action.triggered.connect(lambda checked=False, t=template_name: self._add_template(t))

        menu.addSeparator()

        # Add categorized actions
        for category_name, actions in ACTION_CATEGORIES.items():
            category_menu = menu.addMenu(category_name)
            for action_type, label in actions:
                action = category_menu.addAction(label)
                action.triggered.connect(
                    lambda checked=False, t=action_type: self._add_action_type(t)
                )

        menu.exec(self.btn_more.mapToGlobal(self.btn_more.rect().bottomLeft()))

    def _add_action(self, action_type: str) -> None:
        """Add a new action of given type."""
        factory = ACTION_DEFAULTS.get(action_type)
        if factory:
            self._save_state()  # Save for undo
            action = factory()
            self._actions.append(action)
            self._refresh_list()

            # Select the new action
            self.action_list.setCurrentRow(len(self._actions) - 1)
            self.action_changed.emit()
            logger.info("Added action: %s", action_type)

    def _add_template(self, template_name: str) -> None:
        """Add a template (multiple actions at once) with smart insertion."""
        template = ACTION_TEMPLATES.get(template_name)
        if not template:
            return

        self._save_state()

        # Smart insertion: insert at current position
        current_row = self.action_list.currentRow()
        insert_pos = len(self._actions) if current_row < 0 else current_row + 1

        # Add all actions from template
        for i, (action_type, params) in enumerate(template):
            action = ACTION_DEFAULTS[action_type]()
            for key, value in params.items():
                if hasattr(action, key):
                    setattr(action, key, value)
            self._actions.insert(insert_pos + i, action)

        self._refresh_list()

        # Auto-select all inserted actions
        self.action_list.clearSelection()
        for i in range(len(template)):
            item = self.action_list.item(insert_pos + i)
            if item:
                item.setSelected(True)

        # Scroll to show first inserted action
        self.action_list.setCurrentRow(insert_pos)
        self.action_list.scrollToItem(self.action_list.item(insert_pos))

        self.action_changed.emit()
        logger.info(
            f"Added template: {template_name} ({len(template)} actions) at position {insert_pos}"
        )

    def _add_template(self, template_name: str) -> None:
        """Add a template (multiple actions at once)."""
        template = ACTION_TEMPLATES.get(template_name)
        if not template:
            return

        self._save_state()  # Save for undo

        # Get insertion index (append at end)
        insert_pos = len(self._actions)

        # Add all actions from template
        for action_type, params in template:
            # Create action with default
            action = ACTION_DEFAULTS[action_type]()

            # Apply template parameters
            for key, value in params.items():
                if hasattr(action, key):
                    setattr(action, key, value)

            self._actions.append(action)

        self._refresh_list()
        # Select first action of template
        self.action_list.setCurrentRow(insert_pos)
        self.action_changed.emit()

        logger.info(f"Added template: {template_name} ({len(template)} actions)")

    def _add_action_type(self, action_type: str) -> None:
        """Add action from categorized menu (alias for _add_action)."""
        self._add_action(action_type)

    def _quick_add(self, action_type: str) -> None:
        """Quick add action after current selection (1-click workflow)."""
        if action_type == "WaitGone":
            self._save_state()
            action = WaitImage(asset_id="", appear=False)
        else:
            factory = ACTION_DEFAULTS.get(action_type)
            if not factory:
                return

            self._save_state()  # Save for undo
            action = factory()

        # Insert after current selection, or at end
        current_row = self.action_list.currentRow()
        insert_pos = current_row + 1 if current_row >= 0 else len(self._actions)

        if insert_pos >= len(self._actions):
            self._actions.append(action)
        else:
            self._actions.insert(insert_pos, action)

        self._refresh_list()
        self.action_list.setCurrentRow(insert_pos)
        self.action_changed.emit()
        logger.info("Quick added: %s at position %d", action_type, insert_pos)

    def _on_delete(self) -> None:
        """Delete selected actions."""
        selected = self.action_list.selectedItems()
        if not selected:
            return

        self._save_state()  # Save for undo
        # Get indices in reverse order to delete from end
        rows = sorted([self.action_list.row(item) for item in selected], reverse=True)
        first_deleted_row = min(rows)  # Remember position for reselection

        for row in rows:
            if 0 <= row < len(self._actions):
                del self._actions[row]

        self._refresh_list()

        # Smart selection: select item at deleted position (or last if beyond end)
        if self.action_list.count() > 0:
            new_row = min(first_deleted_row, self.action_list.count() - 1)
            self.action_list.setCurrentRow(new_row)
            self.action_list.scrollToItem(self.action_list.item(new_row))

        self.action_changed.emit()
        logger.info("Deleted %d actions", len(rows))

    def _on_clear_all(self) -> None:
        """Clear all actions."""
        self._save_state()  # Save for undo
        self._actions.clear()
        self._refresh_list()
        self.action_changed.emit()
        logger.info("Cleared all actions")

    def _on_move_up(self) -> None:
        """Move selected action up."""
        row = self.action_list.currentRow()
        if row > 0:
            self._save_state()
            self._actions[row], self._actions[row - 1] = self._actions[row - 1], self._actions[row]
            self._refresh_list()
            self.action_list.setCurrentRow(row - 1)
            self.action_changed.emit()

    def _on_move_down(self) -> None:
        """Move selected action down."""
        row = self.action_list.currentRow()
        if row < len(self._actions) - 1:
            self._save_state()
            self._actions[row], self._actions[row + 1] = self._actions[row + 1], self._actions[row]
            self._refresh_list()
            self.action_list.setCurrentRow(row + 1)
            self.action_changed.emit()

    def _show_context_menu(self, pos) -> None:  # type: ignore
        """Show enhanced context menu with edit actions."""
        item = self.action_list.itemAt(pos)
        if not item:
            return

        menu = QMenu(self)
        idx = self.action_list.row(item)

        # Run actions
        menu.addAction("‚ñ∂ Test Step", lambda: self.run_step_requested.emit(idx))
        menu.addSeparator()

        # Edit actions
        menu.addAction("üìã Duplicate        Ctrl+D", self._on_duplicate)
        menu.addAction("üìÑ Copy              Ctrl+C", self._on_copy)
        if self._clipboard:
            menu.addAction("üì• Paste             Ctrl+V", self._on_paste)
        menu.addSeparator()

        # Insert actions
        insert_menu = menu.addMenu("‚ûï Insert")
        insert_menu.addAction("‚¨ÜÔ∏è Insert Above", lambda: self._insert_action_at(idx))
        insert_menu.addAction("‚¨áÔ∏è Insert Below", lambda: self._insert_action_at(idx + 1))
        menu.addSeparator()

        # Move actions
        if idx > 0:
            menu.addAction("‚¨ÜÔ∏è Move Up        Ctrl+Shift+‚Üë", self._on_move_up)
        if idx < len(self._actions) - 1:
            menu.addAction("‚¨áÔ∏è Move Down    Ctrl+Shift+‚Üì", self._on_move_down)
        menu.addSeparator()

        # Delete
        menu.addAction("üóëÔ∏è Delete            Del", self._on_delete)

        menu.exec(self.action_list.mapToGlobal(pos))

    def update_action(self, data: dict) -> None:
        """Update action from properties panel."""
        idx = data.get("index", -1)
        action = data.get("action")

        if 0 <= idx < len(self._actions) and action:
            self._save_state()
            self._actions[idx] = action
            self._refresh_list()
            self.action_list.setCurrentRow(idx)
            logger.debug("Updated action %d", idx)

    def _on_asset_dropped_on_item(self, asset_id: str, item_index: int) -> None:
        """Handle asset dropped ON an existing action - update its asset_id."""
        if item_index < 0 or item_index >= len(self._actions):
            return

        self._save_state()
        action = self._actions[item_index]
        action_type = type(action).__name__

        # Only update actions that have asset_id
        if isinstance(action, ClickImage):
            updated = ClickImage(
                asset_id=asset_id,
                button=action.button,
                clicks=action.clicks,
                timeout_ms=action.timeout_ms,
                offset_x=action.offset_x,
                offset_y=action.offset_y,
            )
        elif isinstance(action, ClickUntil):
            # For ClickUntil, update the click_asset_id (primary target)
            updated = ClickUntil(
                click_asset_id=asset_id,
                until_asset_id=action.until_asset_id,
                until_appear=action.until_appear,
                button=action.button,
                click_interval_ms=action.click_interval_ms,
                timeout_ms=action.timeout_ms,
                max_clicks=action.max_clicks,
            )
        elif isinstance(action, WaitImage):
            updated = WaitImage(
                asset_id=asset_id,
                appear=action.appear,
                timeout_ms=action.timeout_ms,
                poll_ms=action.poll_ms,
                roi_override=action.roi_override,
            )
        elif isinstance(action, IfImage):
            updated = IfImage(
                asset_id=asset_id,
                then_actions=action.then_actions,
                else_actions=action.else_actions,
                roi_override=action.roi_override,
            )
        elif isinstance(action, WhileImage):
            updated = WhileImage(
                asset_id=asset_id,
                while_present=action.while_present,
                actions=action.actions,
            )
        else:
            # Action doesn't support asset_id - ignore drop
            logger.warning("Cannot set asset_id on action type: %s", action_type)
            return

        self._actions[item_index] = updated
        self._refresh_list()
        self.action_list.setCurrentRow(item_index)
        self.action_changed.emit()
        logger.info("Updated %s asset_id to: %s", action_type, asset_id)

    def _on_asset_drop_insert(self, asset_id: str, insert_index: int, action_type: str) -> None:
        """Handle asset dropped BETWEEN actions - create chosen action type."""
        self._save_state()
        # Create appropriate action based on type
        if action_type == "WaitImage":
            action = WaitImage(asset_id=asset_id)
        elif action_type == "ClickImage":
            action = ClickImage(asset_id=asset_id)
        elif action_type == "IfImage":
            action = IfImage(asset_id=asset_id)
        elif action_type == "WhileImage":
            action = WhileImage(asset_id=asset_id)
        else:
            action = WaitImage(asset_id=asset_id)  # Fallback

        # Insert at specific position
        if insert_index >= len(self._actions):
            self._actions.append(action)
        else:
            self._actions.insert(insert_index, action)

        self._refresh_list()
        self.action_list.setCurrentRow(insert_index)
        self.action_changed.emit()
        logger.info(f"Created {action_type} at index {insert_index} with asset: {asset_id}")

    def insert_action_for_asset(self, asset_id: str, action_type: str) -> None:
        """Insert action for asset (called from Assets panel context menu)."""
        if action_type == "WaitImage":
            action = WaitImage(asset_id=asset_id)
        elif action_type == "IfImage":
            action = IfImage(asset_id=asset_id)
        else:
            return

        self._actions.append(action)
        self._refresh_list()
        self.action_list.setCurrentRow(len(self._actions) - 1)
        self.action_changed.emit()
        logger.info("Created %s for asset: %s", action_type, asset_id)

    def _on_duplicate(self) -> None:
        """Duplicate selected actions."""
        selected = self.action_list.selectedItems()
        if not selected:
            return

        self._save_state()  # Save for undo
        # Get indices sorted
        rows = sorted([self.action_list.row(item) for item in selected])
        insert_pos = rows[-1] + 1

        for row in rows:
            if 0 <= row < len(self._actions):
                # Deep copy using model copy
                action_copy = self._actions[row].model_copy(deep=True)
                self._actions.insert(insert_pos, action_copy)
                insert_pos += 1

        self._refresh_list()
        self.action_changed.emit()
        logger.info("Duplicated %d actions", len(rows))

    def _on_copy(self) -> None:
        """Copy selected actions to clipboard."""
        selected = self.action_list.selectedItems()
        if not selected:
            return

        # Get actions by sorted indices
        rows = sorted([self.action_list.row(item) for item in selected])
        self._clipboard = [
            self._actions[row].model_copy(deep=True)
            for row in rows
            if 0 <= row < len(self._actions)
        ]
        logger.info("Copied %d actions to clipboard", len(self._clipboard))

    def _on_paste(self) -> None:
        """Paste clipboard actions after current selection."""
        if not self._clipboard:
            return

        self._save_state()  # Save for undo
        # Get insert position (after current selection)
        current = self.action_list.currentRow()
        insert_pos = current + 1 if current >= 0 else len(self._actions)

        for action in self._clipboard:
            action_copy = action.model_copy(deep=True)
            self._actions.insert(insert_pos, action_copy)
            insert_pos += 1
            self.action_changed.emit()
            logger.info("Pasted %d actions", len(self._clipboard))

    def _show_add_menu(self) -> None:
        """Show categorized add action menu with templates."""
        menu = QMenu(self)

        # Add Templates submenu first
        templates_menu = menu.addMenu("‚ú® Templates")
        for template_name in ACTION_TEMPLATES:
            action = templates_menu.addAction(template_name)
            action.triggered.connect(lambda checked=False, t=template_name: self._add_template(t))

        menu.addSeparator()

        # Add categorized actions
        for category_name, actions in ACTION_CATEGORIES.items():
            category_menu = menu.addMenu(category_name)
            for action_type, label in actions:
                action = category_menu.addAction(label)
                action.triggered.connect(lambda checked=False, t=action_type: self._add_action(t))

        menu.exec(self.btn_more.mapToGlobal(self.btn_more.rect().bottomLeft()))

    def _insert_action_at(self, position: int) -> None:
        """Show add menu and insert action at specific position."""
        menu = QMenu(self)
        for action_type, label in ACTION_TYPES:
            action = menu.addAction(label)
            action.setData(action_type)
            action.triggered.connect(
                lambda checked, t=action_type, p=position: self._add_action_at(t, p)
            )
        # Show menu at current item position
        item = self.action_list.item(
            position if position < self.action_list.count() else position - 1
        )
        if item:
            rect = self.action_list.visualItemRect(item)
            global_pos = self.action_list.mapToGlobal(rect.bottomLeft())
            menu.exec(global_pos)

    def _add_action_at(self, action_type: str, position: int) -> None:
        """Add new action at specific position."""
        factory = ACTION_DEFAULTS.get(action_type)
        if factory:
            self._save_state()  # Save for undo
            action = factory()
            if position >= len(self._actions):
                self._actions.append(action)
            else:
                self._actions.insert(position, action)
            self._refresh_list()
            self.action_list.setCurrentRow(position)
            self.action_changed.emit()
            logger.info("Added %s at position %d", action_type, position)

    def _save_state(self) -> None:
        """Save current state to undo stack."""
        # Deep copy all actions
        state = [action.model_copy(deep=True) for action in self._actions]
        self._undo_stack.append(state)
        # Limit stack size
        if len(self._undo_stack) > self._max_undo:
            self._undo_stack.pop(0)
        # Clear redo stack on new action
        self._redo_stack.clear()

    def _on_undo(self) -> None:
        """Undo last action."""
        if not self._undo_stack:
            logger.debug("Nothing to undo")
            return

        # Save current state to redo stack
        current = [action.model_copy(deep=True) for action in self._actions]
        self._redo_stack.append(current)

        # Restore previous state
        self._actions = self._undo_stack.pop()
        self._refresh_list()
        self.action_changed.emit()
        logger.info("Undo: restored to %d actions", len(self._actions))

    def _on_redo(self) -> None:
        """Redo last undone action."""
        if not self._redo_stack:
            logger.debug("Nothing to redo")
            return

        # Save current state to undo stack
        current = [action.model_copy(deep=True) for action in self._actions]
        self._undo_stack.append(current)

        # Restore next state
        self._actions = self._redo_stack.pop()
        self._refresh_list()
        self.action_changed.emit()
        logger.info("Redo: restored to %d actions", len(self._actions))

    def _on_test_step(self) -> None:
        """Test current step (Space key)."""
        row = self.action_list.currentRow()
        if row >= 0:
            self.run_step_requested.emit(row)
            logger.info("Test step: %d", row)

    def _on_search_changed(self, text: str) -> None:
        """Filter action list by search text."""
        search = text.lower().strip()
        for i in range(self.action_list.count()):
            item = self.action_list.item(i)
            if item:
                # Hide items that don't match search
                visible = not search or search in item.text().lower()
                item.setHidden(not visible)

    def _sync_actions_order(self) -> None:
        """
        Synchronize self._actions list with the visual order in QListWidget after a drag-drop reorder.
        This fixes the bug where drag-drop changed visuals but not the underlying data.
        """
        if self.action_list.count() != len(self._actions):
            logger.error(
                "Sync error: Visua list count %d != Data list count %d",
                self.action_list.count(),
                len(self._actions),
            )
            return  # Should not happen unless state is corrupted

        # Create a mapping of original_index -> action
        # We need a copy because we'll be rebuilding self._actions
        # Note: We rely on the UserRole (256) which stores the index AT THE TIME OF LAST REFRESH

        # Snapshot of actions before reorder (we already saved state in about_to_reorder,
        # but we need this reference for reconstruction)
        # However, self._actions HAS NOT CHANGED YET. The visual list HAS changed order.
        # But the UserRole data on items STILL points to the index in the CURRENT self._actions.

        new_actions_list = []

        for i in range(self.action_list.count()):
            item = self.action_list.item(i)
            original_idx = item.data(256)  # Qt.UserRole

            if original_idx is None or original_idx >= len(self._actions):
                logger.error("Sync error: Invalid original index %s", original_idx)
                # Fallback: Just keep original order to prevent data loss?
                # Or try to continue? Better to abort sync if critical error.
                # But partial sync is bad.
                # For safety, we should probably stick to original list if mapping fails.
                return

            new_actions_list.append(self._actions[original_idx])

        # Update the data model
        self._actions = new_actions_list

        # Refresh list to update indices for next time
        self._refresh_list()
        self.action_changed.emit()
        logger.info("Synced action order after drag-drop")

    def _on_double_click(self, item: QListWidgetItem) -> None:
        """Handle double-click for quick inline edit (opens properties panel)."""
        row = self.action_list.row(item)
        if 0 <= row < len(self._actions):
            action = self._actions[row]
            self.action_selected.emit({"index": row, "action": action})
            logger.info("Double-click edit: %s", type(action).__name__)


================================================================================
FILE PATH: app\ui\assets_panel.py
LINES: 710
================================================================================

"""
RetroAuto v2 - Assets Panel

Manages image templates for automation.
Enhanced UX: drag-drop feedback, inline editing, context menu, smart naming.
"""

import re
from pathlib import Path

from PySide6.QtCore import QMimeData, Qt, Signal
from PySide6.QtGui import QAction, QDrag
from PySide6.QtWidgets import (
    QAbstractItemView,
    QApplication,
    QFileDialog,
    QGroupBox,
    QHBoxLayout,
    QInputDialog,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMenu,
    QMessageBox,
    QPushButton,
    QStyledItemDelegate,
    QStyleOptionViewItem,
    QVBoxLayout,
    QWidget,
)


class RenameDelegate(QStyledItemDelegate):
    """Custom delegate to ensure rename editor has enough width."""

    def updateEditorGeometry(self, editor: QWidget, option: QStyleOptionViewItem, index) -> None:
        """Update editor geometry to use full available width."""
        rect = option.rect
        # Expand width to show full text relative to font size
        font_metrics = editor.fontMetrics()
        # Add buffer for padding and emoji
        text_width = font_metrics.horizontalAdvance(index.data()) + 40

        # Use wider of item width or text width
        width = max(rect.width(), text_width)

        # Constrain to parent widget width so it doesn't go off screen
        if editor.parentWidget():
            parent_width = editor.parentWidget().width()
            width = min(width, parent_width - rect.x())

        editor.setGeometry(rect.x(), rect.y(), width, rect.height())


from core.models import AssetImage
from infra import get_logger

logger = get_logger("AssetsPanel")

# Custom MIME type for drag to Actions panel
ASSET_MIME_TYPE = "application/x-retroauto-asset"


# Smart naming categories
NAMING_CATEGORIES = {
    "btn": "Button",
    "dlg": "Dialog/Popup",
    "icon": "Icon",
    "txt": "Text field",
    "img": "Image",
    "menu": "Menu item",
    "tab": "Tab",
    "chk": "Checkbox",
    "lbl": "Label",
}


class AssetListWidget(QListWidget):
    """Custom list widget that sends asset_id via MIME when dragging to Actions."""

    def __init__(self, parent=None) -> None:  # type: ignore
        super().__init__(parent)
        self.setDragEnabled(True)
        self.setDefaultDropAction(Qt.DropAction.CopyAction)

    def startDrag(self, supportedActions) -> None:  # type: ignore
        """Start drag with custom MIME type containing asset_id."""
        item = self.currentItem()
        if not item:
            return

        asset_id = item.data(Qt.ItemDataRole.UserRole)
        if not asset_id:
            return

        # Create drag with custom MIME data
        drag = QDrag(self)
        mime_data = QMimeData()
        mime_data.setData(ASSET_MIME_TYPE, asset_id.encode("utf-8"))
        mime_data.setText(f"Asset: {asset_id}")  # For visual feedback
        drag.setMimeData(mime_data)

        # Execute drag
        drag.exec(Qt.DropAction.CopyAction)


class AssetsPanel(QWidget):
    """
    Panel for managing image assets.

    Features:
    - List of assets with thumbnails
    - Add button (import image / capture)
    - Drag & drop with visual feedback
    - Inline ID editing (double-click)
    - Context menu with quick actions
    - Smart naming suggestions
    """

    asset_selected = Signal(str)  # asset_id
    assets_changed = Signal()  # when list changes
    insert_action_requested = Signal(str, str)  # asset_id, action_type

    def __init__(self) -> None:
        super().__init__()
        self._assets: list[AssetImage] = []
        self._assets_dir: Path | None = None
        self._default_style = ""
        self._init_ui()

    def _init_ui(self) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(4, 4, 4, 4)

        # Group box
        self.group = QGroupBox("Assets")
        group_layout = QVBoxLayout(self.group)

        # Drop hint label (shown when empty)
        self.drop_hint = QLabel("üìÅ K√©o th·∫£ ·∫£nh v√†o ƒë√¢y\nho·∫∑c b·∫•m '+ Add'")
        self.drop_hint.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.drop_hint.setStyleSheet(
            """
            QLabel {
                color: #808080;
                font-size: 11px;
                padding: 20px;
                border: 2px dashed #555555;
                border-radius: 8px;
                background-color: #2a2a2a;
            }
        """
        )
        group_layout.addWidget(self.drop_hint)

        # Asset list with custom drag support (ExtendedSelection enables Ctrl+A and Shift+arrows)
        self.asset_list = AssetListWidget()
        self.asset_list.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.asset_list.currentItemChanged.connect(self._on_selection_changed)
        self.asset_list.itemDoubleClicked.connect(self._on_asset_double_clicked)
        self.asset_list.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.asset_list.customContextMenuRequested.connect(self._show_context_menu)
        group_layout.addWidget(self.asset_list)

        # Buttons
        btn_layout = QHBoxLayout()

        self.btn_add = QPushButton("+ Add")
        self.btn_add.setToolTip("Import images (or drag & drop)")
        self.btn_add.clicked.connect(self._on_add)

        self.btn_delete = QPushButton("Delete")
        self.btn_delete.clicked.connect(self._on_delete)
        self.btn_delete.setEnabled(False)

        self.btn_test = QPushButton("Test Find")
        self.btn_test.setToolTip("Test find this asset on screen")
        self.btn_test.clicked.connect(self._on_test)
        self.btn_test.setEnabled(False)

        btn_layout.addWidget(self.btn_add)
        btn_layout.addWidget(self.btn_delete)
        btn_layout.addWidget(self.btn_test)
        group_layout.addLayout(btn_layout)

        layout.addWidget(self.group)

        # Enable drag & drop
        self.setAcceptDrops(True)
        self._default_style = self.group.styleSheet()
        self._update_visibility()

        # F2 shortcut for inline rename
        from PySide6.QtGui import QKeySequence, QShortcut

        self.rename_shortcut = QShortcut(QKeySequence(Qt.Key.Key_F2), self.asset_list)
        self.rename_shortcut.activated.connect(self._start_inline_rename)

        # Del shortcut for delete selected items
        self.delete_shortcut = QShortcut(QKeySequence(Qt.Key.Key_Delete), self.asset_list)
        self.delete_shortcut.activated.connect(self._on_delete)

        # Ctrl+A shortcut for select all
        self.select_all_shortcut = QShortcut(QKeySequence("Ctrl+A"), self.asset_list)
        self.select_all_shortcut.activated.connect(self.asset_list.selectAll)

        # Handle inline editing
        self.asset_list.setItemDelegate(RenameDelegate(self.asset_list))
        self.asset_list.itemChanged.connect(self._on_item_edited)

    def _update_visibility(self) -> None:
        """Show/hide drop hint based on asset count."""
        has_assets = len(self._assets) > 0
        self.drop_hint.setVisible(not has_assets)
        self.asset_list.setVisible(has_assets)

    def load_assets(self, assets: list[AssetImage]) -> None:
        """Load assets from script with auto-migration for legacy relative paths."""
        self._assets = []
        self.asset_list.clear()

        for asset in assets:
            # Auto-migrate relative paths to absolute
            migrated_asset = self._migrate_asset_path(asset)
            self._assets.append(migrated_asset)
            self._add_list_item(migrated_asset)

        self._update_visibility()

    def _migrate_asset_path(self, asset: AssetImage) -> AssetImage:
        """Migrate relative path to absolute path by searching known locations."""
        asset_path = Path(asset.path)

        # Already absolute - no migration needed
        if asset_path.is_absolute() and asset_path.exists():
            return asset

        # Try to find file in known locations
        candidates = []

        # If we have an assets directory, look there first
        if self._assets_dir:
            candidates.append(self._assets_dir / asset.path)
            candidates.append(self._assets_dir / asset_path.name)

        # Also try project-relative paths
        if self._assets_dir and self._assets_dir.parent:
            project_dir = self._assets_dir.parent
            candidates.append(project_dir / "assets" / asset.path)
            candidates.append(project_dir / asset.path)

        for candidate in candidates:
            if candidate.exists():
                new_path = str(candidate.resolve().as_posix())
                logger.info("Migrated asset path: %s -> %s", asset.path, new_path)
                return AssetImage(
                    id=asset.id,
                    path=new_path,
                    threshold=asset.threshold,
                    method=asset.method,
                    grayscale=asset.grayscale,
                    roi=asset.roi,
                )

        # File not found - keep original path, will fail at load time with clear error
        logger.warning("Could not migrate asset path: %s (file not found)", asset.path)
        return asset

    def get_assets(self) -> list[AssetImage]:
        """Get current assets list for syncing to script."""
        return list(self._assets)

    def _add_list_item(self, asset: AssetImage) -> None:
        """Add item to list widget."""
        item = QListWidgetItem(f"üñºÔ∏è {asset.id}")
        item.setData(Qt.ItemDataRole.UserRole, asset.id)
        item.setToolTip(
            f"ID: {asset.id}\n"
            f"Path: {asset.path}\n"
            f"Threshold: {asset.threshold}\n"
            f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
            f"Double-click: Preview\n"
            f"F2: Rename\n"
            f"Right-click: Options"
        )
        item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)
        self.asset_list.addItem(item)

    def add_asset(self, asset: AssetImage) -> None:
        """Add a new asset."""
        self._assets.append(asset)
        self._add_list_item(asset)
        self._update_visibility()
        self.assets_changed.emit()

    def _on_selection_changed(
        self, current: QListWidgetItem | None, _: QListWidgetItem | None
    ) -> None:
        has_selection = current is not None
        self.btn_delete.setEnabled(has_selection)
        self.btn_test.setEnabled(has_selection)

        if current:
            asset_id = current.data(Qt.ItemDataRole.UserRole)
            self.asset_selected.emit(asset_id)

    def _on_item_double_clicked(self, item: QListWidgetItem) -> None:
        """Handle double-click to rename asset."""
        old_id = item.data(Qt.ItemDataRole.UserRole)
        self._rename_asset(old_id)

    def _on_add(self) -> None:
        """Add new asset via file dialog."""
        paths, _ = QFileDialog.getOpenFileNames(
            self,
            "Select Images",
            "",
            "Images (*.png *.jpg *.jpeg *.bmp);;All Files (*)",
        )

        for path in paths:
            self._import_image(Path(path))

    def _import_image(self, path: Path) -> None:
        """Import image as new asset with smart naming."""
        # Step 1: Try clean filename
        base_id = self._clean_name(path.stem)

        if not self._id_exists(base_id):
            # Unique - use as is
            asset_id = base_id
        else:
            # Step 2: Try with folder prefix (e.g., folder_filename)
            folder_name = self._clean_name(path.parent.name)
            prefixed_id = f"{folder_name}_{base_id}" if folder_name else base_id

            if not self._id_exists(prefixed_id):
                asset_id = prefixed_id
            else:
                # Step 3: Show dialog to let user rename
                asset_id = self._prompt_for_unique_id(base_id, prefixed_id, path)
                if not asset_id:
                    # User cancelled
                    return

        asset = AssetImage(
            id=asset_id,
            path=str(path.resolve().as_posix()),  # Absolute path with forward slashes
            threshold=0.8,
        )
        self.add_asset(asset)
        logger.info("Imported asset: %s from %s (absolute path)", asset_id, path)

    def _clean_name(self, name: str) -> str:
        """Clean a name to valid ID format (lowercase, alphanumeric + underscore)."""
        clean = re.sub(r"[^a-zA-Z0-9_]", "_", name.lower())
        clean = re.sub(r"_+", "_", clean).strip("_")
        if clean.isdigit() or not clean:
            clean = f"img_{clean or 'new'}"
        return clean

    def _id_exists(self, asset_id: str) -> bool:
        """Check if asset ID already exists."""
        return any(a.id == asset_id for a in self._assets)

    def _prompt_for_unique_id(self, base_id: str, prefixed_id: str, path: Path) -> str | None:
        """Show dialog to get unique ID from user when auto-naming fails."""
        # Suggest a numbered version as fallback
        counter = 1
        suggested = prefixed_id
        while self._id_exists(suggested):
            suggested = f"{prefixed_id}_{counter}"
            counter += 1

        new_id, ok = QInputDialog.getText(
            self,
            "T√™n ·∫£nh b·ªã tr√πng",
            f"·∫¢nh '{base_id}' ƒë√£ t·ªìn t·∫°i.\n" f"Folder: {path.parent.name}\n\n" f"Nh·∫≠p ID m·ªõi:",
            text=suggested,
        )

        if not ok or not new_id:
            return None

        # Clean and validate
        clean_id = self._clean_name(new_id)
        if not clean_id:
            QMessageBox.warning(self, "ID kh√¥ng h·ª£p l·ªá", "ID kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.")
            return None

        if self._id_exists(clean_id):
            QMessageBox.warning(
                self, "ID b·ªã tr√πng", f"ID '{clean_id}' ƒë√£ t·ªìn t·∫°i. Vui l√≤ng ch·ªçn t√™n kh√°c."
            )
            return None

        return clean_id

    def _on_delete(self) -> None:
        """Delete selected asset(s)."""
        selected_items = self.asset_list.selectedItems()
        if not selected_items:
            return

        # Collect asset IDs to delete
        deleted_ids = []
        for item in selected_items:
            asset_id = item.data(Qt.ItemDataRole.UserRole)
            deleted_ids.append(asset_id)
            row = self.asset_list.row(item)
            self.asset_list.takeItem(row)

        # Remove from internal list
        self._assets = [a for a in self._assets if a.id not in deleted_ids]
        self._update_visibility()
        self.assets_changed.emit()
        logger.info("Deleted %d asset(s): %s", len(deleted_ids), ", ".join(deleted_ids))

    def _on_test(self) -> None:
        """Test find selected asset on screen."""
        current = self.asset_list.currentItem()
        if current:
            asset_id = current.data(Qt.ItemDataRole.UserRole)
            logger.info("Test find asset: %s", asset_id)
            # TODO: Implement test find with matcher

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Context Menu
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _show_context_menu(self, pos) -> None:  # type: ignore
        """Show context menu with quick actions."""
        item = self.asset_list.itemAt(pos)
        if not item:
            return

        asset_id = item.data(Qt.ItemDataRole.UserRole)
        menu = QMenu(self)

        # Rename
        rename_action = QAction("üìù Rename", self)
        rename_action.triggered.connect(lambda: self._rename_asset(asset_id))
        menu.addAction(rename_action)

        # Copy ID
        copy_action = QAction("üìã Copy ID", self)
        copy_action.triggered.connect(lambda: self._copy_id(asset_id))
        menu.addAction(copy_action)

        # Test Find
        test_action = QAction("üîç Test Find", self)
        test_action.triggered.connect(self._on_test)
        menu.addAction(test_action)

        # Open Folder
        open_folder_action = QAction("üìÇ Open Folder", self)
        open_folder_action.triggered.connect(lambda: self._open_asset_folder(asset_id))
        menu.addAction(open_folder_action)

        menu.addSeparator()

        # Delete
        delete_action = QAction("üóëÔ∏è Delete", self)
        delete_action.triggered.connect(self._on_delete)
        menu.addAction(delete_action)

        menu.exec(self.asset_list.mapToGlobal(pos))

    def _open_asset_folder(self, asset_id: str) -> None:
        """Open the folder containing the asset in file explorer."""
        import os
        import subprocess

        asset = next((a for a in self._assets if a.id == asset_id), None)
        if not asset or not asset.path:
            return

        # Construct full path - support absolute paths
        asset_path = Path(asset.path)
        if asset_path.is_absolute():
            full_path = asset_path
        elif self._assets_dir:
            full_path = self._assets_dir / asset.path
        else:
            full_path = asset_path

        if full_path.exists():
            # Open folder and select the file on Windows
            subprocess.run(["explorer", "/select,", str(full_path)], check=False)
        elif self._assets_dir and self._assets_dir.exists():
            # Just open the assets folder if file doesn't exist
            os.startfile(str(self._assets_dir))  # type: ignore

    def _on_asset_double_clicked(self, item: QListWidgetItem) -> None:
        """Show image preview when double-clicking asset."""
        asset_id = item.data(Qt.ItemDataRole.UserRole)
        asset = next((a for a in self._assets if a.id == asset_id), None)

        if asset and asset.path:
            # Construct full path - support absolute paths
            asset_path = Path(asset.path)
            if asset_path.is_absolute():
                full_path = asset_path
            elif self._assets_dir:
                full_path = self._assets_dir / asset.path
            else:
                full_path = asset_path

            if not full_path.exists():
                logger.warning("Asset image not found: %s", full_path)
                return

            # Show image preview in dialog
            from PySide6.QtWidgets import QDialog, QVBoxLayout

            from app.ui.image_preview import ImagePreview

            dialog = QDialog(self)
            dialog.setWindowTitle(f"Preview: {asset_id}")
            dialog.resize(800, 600)

            layout = QVBoxLayout(dialog)
            layout.setContentsMargins(0, 0, 0, 0)

            preview = ImagePreview()
            preview.load_image(full_path)
            layout.addWidget(preview)

            dialog.exec()

    def set_assets_dir(self, path: Path) -> None:
        """Set the assets directory for resolving relative paths."""
        self._assets_dir = path

    def _rename_asset(self, old_id: str) -> None:
        """Rename an asset with improved dialog."""
        # Create custom dialog for better UX
        from PySide6.QtWidgets import QDialog, QDialogButtonBox, QLabel, QVBoxLayout

        dialog = QDialog(self)
        dialog.setWindowTitle("Rename Asset")
        dialog.setMinimumWidth(450)

        layout = QVBoxLayout(dialog)
        layout.setSpacing(12)

        # Current ID and instructions
        info = QLabel(
            f"<b>Current ID:</b> {old_id}<br><br>"
            "<b>Naming Convention:</b> category_element<br>"
            "Examples: btn_login, icon_close, dlg_confirm"
        )
        layout.addWidget(info)

        # Input field
        layout.addWidget(QLabel("<b>New ID:</b>"))
        input_field = QLineEdit(old_id)
        input_field.setMinimumHeight(32)
        input_field.setStyleSheet("QLineEdit { font-size: 13px; padding: 4px; }")
        input_field.selectAll()
        layout.addWidget(input_field)

        # Buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)

        if dialog.exec() != QDialog.DialogCode.Accepted:
            return

        new_id = input_field.text().strip()
        if not new_id or new_id == old_id:
            return

        # Validate: only allow a-z, 0-9, _
        clean_id = re.sub(r"[^a-z0-9_]", "_", new_id.lower())
        clean_id = re.sub(r"_+", "_", clean_id).strip("_")

        if not clean_id:
            QMessageBox.warning(self, "Invalid ID", "ID cannot be empty.")
            return

        # Check duplicate
        if any(a.id == clean_id for a in self._assets if a.id != old_id):
            QMessageBox.warning(self, "Duplicate ID", f"ID '{clean_id}' already exists.")
            return

        # Update in assets list
        for asset in self._assets:
            if asset.id == old_id:
                # Create new asset with updated ID
                idx = self._assets.index(asset)
                self._assets[idx] = AssetImage(
                    id=clean_id,
                    path=asset.path,
                    threshold=asset.threshold,
                    roi=asset.roi,
                )
                break

        # Update list item
        for i in range(self.asset_list.count()):
            item = self.asset_list.item(i)
            if item and item.data(Qt.ItemDataRole.UserRole) == old_id:
                item.setText(f"üñºÔ∏è {clean_id}")
                item.setData(Qt.ItemDataRole.UserRole, clean_id)
                break

        self.assets_changed.emit()
        logger.info("Renamed asset: %s -> %s", old_id, clean_id)

    def _start_inline_rename(self) -> None:
        """Start inline editing on selected item (F2)."""
        current_item = self.asset_list.currentItem()
        if current_item:
            self.asset_list.editItem(current_item)

    def _on_item_edited(self, item: QListWidgetItem) -> None:
        """Handle inline editing completion."""
        # Get new text without emoji
        new_text = item.text().replace("üñºÔ∏è ", "").strip()
        old_id = item.data(Qt.ItemDataRole.UserRole)

        if not new_text or new_text == old_id:
            # Restore original
            item.setText(f"üñºÔ∏è {old_id}")
            return

        # Validate
        import re

        clean_id = re.sub(r"[^a-z0-9_]", "_", new_text.lower())
        clean_id = re.sub(r"_+", "_", clean_id).strip("_")

        if not clean_id or any(a.id == clean_id for a in self._assets if a.id != old_id):
            # Invalid - restore
            item.setText(f"üñºÔ∏è {old_id}")
            if not clean_id:
                QMessageBox.warning(self, "Invalid ID", "ID cannot be empty.")
            else:
                QMessageBox.warning(self, "Duplicate ID", f"'{clean_id}' exists.")
            return

        # Update asset
        for asset in self._assets:
            if asset.id == old_id:
                asset.id = clean_id
                break

        # Update item
        item.setText(f"üñºÔ∏è {clean_id}")
        item.setData(Qt.ItemDataRole.UserRole, clean_id)

        self.assets_changed.emit()
        logger.info(f"Inline renamed: {old_id} ‚Üí {clean_id}")

    def _copy_id(self, asset_id: str) -> None:
        """Copy asset ID to clipboard."""
        clipboard = QApplication.clipboard()
        if clipboard:
            clipboard.setText(asset_id)
            logger.info("Copied asset ID to clipboard: %s", asset_id)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Drag & Drop with Visual Feedback
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def dragEnterEvent(self, event) -> None:  # type: ignore
        """Handle drag enter with visual feedback."""
        if event.mimeData().hasUrls():
            # Check if any URL is an image
            for url in event.mimeData().urls():
                path = Path(url.toLocalFile())
                if path.suffix.lower() in (".png", ".jpg", ".jpeg", ".bmp"):
                    self.group.setStyleSheet(
                        """
                        QGroupBox {
                            border: 2px dashed #0078d4;
                            border-radius: 8px;
                            background-color: rgba(0, 120, 212, 0.1);
                        }
                        QGroupBox::title {
                            color: #0078d4;
                        }
                    """
                    )
                    event.acceptProposedAction()
                    return

    def dragLeaveEvent(self, event) -> None:  # type: ignore
        """Reset style when drag leaves."""
        self.group.setStyleSheet(self._default_style)

    def dropEvent(self, event) -> None:  # type: ignore
        """Handle drop with import."""
        self.group.setStyleSheet(self._default_style)

        imported_count = 0
        for url in event.mimeData().urls():
            path = Path(url.toLocalFile())
            if path.suffix.lower() in (".png", ".jpg", ".jpeg", ".bmp"):
                self._import_image(path)
                imported_count += 1

        if imported_count > 0:
            logger.info("Imported %d assets via drag & drop", imported_count)


================================================================================
FILE PATH: app\ui\capture_tool.py
LINES: 299
================================================================================

"""
RetroAuto v2 - Screen Capture Tool

Full-screen overlay for region selection.
"""

from collections.abc import Callable
from pathlib import Path

from PySide6.QtCore import QPoint, QRect, Qt, Signal
from PySide6.QtGui import QColor, QGuiApplication, QPainter, QPen, QPixmap
from PySide6.QtWidgets import QWidget

from core.models import ROI, AssetImage
from infra import get_logger

logger = get_logger("CaptureTool")


class CaptureOverlay(QWidget):
    """
    Full-screen overlay for selecting a region.

    Features:
    - Covers entire screen
    - Rubber-band rectangle selection
    - ESC to cancel
    - Preview of selection
    """

    region_selected = Signal(QRect, QPixmap)  # Selected region and cropped image
    cancelled = Signal()

    def __init__(self) -> None:
        super().__init__()
        self._start_pos: QPoint | None = None
        self._current_pos: QPoint | None = None
        self._screenshot: QPixmap | None = None
        self._selection: QRect | None = None
        self._parent_window: QWidget | None = None

        self._init_ui()

    def _init_ui(self) -> None:
        """Initialize overlay window."""
        # Frameless, fullscreen, on top
        self.setWindowFlags(
            Qt.WindowType.FramelessWindowHint
            | Qt.WindowType.WindowStaysOnTopHint
            | Qt.WindowType.Tool
        )
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, False)
        self.setCursor(Qt.CursorShape.CrossCursor)

        # Get screen geometry
        screen = QGuiApplication.primaryScreen()
        if screen:
            geometry = screen.geometry()
            self.setGeometry(geometry)

    def start_capture(self, parent_window: QWidget | None = None) -> None:
        """Start the capture process."""
        self._parent_window = parent_window

        # Hide parent window before capturing screen
        if parent_window:
            parent_window.hide()
            QGuiApplication.processEvents()  # Ensure window is fully hidden
            # Small delay to ensure window is hidden
            import time
            time.sleep(0.15)

        # Take screenshot first
        screen = QGuiApplication.primaryScreen()
        if screen:
            self._screenshot = screen.grabWindow(0)
            self.setGeometry(screen.geometry())

        self._start_pos = None
        self._current_pos = None
        self._selection = None
        self.showFullScreen()
        self.activateWindow()
        logger.info("Capture overlay started")

    def paintEvent(self, event) -> None:  # type: ignore
        """Draw the overlay with selection rectangle."""
        painter = QPainter(self)

        # Draw screenshot as background
        if self._screenshot:
            painter.drawPixmap(0, 0, self._screenshot)

        # Darken non-selected area
        if self._start_pos and self._current_pos:
            rect = self._get_selection_rect()

            # Draw dark overlay
            dark = QColor(0, 0, 0, 128)
            painter.fillRect(self.rect(), dark)

            # Clear selection area (show original screenshot)
            if self._screenshot:
                painter.drawPixmap(rect, self._screenshot, rect)

            # Draw selection border
            pen = QPen(QColor(0, 255, 0), 2, Qt.PenStyle.SolidLine)
            painter.setPen(pen)
            painter.drawRect(rect)

            # Draw size label
            painter.setPen(QPen(Qt.GlobalColor.white))
            size_text = f"{rect.width()} x {rect.height()}"
            painter.drawText(rect.bottomRight() + QPoint(-80, 20), size_text)
        else:
            # Just show dimmed screenshot
            dark = QColor(0, 0, 0, 64)
            painter.fillRect(self.rect(), dark)

            # Instructions
            painter.setPen(QPen(Qt.GlobalColor.white))
            painter.drawText(
                self.rect(),
                Qt.AlignmentFlag.AlignCenter,
                "Click and drag to select region\nESC to cancel",
            )

    def _get_selection_rect(self) -> QRect:
        """Get normalized selection rectangle."""
        if not self._start_pos or not self._current_pos:
            return QRect()

        return QRect(self._start_pos, self._current_pos).normalized()

    def mousePressEvent(self, event) -> None:  # type: ignore
        """Start selection."""
        if event.button() == Qt.MouseButton.LeftButton:
            self._start_pos = event.pos()
            self._current_pos = event.pos()
            self.update()

    def mouseMoveEvent(self, event) -> None:  # type: ignore
        """Update selection."""
        if self._start_pos:
            self._current_pos = event.pos()
            self.update()

    def mouseReleaseEvent(self, event) -> None:  # type: ignore
        """Complete selection."""
        if event.button() == Qt.MouseButton.LeftButton and self._start_pos:
            self._current_pos = event.pos()
            rect = self._get_selection_rect()

            # Minimum size check
            if rect.width() > 5 and rect.height() > 5:
                self._selection = rect
                self._finish_capture()
            else:
                # Too small, reset
                self._start_pos = None
                self._current_pos = None
                self.update()

    def keyPressEvent(self, event) -> None:  # type: ignore
        """Handle keyboard input."""
        if event.key() == Qt.Key.Key_Escape:
            self._restore_parent_window()
            self.hide()
            self.cancelled.emit()
            logger.info("Capture cancelled")

    def _finish_capture(self) -> None:
        """Complete capture and emit result."""
        if not self._selection or not self._screenshot:
            return

        # Crop selection from screenshot
        cropped = self._screenshot.copy(self._selection)

        self._restore_parent_window()
        self.hide()
        self.region_selected.emit(self._selection, cropped)
        logger.info(
            "Region captured: %dx%d at (%d, %d)",
            self._selection.width(),
            self._selection.height(),
            self._selection.x(),
            self._selection.y(),
        )

    def _restore_parent_window(self) -> None:
        """Restore the parent window after capture."""
        if self._parent_window:
            self._parent_window.show()
            self._parent_window.activateWindow()


class CaptureTool:
    """
    High-level capture tool for creating assets.

    Usage:
        tool = CaptureTool(assets_dir)
        tool.capture()  # Shows overlay
        # On selection, creates asset and saves image
    """

    def __init__(
        self,
        assets_dir: Path | None = None,
        existing_asset_ids: set[str] | None = None,
    ) -> None:
        self._assets_dir = assets_dir or Path(".")
        self._overlay = CaptureOverlay()

        # Existing asset IDs from the script (in-memory, may not be on disk)
        self._existing_asset_ids = existing_asset_ids or set()

        # Connect signals
        self._overlay.region_selected.connect(self._on_region_selected)
        self._overlay.cancelled.connect(self._on_cancelled)

        self._callback: Callable | None = None

    def capture(self, callback: Callable | None = None, parent_window: QWidget | None = None) -> None:
        """
        Start capture process.

        Args:
            callback: Function(asset: AssetImage, roi: ROI) called on success
            parent_window: Main window to hide during capture (optional)
        """
        self._callback = callback
        self._overlay.start_capture(parent_window)

    def _on_region_selected(self, rect: QRect, pixmap: QPixmap) -> None:
        """Handle successful region selection."""
        # Get existing asset names to avoid duplicates
        existing_names = self._get_existing_asset_names()

        # Generate unique filename that doesn't conflict with existing assets
        counter = 1
        while True:
            filename = f"capture_{counter}.png"
            asset_id = f"capture_{counter}"  # ID without extension
            path = self._assets_dir / filename

            # Check both: file doesn't exist AND name not in existing assets
            if not path.exists() and asset_id not in existing_names:
                break
            counter += 1

        # Save image
        self._assets_dir.mkdir(parents=True, exist_ok=True)
        pixmap.save(str(path), "PNG")
        logger.info("Saved capture: %s", path)

        # Create asset
        asset = AssetImage(
            id=asset_id,
            path=filename,
            threshold=0.8,
        )

        # Create ROI from selection
        roi = ROI(
            x=rect.x(),
            y=rect.y(),
            w=rect.width(),
            h=rect.height(),
        )

        # Callback
        if self._callback:
            self._callback(asset, roi)

    def _on_cancelled(self) -> None:
        """Handle cancellation."""
        logger.info("Capture cancelled by user")

    def _get_existing_asset_names(self) -> set[str]:
        """Get set of existing asset IDs/names in assets directory.

        Returns:
            Set of asset names (without extension) to avoid duplicates.
        """
        # Start with in-memory asset IDs from the script
        existing = set(self._existing_asset_ids)

        try:
            if self._assets_dir.exists():
                # Also add all image files on disk
                for ext in ["*.png", "*.jpg", "*.jpeg", "*.bmp", "*.gif"]:
                    for path in self._assets_dir.glob(ext):
                        existing.add(path.stem)  # Name without extension
        except Exception as e:
            logger.warning("Error scanning assets: %s", e)
        return existing



================================================================================
FILE PATH: app\ui\code_editor.py
LINES: 544
================================================================================

"""
RetroAuto v2 - DSL Code Editor

Custom QPlainTextEdit-based code editor for the DSL.
Features:
- Line numbers (Win95/98 style)
- Syntax highlighting
- Current line highlighting
- Auto-indent
- Tab to spaces conversion
- Breakpoint markers
"""

from __future__ import annotations

from PySide6.QtCore import QRect, QSize, Qt, Signal
from PySide6.QtGui import (
    QBrush,
    QColor,
    QFont,
    QKeyEvent,
    QMouseEvent,
    QPainter,
    QTextCursor,
    QTextFormat,
)
from PySide6.QtWidgets import QPlainTextEdit, QTextEdit, QToolTip, QWidget

from app.ui.minimap import Minimap
from app.ui.syntax_highlighter import DSLHighlighter
from app.ui.win95_style import COLORS

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Line Number Area (with breakpoint gutter)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class LineNumberArea(QWidget):
    """Line number gutter with breakpoint support."""

    BREAKPOINT_MARGIN = 16  # Width for breakpoint markers

    def __init__(self, editor: DSLCodeEditor) -> None:
        super().__init__(editor)
        self.editor = editor

    def sizeHint(self) -> QSize:
        return QSize(self.editor.line_number_area_width(), 0)

    def paintEvent(self, event) -> None:  # type: ignore
        """Paint line numbers and breakpoints."""
        self.editor.line_number_area_paint_event(event)

    def mousePressEvent(self, event: QMouseEvent) -> None:
        """Handle click to toggle breakpoint."""
        if event.button() == Qt.MouseButton.LeftButton:  # noqa: SIM102
            # Check if click is in breakpoint margin
            if event.position().x() < self.BREAKPOINT_MARGIN:
                # Find which line was clicked
                block = self.editor.firstVisibleBlock()
                top = int(
                    self.editor.blockBoundingGeometry(block)
                    .translated(self.editor.contentOffset())
                    .top()
                )

                while block.isValid():
                    if block.isVisible():
                        block_top = top
                        block_bottom = top + int(self.editor.blockBoundingRect(block).height())

                        if block_top <= event.position().y() < block_bottom:
                            line = block.blockNumber() + 1
                            self.editor.toggle_breakpoint(line)
                            self.update()
                            return

                    top += int(self.editor.blockBoundingRect(block).height())
                    block = block.next()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Code Editor
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class DSLCodeEditor(QPlainTextEdit):
    """
    DSL code editor with Win95/98 styling.

    Features:
    - Line numbers with classic styling
    - Syntax highlighting for DSL
    - Current line highlight
    - Smart indentation
    - Tab to 2-space conversion
    - Breakpoint markers
    - Debug line highlighting

    Signals:
        content_changed: Emitted when content changes
        cursor_position_changed: Emitted with (line, col)
        breakpoint_toggled: Emitted when breakpoint is toggled (line, enabled)
    """

    content_changed = Signal()
    cursor_position_changed = Signal(int, int)
    breakpoint_toggled = Signal(int, bool)  # line, is_set

    TAB_SIZE = 2  # 2-space indent per DSL spec

    def __init__(self, parent=None) -> None:  # type: ignore
        super().__init__(parent)
        self._breakpoints: set[int] = set()  # Set of line numbers with breakpoints
        self._debug_line: int | None = None  # Current debug execution line
        self._init_style()
        self._init_line_numbers()
        self._init_highlighter()
        self._init_highlighter()
        self._connect_signals()

        self.setMouseTracking(True)
        self._asset_provider = None  # Callable[[str], Path | None]

        # Minimap (Overlay)
        self.minimap = Minimap(self)
        self.minimap.show()

    def set_asset_provider(self, provider) -> None:
        """Set callback to lookup asset path from ID."""
        self._asset_provider = provider

    def _init_style(self) -> None:
        """Set up editor styling."""
        # Font
        font = QFont("Courier New", 10)
        font.setStyleHint(QFont.StyleHint.Monospace)
        font.setFixedPitch(True)
        self.setFont(font)

        # Tab width
        self.setTabStopDistance(self.fontMetrics().horizontalAdvance(" ") * self.TAB_SIZE)

        # Colors - Dark theme
        self.setStyleSheet(
            f"""
            QPlainTextEdit {{
                background-color: {COLORS["editor_bg"]};
                color: #d4d4d4;
                border: 1px solid {COLORS["shadow_dark"]};
                selection-background-color: {COLORS["highlight"]};
                selection-color: {COLORS["highlight_text"]};
            }}
        """
        )

        # Current line highlight color - dark theme
        self.current_line_color = QColor("#2d2d2d")  # Subtle dark highlight
        self.debug_line_color = QColor("#3a3a00")  # Dark yellow for debug

    def _init_line_numbers(self) -> None:
        """Set up line number gutter."""
        self.line_number_area = LineNumberArea(self)
        self.blockCountChanged.connect(self._update_line_number_area_width)
        self.updateRequest.connect(self._update_line_number_area)
        self._update_line_number_area_width()

    def _init_highlighter(self) -> None:
        """Set up syntax highlighter."""
        self.highlighter = DSLHighlighter(self.document())

    def _connect_signals(self) -> None:
        """Connect internal signals."""
        self.textChanged.connect(self._on_text_changed)
        self.cursorPositionChanged.connect(self._on_cursor_moved)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Line Numbers
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def line_number_area_width(self) -> int:
        """Calculate width needed for line numbers."""
        digits = len(str(max(1, self.blockCount())))
        digits = max(digits, 3)  # Minimum 3 digits
        space = 8 + self.fontMetrics().horizontalAdvance("9") * digits
        return space

    def _update_line_number_area_width(self) -> None:
        """Update viewport margins for line numbers AND minimap."""
        left_margin = self.line_number_area_width()
        right_margin = self.minimap.WIDTH if hasattr(self, "minimap") else 0
        self.setViewportMargins(left_margin, 0, right_margin, 0)

    def _update_line_number_area(self, rect: QRect, dy: int) -> None:
        """Update line number area on scroll."""
        if dy:
            self.line_number_area.scroll(0, dy)
        else:
            self.line_number_area.update(0, rect.y(), self.line_number_area.width(), rect.height())

        if rect.contains(self.viewport().rect()):
            self._update_line_number_area_width()

    def resizeEvent(self, event) -> None:  # type: ignore
        """Handle resize to adjust line number area AND minimap."""
        super().resizeEvent(event)
        cr = self.contentsRect()

        # Line number area (left)
        self.line_number_area.setGeometry(
            QRect(cr.left(), cr.top(), self.line_number_area_width(), cr.height())
        )

        # Minimap (right overlay)
        if hasattr(self, "minimap"):
            w = self.minimap.WIDTH
            self.minimap.setGeometry(QRect(cr.right() - w, cr.top(), w, cr.height()))

    def line_number_area_paint_event(self, event) -> None:  # type: ignore
        """Paint the line number gutter with breakpoint markers."""
        painter = QPainter(self.line_number_area)

        # Background (Win95 gray)
        painter.fillRect(event.rect(), QColor(COLORS["gutter_bg"]))

        # Border line
        painter.setPen(QColor(COLORS["border"]))
        painter.drawLine(
            self.line_number_area.width() - 1,
            event.rect().top(),
            self.line_number_area.width() - 1,
            event.rect().bottom(),
        )

        # Draw line numbers and breakpoints
        block = self.firstVisibleBlock()
        block_number = block.blockNumber()
        top = int(self.blockBoundingGeometry(block).translated(self.contentOffset()).top())
        bottom = top + int(self.blockBoundingRect(block).height())

        while block.isValid() and top <= event.rect().bottom():
            if block.isVisible() and bottom >= event.rect().top():
                line = block_number + 1

                # Draw breakpoint marker (red circle)
                if line in self._breakpoints:
                    circle_y = top + (self.fontMetrics().height() - 12) // 2
                    painter.setBrush(QBrush(QColor("#CC0000")))  # Dark red
                    painter.setPen(QColor("#800000"))
                    painter.drawEllipse(2, circle_y, 12, 12)

                # Draw debug arrow (yellow arrow on current debug line)
                if self._debug_line == line:
                    arrow_y = top + (self.fontMetrics().height() - 8) // 2
                    painter.setBrush(QBrush(QColor("#FFFF00")))  # Yellow
                    painter.setPen(QColor("#808000"))
                    # Draw simple arrow
                    painter.drawRect(2, arrow_y + 2, 8, 4)
                    painter.drawLine(10, arrow_y, 14, arrow_y + 4)
                    painter.drawLine(10, arrow_y + 8, 14, arrow_y + 4)

                # Draw line number
                painter.setPen(QColor(COLORS["line_number"]))
                painter.drawText(
                    0,
                    top,
                    self.line_number_area.width() - 4,
                    self.fontMetrics().height(),
                    Qt.AlignmentFlag.AlignRight,
                    str(line),
                )

            block = block.next()
            top = bottom
            bottom = top + int(self.blockBoundingRect(block).height())
            block_number += 1

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Current Line Highlight
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _highlight_current_line(self) -> None:
        """Highlight the current line."""
        extra_selections: list[QTextEdit.ExtraSelection] = []

        if not self.isReadOnly():
            selection = QTextEdit.ExtraSelection()
            selection.format.setBackground(self.current_line_color)
            selection.format.setProperty(QTextFormat.Property.FullWidthSelection, True)
            selection.cursor = self.textCursor()
            selection.cursor.clearSelection()
            extra_selections.append(selection)

        self.setExtraSelections(extra_selections)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Mouse Events (Asset Peek)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def mouseMoveEvent(self, event: QMouseEvent) -> None:
        """Handle mouse move for Asset Peek tooltip."""
        super().mouseMoveEvent(event)

        if not self._asset_provider:
            return

        # Get cursor under mouse
        cursor = self.cursorForPosition(event.position().toPoint())

        # Select word under cursor
        cursor.select(QTextCursor.SelectionType.WordUnderCursor)
        word = cursor.selectedText().strip("\"'")

        if not word:
            return

        # Check if it looks like an asset ID (alphanumeric + underscore)
        if not word.replace("_", "").isalnum():
            return

        # Try to resolve asset
        image_path = self._asset_provider(word)
        if image_path and image_path.exists():
            # Show tooltip with image
            # Convert path to string using forward slashes for HTML compatibility
            html_path = str(image_path).replace("\\", "/")

            tooltip_html = f"""
            <div style='background-color: #2d2d2d; color: #fff; padding: 4px; border: 1px solid #0078d4;'>
                <div style='font-weight: bold; margin-bottom: 4px;'>üì∑ {word}</div>
                <img src='file:///{html_path}' width='200' />
            </div>
            """

            QToolTip.showText(event.globalPosition().toPoint(), tooltip_html, self)
        else:
            QToolTip.hideText()

    # resizeEvent unified above (handles both line numbers and minimap)

    def keyPressEvent(self, event: QKeyEvent) -> None:
        """Handle key events for editor behavior."""
        # Tab -> spaces
        if event.key() == Qt.Key.Key_Tab:
            if event.modifiers() & Qt.KeyboardModifier.ShiftModifier:
                self._unindent()
            else:
                self._insert_spaces()
            return

        # Enter -> auto-indent
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            self._insert_newline_with_indent()
            return

        # Backspace -> smart unindent
        if event.key() == Qt.Key.Key_Backspace and self._smart_backspace():
            return

        super().keyPressEvent(event)

    def _insert_spaces(self) -> None:
        """Insert spaces instead of tab."""
        cursor = self.textCursor()
        cursor.insertText(" " * self.TAB_SIZE)

    def _unindent(self) -> None:
        """Remove one level of indentation."""
        cursor = self.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)
        cursor.movePosition(QTextCursor.MoveOperation.EndOfLine, QTextCursor.MoveMode.KeepAnchor)
        line = cursor.selectedText()

        # Remove leading spaces
        if line.startswith(" " * self.TAB_SIZE):
            cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)
            cursor.movePosition(
                QTextCursor.MoveOperation.Right, QTextCursor.MoveMode.KeepAnchor, self.TAB_SIZE
            )
            cursor.removeSelectedText()
        elif line.startswith("\t"):
            cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)
            cursor.movePosition(QTextCursor.MoveOperation.Right, QTextCursor.MoveMode.KeepAnchor, 1)
            cursor.removeSelectedText()

    def _insert_newline_with_indent(self) -> None:
        """Insert newline and match previous line's indentation."""
        cursor = self.textCursor()

        # Get current line's indentation
        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)
        cursor.movePosition(QTextCursor.MoveOperation.EndOfLine, QTextCursor.MoveMode.KeepAnchor)
        current_line = cursor.selectedText()

        # Calculate indent
        indent = ""
        for char in current_line:
            if char == " ":
                indent += " "
            elif char == "\t":
                indent += " " * self.TAB_SIZE
            else:
                break

        # Check if we should increase indent (line ends with {)
        stripped = current_line.rstrip()
        if stripped.endswith("{"):
            indent += " " * self.TAB_SIZE

        # Insert newline with indent
        cursor = self.textCursor()
        cursor.insertText("\n" + indent)

    def _smart_backspace(self) -> bool:
        """Smart backspace to remove indent levels."""
        cursor = self.textCursor()

        # Only at start of non-empty indent
        if cursor.positionInBlock() == 0:
            return False

        # Get text before cursor on current line
        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)
        cursor.movePosition(
            QTextCursor.MoveOperation.Right,
            QTextCursor.MoveMode.KeepAnchor,
            self.textCursor().positionInBlock(),
        )
        before = cursor.selectedText()

        # If only spaces before cursor, remove indent level
        if before and before.strip() == "":
            spaces_to_remove = len(before) % self.TAB_SIZE
            if spaces_to_remove == 0:
                spaces_to_remove = self.TAB_SIZE

            cursor = self.textCursor()
            for _ in range(spaces_to_remove):
                cursor.deletePreviousChar()
            return True

        return False

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Signal Handlers
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _on_text_changed(self) -> None:
        """Handle text change."""
        self.content_changed.emit()
        self._highlight_current_line()

    def _on_cursor_moved(self) -> None:
        """Handle cursor position change."""
        cursor = self.textCursor()
        line = cursor.blockNumber() + 1
        col = cursor.columnNumber() + 1
        self.cursor_position_changed.emit(line, col)
        self._highlight_current_line()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Public API
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def get_code(self) -> str:
        """Get editor content."""
        return self.toPlainText()

    def set_code(self, code: str) -> None:
        """Set editor content."""
        self.setPlainText(code)

    def goto_line(self, line: int, col: int = 1) -> None:
        """Move cursor to specific line and column."""
        block = self.document().findBlockByLineNumber(line - 1)
        if block.isValid():
            cursor = self.textCursor()
            cursor.setPosition(block.position() + min(col - 1, block.length() - 1))
            self.setTextCursor(cursor)
            self.centerCursor()

    def get_cursor_position(self) -> tuple[int, int]:
        """Get current (line, column) position."""
        cursor = self.textCursor()
        return (cursor.blockNumber() + 1, cursor.columnNumber() + 1)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Breakpoint API
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def toggle_breakpoint(self, line: int) -> None:
        """Toggle breakpoint at line."""
        if line in self._breakpoints:
            self._breakpoints.remove(line)
            self.breakpoint_toggled.emit(line, False)
        else:
            self._breakpoints.add(line)
            self.breakpoint_toggled.emit(line, True)
        self.line_number_area.update()

    def set_breakpoint(self, line: int) -> None:
        """Set a breakpoint at line."""
        if line not in self._breakpoints:
            self._breakpoints.add(line)
            self.breakpoint_toggled.emit(line, True)
            self.line_number_area.update()

    def clear_breakpoint(self, line: int) -> None:
        """Clear breakpoint at line."""
        if line in self._breakpoints:
            self._breakpoints.remove(line)
            self.breakpoint_toggled.emit(line, False)
            self.line_number_area.update()

    def clear_all_breakpoints(self) -> None:
        """Clear all breakpoints."""
        for line in list(self._breakpoints):
            self.breakpoint_toggled.emit(line, False)
        self._breakpoints.clear()
        self.line_number_area.update()

    def get_breakpoints(self) -> set[int]:
        """Get set of lines with breakpoints."""
        return self._breakpoints.copy()

    def has_breakpoint(self, line: int) -> bool:
        """Check if line has a breakpoint."""
        return line in self._breakpoints

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Debug Line API
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def set_debug_line(self, line: int | None) -> None:
        """Set the current debug execution line (highlighted yellow)."""
        self._debug_line = line
        self._highlight_current_line()
        if line:
            self.goto_line(line)

    def clear_debug_line(self) -> None:
        """Clear debug line highlighting."""
        self._debug_line = None
        self._highlight_current_line()


================================================================================
FILE PATH: app\ui\coordinates_panel.py
LINES: 256
================================================================================

"""
RetroAuto v2 - Coordinates Panel

Panel to capture and manage mouse coordinates.
Features:
- F4 to capture current mouse position
- Right-click context menu for click actions
- Multi-selection with Ctrl+A, Shift+Arrow, Delete
"""

from __future__ import annotations

from dataclasses import dataclass

from PySide6.QtCore import QPoint, Qt, Signal
from PySide6.QtGui import QBrush, QColor, QCursor, QKeySequence, QShortcut
from PySide6.QtWidgets import (
    QGroupBox,
    QHBoxLayout,
    QLabel,
    QListWidget,
    QListWidgetItem,
    QMenu,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

from input.mouse import MouseController


@dataclass
class Coordinate:
    """A saved coordinate."""

    index: int
    x: int
    y: int


class CoordinatesPanel(QWidget):
    """
    Panel for capturing and managing mouse coordinates.

    Features:
    - F4: Capture current mouse position
    - Right-click: Send click or add to script
    - Ctrl+A: Select all
    - Shift+Up/Down: Extend selection
    - Delete: Remove selected

    Signals:
        coordinate_added: Emitted when coordinate is captured (x, y)
        add_to_script: Emitted to add click action to script (x, y, button, clicks)
    """

    coordinate_added = Signal(int, int)
    add_to_script = Signal(int, int, str, int)  # x, y, button, clicks

    def __init__(self, parent=None) -> None:  # type: ignore
        super().__init__(parent)
        self._coordinates: list[Coordinate] = []
        self._next_index = 1
        self._mouse = MouseController()
        self._init_ui()
        self._setup_shortcuts()

    def _init_ui(self) -> None:
        """Initialize the UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(4)

        # Group box
        group = QGroupBox("üìç Coordinates (F4)")
        group_layout = QVBoxLayout(group)

        # List widget matching Actions panel style
        self.coord_list = QListWidget()
        self.coord_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection)
        self.coord_list.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.coord_list.customContextMenuRequested.connect(self._show_context_menu)
        self.coord_list.setStyleSheet(
            """
            QListWidget {
                background-color: #2B2B2B;
                border: 2px inset #808080;
                font-family: "Consolas", "Courier New", monospace;
                font-size: 9pt;
                color: #E0E0E0;
            }
            QListWidget::item {
                padding: 2px 4px;
                border-bottom: 1px solid #3C3C3C;
            }
            QListWidget::item:selected {
                background-color: #264F78;
                color: #FFFFFF;
            }
            QListWidget::item:hover {
                background-color: #3C3C3C;
            }
        """
        )
        group_layout.addWidget(self.coord_list)

        # Buttons
        btn_layout = QHBoxLayout()

        self.capture_btn = QPushButton("üìç F4")
        self.capture_btn.setToolTip("Capture mouse position (F4)")
        self.capture_btn.clicked.connect(self._on_capture)
        btn_layout.addWidget(self.capture_btn)

        self.delete_btn = QPushButton("üóëÔ∏è")
        self.delete_btn.setToolTip("Delete selected (Del)")
        self.delete_btn.clicked.connect(self._on_delete_selected)
        btn_layout.addWidget(self.delete_btn)

        self.clear_btn = QPushButton("Clear")
        self.clear_btn.clicked.connect(self._on_clear_all)
        btn_layout.addWidget(self.clear_btn)

        group_layout.addLayout(btn_layout)

        # Current position label
        self.pos_label = QLabel("üñ±Ô∏è (0, 0)")
        self.pos_label.setStyleSheet("color: #404040; font-size: 9pt;")
        group_layout.addWidget(self.pos_label)

        layout.addWidget(group)

    def _setup_shortcuts(self) -> None:
        """Setup keyboard shortcuts."""
        # F4 to capture
        self.f4_shortcut = QShortcut(QKeySequence(Qt.Key.Key_F4), self)
        self.f4_shortcut.activated.connect(self._on_capture)

        # Ctrl+Space to capture (alternative)
        self.ctrl_space_shortcut = QShortcut(QKeySequence("Ctrl+Space"), self)
        self.ctrl_space_shortcut.activated.connect(self._on_capture)

        # Delete key
        self.del_shortcut = QShortcut(QKeySequence(Qt.Key.Key_Delete), self.coord_list)
        self.del_shortcut.setContext(Qt.ShortcutContext.WidgetShortcut)
        self.del_shortcut.activated.connect(self._on_delete_selected)

        # Ctrl+A to select all
        self.select_all_shortcut = QShortcut(QKeySequence.StandardKey.SelectAll, self.coord_list)
        self.select_all_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.select_all_shortcut.activated.connect(self.coord_list.selectAll)

    def _on_capture(self) -> None:
        """Capture current mouse position."""
        pos = QCursor.pos()
        x, y = pos.x(), pos.y()

        coord = Coordinate(index=self._next_index, x=x, y=y)
        self._coordinates.append(coord)
        self._next_index += 1

        # Add to list with color
        item = QListWidgetItem(f"#{coord.index:02d}  ({x:4d}, {y:4d})")
        item.setData(Qt.ItemDataRole.UserRole, coord)
        item.setBackground(QBrush(QColor("#FFFFEE")))
        self.coord_list.addItem(item)

        # Update label
        self.pos_label.setText(f"üñ±Ô∏è ({x}, {y}) ‚úì")

        # Emit signal
        self.coordinate_added.emit(x, y)

    def _show_context_menu(self, pos: QPoint) -> None:
        """Show context menu for click actions."""
        selected = self.coord_list.selectedItems()
        if not selected:
            return

        count = len(selected)
        menu = QMenu(self)

        # Add to Script - works for multiple selected items
        label = f"üìù Add {count} to Script" if count > 1 else "üìù Add to Script"
        script_menu = menu.addMenu(label)

        add_left = script_menu.addAction("Left Click")
        add_left.triggered.connect(lambda: self._add_selected_to_script("left", 1))

        add_right = script_menu.addAction("Right Click")
        add_right.triggered.connect(lambda: self._add_selected_to_script("right", 1))

        add_double = script_menu.addAction("Double Click")
        add_double.triggered.connect(lambda: self._add_selected_to_script("left", 2))

        add_middle = script_menu.addAction("Middle Click")
        add_middle.triggered.connect(lambda: self._add_selected_to_script("middle", 1))

        menu.addSeparator()

        # Delete action
        delete_label = f"üóëÔ∏è Delete ({count})" if count > 1 else "üóëÔ∏è Delete"
        delete_action = menu.addAction(delete_label)
        delete_action.triggered.connect(self._on_delete_selected)

        menu.exec(self.coord_list.mapToGlobal(pos))

    def _add_selected_to_script(self, button: str, clicks: int) -> None:
        """Add all selected coordinates to script."""
        selected = self.coord_list.selectedItems()
        for item in selected:
            coord: Coordinate = item.data(Qt.ItemDataRole.UserRole)
            self.add_to_script.emit(coord.x, coord.y, button, clicks)

    def _add_to_script(self, item: QListWidgetItem, button: str, clicks: int) -> None:
        """Add click action to script."""
        coord: Coordinate = item.data(Qt.ItemDataRole.UserRole)
        self.add_to_script.emit(coord.x, coord.y, button, clicks)

    def _send_click(self, item: QListWidgetItem, button: str) -> None:
        """Send a click to the coordinate."""
        coord: Coordinate = item.data(Qt.ItemDataRole.UserRole)

        if button == "left":
            self._mouse.click(coord.x, coord.y, "left", 1)
        elif button == "right":
            self._mouse.click(coord.x, coord.y, "right", 1)
        elif button == "double":
            self._mouse.click(coord.x, coord.y, "left", 2)
        elif button == "middle":
            self._mouse.click(coord.x, coord.y, "middle", 1)

    def _on_delete_selected(self) -> None:
        """Delete selected coordinates."""
        selected = self.coord_list.selectedItems()
        for item in selected:
            coord: Coordinate = item.data(Qt.ItemDataRole.UserRole)
            if coord in self._coordinates:
                self._coordinates.remove(coord)
            row = self.coord_list.row(item)
            self.coord_list.takeItem(row)

    def _on_clear_all(self) -> None:
        """Clear all coordinates."""
        self._coordinates.clear()
        self.coord_list.clear()
        self._next_index = 1

    def get_coordinates(self) -> list[tuple[int, int]]:
        """Get all coordinates as (x, y) tuples."""
        return [(c.x, c.y) for c in self._coordinates]

    def update_mouse_position(self) -> None:
        """Update the current mouse position label."""
        pos = QCursor.pos()
        self.pos_label.setText(f"üñ±Ô∏è ({pos.x()}, {pos.y()})")


================================================================================
FILE PATH: app\ui\debug_panel.py
LINES: 394
================================================================================

"""
RetroAuto v2 - Debug Panel

Win95-style debug panel showing:
- Call Stack
- Variables/Watch
- Breakpoints list
"""

from __future__ import annotations

from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QColor
from PySide6.QtWidgets import (
    QHBoxLayout,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QPushButton,
    QTabWidget,
    QTreeWidget,
    QTreeWidgetItem,
    QVBoxLayout,
    QWidget,
)

from core.dsl.debugger import Breakpoint, Debugger, StackFrame, Variable


class DebugPanel(QWidget):
    """
    Debug panel with Win95 styling.

    Tabs:
    - Call Stack: Current execution stack
    - Variables: Local and watch variables
    - Breakpoints: List of all breakpoints

    Signals:
        frame_selected: Stack frame was selected (frame_id)
        breakpoint_toggled: Breakpoint enable toggled (bp_id)
        breakpoint_removed: Breakpoint was removed (bp_id)
        goto_source: Navigate to source location (file, line)
    """

    frame_selected = Signal(int)
    breakpoint_toggled = Signal(int)
    breakpoint_removed = Signal(int)
    goto_source = Signal(str, int)

    def __init__(self, debugger: Debugger | None = None, parent=None) -> None:  # type: ignore
        super().__init__(parent)
        self._debugger = debugger or Debugger()
        self._init_ui()

    def _init_ui(self) -> None:
        """Initialize the UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Debug toolbar
        toolbar = QHBoxLayout()
        toolbar.setContentsMargins(4, 4, 4, 4)
        toolbar.setSpacing(4)

        self.continue_btn = QPushButton("‚ñ∂ Continue")
        self.continue_btn.clicked.connect(self._on_continue)
        toolbar.addWidget(self.continue_btn)

        self.pause_btn = QPushButton("‚è∏ Pause")
        self.pause_btn.clicked.connect(self._on_pause)
        toolbar.addWidget(self.pause_btn)

        self.step_over_btn = QPushButton("‚§µ Step Over")
        self.step_over_btn.clicked.connect(self._on_step_over)
        toolbar.addWidget(self.step_over_btn)

        self.step_into_btn = QPushButton("‚Ü¥ Step Into")
        self.step_into_btn.clicked.connect(self._on_step_into)
        toolbar.addWidget(self.step_into_btn)

        self.step_out_btn = QPushButton("‚Ü± Step Out")
        self.step_out_btn.clicked.connect(self._on_step_out)
        toolbar.addWidget(self.step_out_btn)

        self.stop_btn = QPushButton("‚ñ† Stop")
        self.stop_btn.clicked.connect(self._on_stop)
        toolbar.addWidget(self.stop_btn)

        toolbar.addStretch()
        layout.addLayout(toolbar)

        # Tab widget
        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # Call Stack tab
        self.stack_widget = self._create_stack_tab()
        self.tabs.addTab(self.stack_widget, "Call Stack")

        # Variables tab
        self.variables_widget = self._create_variables_tab()
        self.tabs.addTab(self.variables_widget, "Variables")

        # Breakpoints tab
        self.breakpoints_widget = self._create_breakpoints_tab()
        self.tabs.addTab(self.breakpoints_widget, "Breakpoints")

        self._apply_style()
        self._update_button_states()

    def _create_stack_tab(self) -> QWidget:
        """Create the call stack tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(4, 4, 4, 4)

        self.stack_list = QListWidget()
        self.stack_list.itemDoubleClicked.connect(self._on_stack_item_clicked)
        self.stack_list.setStyleSheet(
            """
            QListWidget {
                background-color: #FFFFFF;
                border: 2px inset #808080;
            }
            QListWidget::item:selected {
                background-color: #000080;
                color: #FFFFFF;
            }
        """
        )
        layout.addWidget(self.stack_list)

        return widget

    def _create_variables_tab(self) -> QWidget:
        """Create the variables/watch tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(4)

        # Variables tree
        self.variables_tree = QTreeWidget()
        self.variables_tree.setHeaderLabels(["Name", "Value", "Type"])
        self.variables_tree.setColumnWidth(0, 150)
        self.variables_tree.setColumnWidth(1, 200)
        self.variables_tree.setStyleSheet(
            """
            QTreeWidget {
                background-color: #FFFFFF;
                border: 2px inset #808080;
            }
            QTreeWidget::item:selected {
                background-color: #000080;
                color: #FFFFFF;
            }
        """
        )
        layout.addWidget(self.variables_tree)

        # Watch expression input
        watch_layout = QHBoxLayout()
        self.watch_input = QLineEdit()
        self.watch_input.setPlaceholderText("Enter expression to watch...")
        self.watch_input.returnPressed.connect(self._on_add_watch)
        watch_layout.addWidget(self.watch_input)

        add_watch_btn = QPushButton("Add")
        add_watch_btn.clicked.connect(self._on_add_watch)
        watch_layout.addWidget(add_watch_btn)

        layout.addLayout(watch_layout)

        return widget

    def _create_breakpoints_tab(self) -> QWidget:
        """Create the breakpoints tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(4, 4, 4, 4)

        self.breakpoints_list = QListWidget()
        self.breakpoints_list.itemDoubleClicked.connect(self._on_breakpoint_clicked)
        self.breakpoints_list.setStyleSheet(
            """
            QListWidget {
                background-color: #FFFFFF;
                border: 2px inset #808080;
            }
            QListWidget::item:selected {
                background-color: #000080;
                color: #FFFFFF;
            }
        """
        )
        layout.addWidget(self.breakpoints_list)

        # Buttons
        btn_layout = QHBoxLayout()

        toggle_btn = QPushButton("Toggle")
        toggle_btn.clicked.connect(self._on_toggle_breakpoint)
        btn_layout.addWidget(toggle_btn)

        remove_btn = QPushButton("Remove")
        remove_btn.clicked.connect(self._on_remove_breakpoint)
        btn_layout.addWidget(remove_btn)

        clear_btn = QPushButton("Clear All")
        clear_btn.clicked.connect(self._on_clear_breakpoints)
        btn_layout.addWidget(clear_btn)

        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        return widget

    def _apply_style(self) -> None:
        """Apply Win95 tab styling."""
        self.tabs.setStyleSheet(
            """
            QTabWidget::pane {
                border: 2px inset #808080;
                background-color: #C0C0C0;
            }
            QTabBar::tab {
                background-color: #C0C0C0;
                border: 2px outset #FFFFFF;
                border-bottom: none;
                padding: 4px 12px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #C0C0C0;
                border-bottom: 2px solid #C0C0C0;
                margin-bottom: -2px;
            }
            QTabBar::tab:!selected {
                background-color: #808080;
                margin-top: 2px;
            }
        """
        )

    def _update_button_states(self) -> None:
        """Update button enabled states based on debugger state."""
        is_paused = self._debugger.is_paused
        is_running = self._debugger.state.name == "RUNNING"

        self.continue_btn.setEnabled(is_paused)
        self.pause_btn.setEnabled(is_running)
        self.step_over_btn.setEnabled(is_paused)
        self.step_into_btn.setEnabled(is_paused)
        self.step_out_btn.setEnabled(is_paused)
        self.stop_btn.setEnabled(is_paused or is_running)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Public API
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def set_debugger(self, debugger: Debugger) -> None:
        """Set the debugger instance."""
        self._debugger = debugger
        self._update_button_states()

    def update_call_stack(self, frames: list[StackFrame]) -> None:
        """Update the call stack display."""
        self.stack_list.clear()

        for frame in reversed(frames):  # Show top frame first
            text = f"{frame.name} at line {frame.line}"
            item = QListWidgetItem(text)
            item.setData(Qt.ItemDataRole.UserRole, frame.id)
            self.stack_list.addItem(item)

    def update_variables(self, variables: list[Variable]) -> None:
        """Update the variables display."""
        self.variables_tree.clear()

        for var in variables:
            item = QTreeWidgetItem([var.name, str(var.value), var.type])
            if var.expandable:
                item.setChildIndicatorPolicy(QTreeWidgetItem.ChildIndicatorPolicy.ShowIndicator)
            self.variables_tree.addTopLevelItem(item)

    def update_breakpoints(self, breakpoints: list[Breakpoint]) -> None:
        """Update the breakpoints list."""
        self.breakpoints_list.clear()

        for bp in breakpoints:
            text = f"{'‚óè' if bp.enabled else '‚óã'} {bp.file}:{bp.line}"
            if bp.condition:
                text += f" [{bp.condition}]"
            item = QListWidgetItem(text)
            item.setData(Qt.ItemDataRole.UserRole, bp.id)
            if not bp.enabled:
                item.setForeground(QColor("#808080"))
            self.breakpoints_list.addItem(item)

    def on_paused(self, reason: str, line: int) -> None:
        """Called when debugger pauses."""
        self._update_button_states()
        self.update_call_stack(self._debugger.call_stack)
        self.update_variables(self._debugger.get_variables())
        self.update_breakpoints(self._debugger.breakpoints.get_all())

    def on_resumed(self) -> None:
        """Called when debugger resumes."""
        self._update_button_states()

    def on_stopped(self) -> None:
        """Called when debugger stops."""
        self._update_button_states()
        self.stack_list.clear()
        self.variables_tree.clear()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Event Handlers
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _on_continue(self) -> None:
        """Handle continue button."""
        self._debugger.continue_execution()

    def _on_pause(self) -> None:
        """Handle pause button."""
        self._debugger.pause()

    def _on_step_over(self) -> None:
        """Handle step over button."""
        self._debugger.step_over()

    def _on_step_into(self) -> None:
        """Handle step into button."""
        self._debugger.step_into()

    def _on_step_out(self) -> None:
        """Handle step out button."""
        self._debugger.step_out()

    def _on_stop(self) -> None:
        """Handle stop button."""
        self._debugger.stop()

    def _on_stack_item_clicked(self, item: QListWidgetItem) -> None:
        """Handle stack frame selection."""
        frame_id = item.data(Qt.ItemDataRole.UserRole)
        self.frame_selected.emit(frame_id)
        self.update_variables(self._debugger.get_variables(frame_id))

    def _on_add_watch(self) -> None:
        """Handle add watch expression."""
        expr = self.watch_input.text().strip()
        if expr:
            value, error = self._debugger.evaluate(expr)
            if error:
                item = QTreeWidgetItem([expr, f"Error: {error}", ""])
                item.setForeground(1, QColor("#FF0000"))
            else:
                item = QTreeWidgetItem([expr, str(value), type(value).__name__])
            self.variables_tree.addTopLevelItem(item)
            self.watch_input.clear()

    def _on_breakpoint_clicked(self, item: QListWidgetItem) -> None:
        """Handle breakpoint double-click."""
        bp_id = item.data(Qt.ItemDataRole.UserRole)
        bp = self._debugger.breakpoints.get(bp_id)
        if bp:
            self.goto_source.emit(bp.file, bp.line)

    def _on_toggle_breakpoint(self) -> None:
        """Toggle selected breakpoint."""
        item = self.breakpoints_list.currentItem()
        if item:
            bp_id = item.data(Qt.ItemDataRole.UserRole)
            self._debugger.breakpoints.toggle(bp_id)
            self.breakpoint_toggled.emit(bp_id)
            self.update_breakpoints(self._debugger.breakpoints.get_all())

    def _on_remove_breakpoint(self) -> None:
        """Remove selected breakpoint."""
        item = self.breakpoints_list.currentItem()
        if item:
            bp_id = item.data(Qt.ItemDataRole.UserRole)
            self._debugger.breakpoints.remove(bp_id)
            self.breakpoint_removed.emit(bp_id)
            self.update_breakpoints(self._debugger.breakpoints.get_all())

    def _on_clear_breakpoints(self) -> None:
        """Clear all breakpoints."""
        self._debugger.breakpoints.clear()
        self.update_breakpoints([])


================================================================================
FILE PATH: app\ui\engine_worker.py
LINES: 244
================================================================================

"""
RetroAuto v2 - Engine Worker Thread

QThread wrapper for running engine in background.
"""

from pathlib import Path

from PySide6.QtCore import QThread, Signal

from core.engine import ExecutionContext, InterruptManager, Runner
from core.models import Script
from core.script.io import create_empty_script, load_script, save_script
from core.templates import TemplateStore
from vision.matcher import Matcher
from vision.waiter import ImageWaiter
from infra import get_logger

logger = get_logger("EngineWorker")


class EngineWorker(QThread):
    """
    Background thread for engine execution.

    Emits signals for UI updates (thread-safe).
    """

    # Signals for UI updates
    step_started = Signal(str, int, str)  # flow, index, action_type
    step_completed = Signal(str, int, int)  # flow, index, elapsed_ms
    flow_completed = Signal(str, bool)  # flow, success
    state_changed = Signal(str)  # state name
    error_occurred = Signal(str)  # error message
    notification_received = Signal(str, str)  # title, message

    def __init__(self) -> None:
        super().__init__()
        self._ctx: ExecutionContext | None = None
        self._runner: Runner | None = None
        self._interrupt_mgr: InterruptManager | None = None
        self._script: Script | None = None
        self._templates: TemplateStore | None = None
        self._project_path: Path | None = None

    @property
    def is_loaded(self) -> bool:
        """Check if script is loaded."""
        return self._script is not None

    @property
    def script(self) -> Script | None:
        """Get current script."""
        return self._script

    @property
    def context(self) -> ExecutionContext | None:
        """Get execution context."""
        return self._ctx

    def new_script(self, name: str = "Untitled") -> None:
        """Create a new empty script."""
        self._script = create_empty_script(name)
        self._project_path = None
        self._setup_context()
        logger.info("Created new script: %s", name)

    def load_project(self, path: Path) -> None:
        """
        Load script from YAML file.

        Args:
            path: Path to script.yaml
        """
        try:
            self._script = load_script(path)
            self._project_path = path.parent
            self._setup_context()
            logger.info("Loaded project: %s", path)
        except Exception as e:
            logger.exception("Failed to load project: %s", e)
            self.error_occurred.emit(f"Failed to load: {e}")

    def save_project(self, path: Path | None = None) -> bool:
        """
        Save script to YAML file.

        Args:
            path: Target path (None = use current)

        Returns:
            True if saved successfully
        """
        if self._script is None:
            return False

        target = path or (self._project_path / "script.yaml" if self._project_path else None)
        if target is None:
            logger.warning("No save path specified")
            return False

        try:
            save_script(self._script, target)
            self._project_path = target.parent
            return True
        except Exception as e:
            logger.exception("Failed to save: %s", e)
            self.error_occurred.emit(f"Failed to save: {e}")
            return False

    def _setup_context(self) -> None:
        """Set up execution context and runner."""
        if self._script is None:
            return

        self._templates = TemplateStore(self._project_path or Path("."))

        # Preload templates if we have a project path
        if self._project_path and self._script.assets:
            errors = self._templates.preload(self._script.assets)
            if errors:
                logger.warning("Template preload errors: %s", errors)

        self._ctx = ExecutionContext(
            script=self._script,
            templates=self._templates,
        )

        self._runner = Runner(
            self._ctx,
            on_step=self._on_step,
            on_complete=self._on_flow_complete,
            on_notify=self._on_notify_callback,
        )

        self._interrupt_mgr = InterruptManager(self._ctx)
        self._interrupt_mgr.set_runner(self._runner)

    def _on_step(self, flow: str, idx: int, action) -> None:  # type: ignore
        """Callback when step starts."""
        action_type = type(action).__name__
        self.step_started.emit(flow, idx, action_type)

    def _on_flow_complete(self, flow: str, success: bool) -> None:
        """Callback when flow completes."""
        self.flow_completed.emit(flow, success)

    def _on_notify_callback(self, title: str, message: str) -> None:
        """Callback for notifications."""
        self.notification_received.emit(title, message)

    def run(self) -> None:
        """Execute the main flow (called by QThread.start)."""
        if not self._runner or not self._script:
            self.error_occurred.emit("No script loaded")
            return

        try:
            # Debug: log what assets we have
            logger.info("Script assets count: %d", len(self._script.assets) if self._script.assets else 0)
            if self._script.assets:
                asset_ids = [a.id for a in self._script.assets]
                logger.info("Available asset IDs: %s", asset_ids)

            # Ensure templates store exists
            if self._templates is None:
                logger.warning("TemplateStore was None, creating new one")
                self._templates = TemplateStore(self._project_path or Path("."))
                # Also need to update context's matcher
                if self._ctx:
                    self._ctx.templates = self._templates
                    self._ctx.matcher = Matcher(self._templates, self._ctx.capture)
                    self._ctx.waiter = ImageWaiter(self._ctx.matcher)

            # Refresh templates before run to pick up newly added assets
            if self._script.assets:
                logger.info("Calling preload with %d assets...", len(self._script.assets))
                errors = self._templates.preload(self._script.assets)
                if errors:
                    logger.warning("Template preload errors: %s", errors)
                else:
                    logger.info("‚úÖ Preloaded %d assets successfully", len(self._script.assets))

            # Start interrupt watching
            if self._interrupt_mgr:
                self._interrupt_mgr.start_watching()

            self.state_changed.emit("running")

            # Run main flow
            success = self._runner.run_flow(self._script.main_flow)

            self.state_changed.emit("idle")

            if success:
                logger.info("Script completed successfully")
            else:
                logger.warning("Script stopped or failed")
        except Exception as e:
            logger.exception("Engine error: %s", e)
            self.error_occurred.emit(str(e))
            self.state_changed.emit("error")
        finally:
            if self._interrupt_mgr:
                self._interrupt_mgr.stop_watching()

    def start_from(self, flow: str, step: int) -> None:
        """Start execution from specific step."""
        if not self._runner:
            return
        # Override run to use specific starting point
        self._run_flow = flow
        self._run_step = step
        self.start()

    def pause(self) -> None:
        """Request pause."""
        if self._ctx:
            self._ctx.request_pause()
            self.state_changed.emit("paused")

    def resume(self) -> None:
        """Resume from pause."""
        if self._ctx:
            self._ctx.request_resume()
            self.state_changed.emit("running")

    def stop(self) -> None:
        """Request stop."""
        if self._ctx:
            self._ctx.request_stop()
            self.state_changed.emit("stopping")

    def run_single_step(self, flow: str, step: int) -> bool:
        """Execute single step (blocking)."""
        if not self._runner:
            return False
        return self._runner.run_step(flow, step)

    def get_state(self) -> str:
        """Get current engine state."""
        if self._ctx:
            return self._ctx.state.value
        return "idle"


================================================================================
FILE PATH: app\ui\flow_converter.py
LINES: 361
================================================================================

"""
RetroAuto v2 - Flow Graph Converter

Converts between Actions list and Visual Graph representation.
Enables bidirectional sync between ActionsPanel and FlowEditor.
"""

from __future__ import annotations

from typing import TYPE_CHECKING

from core.models import (
    Action,
    Click,
    ClickImage,
    ClickRandom,
    ClickUntil,
    Delay,
    DelayRandom,
    Else,
    EndIf,
    EndLoop,
    EndWhile,
    Goto,
    Hotkey,
    IfImage,
    IfPixel,
    IfText,
    Label,
    Loop,
    Notify,
    ReadText,
    RunFlow,
    Scroll,
    TypeText,
    WaitImage,
    WaitPixel,
    WhileImage,
)
from infra import get_logger

if TYPE_CHECKING:
    from app.ui.flow_editor import ConnectionData, NodeData

logger = get_logger("FlowConverter")


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Action to Node Type Mapping
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

ACTION_TO_NODE_TYPE = {
    "Click": "Click",
    "ClickImage": "Click",
    "ClickRandom": "Click",
    "ClickUntil": "Click",
    "WaitImage": "Wait",
    "WaitPixel": "Wait",
    "Delay": "Wait",
    "DelayRandom": "Wait",
    "IfImage": "If",
    "IfPixel": "If",
    "IfText": "If",
    "Loop": "Loop",
    "WhileImage": "Loop",
    "Hotkey": "Default",
    "TypeText": "Default",
    "ReadText": "Default",
    "RunFlow": "Default",
    "Goto": "Default",
    "Label": "Default",
    "Notify": "Default",
    "Scroll": "Default",
    "Else": "Default",
    "EndIf": "End",
    "EndLoop": "End",
    "EndWhile": "End",
}

ACTION_ICONS = {
    "Click": "üñ±Ô∏è",
    "ClickImage": "üéØ",
    "ClickRandom": "üé≤",
    "ClickUntil": "üîÑ",
    "WaitImage": "üëÅÔ∏è",
    "WaitPixel": "‚è≥",
    "Delay": "‚è±Ô∏è",
    "DelayRandom": "‚è≥",
    "IfImage": "‚ùì",
    "IfPixel": "‚ùì",
    "IfText": "‚ùì",
    "Loop": "üîÅ",
    "WhileImage": "üîÑ",
    "EndIf": "üìç",
    "EndLoop": "üìç",
    "EndWhile": "üìç",
    "Hotkey": "‚å®Ô∏è",
    "TypeText": "üìù",
    "ReadText": "üìñ",
    "RunFlow": "‚ñ∂Ô∏è",
    "Goto": "‚ÜóÔ∏è",
    "Label": "üè∑Ô∏è",
    "Notify": "üîî",
    "Scroll": "üìú",
    "Else": "üîÄ",
}


class FlowConverter:
    """
    Converts between Actions list and Visual Graph.

    Actions ‚Üí Graph: Creates nodes with auto-layout
    Graph ‚Üí Actions: Traverses connection graph to create linear list
    """

    NODE_WIDTH = 160
    NODE_HEIGHT = 80
    H_SPACING = 80  # Horizontal spacing
    V_SPACING = 40  # Vertical spacing

    def __init__(self) -> None:
        self._node_counter = 0

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Actions ‚Üí Graph
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def actions_to_graph(
        self, actions: list[Action]
    ) -> tuple[list[NodeData], list[ConnectionData]]:
        """
        Convert a list of actions to visual graph nodes.

        Returns:
            Tuple of (nodes, connections)
        """
        from app.ui.flow_editor import ConnectionData, NodeData, Pin

        nodes: list[NodeData] = []
        connections: list[ConnectionData] = []

        if not actions:
            return nodes, connections

        # Add Start node
        start_node = NodeData(
            id="start",
            node_type="Start",
            title="üöÄ Start",
            x=50,
            y=100,
            outputs=[Pin("Exec", "exec_out", "exec")],
        )
        nodes.append(start_node)

        # Convert each action to a node
        x_pos = 50 + self.NODE_WIDTH + self.H_SPACING
        y_pos = 100
        prev_node_id = "start"

        for i, action in enumerate(actions):
            action_type = type(action).__name__
            node_type = ACTION_TO_NODE_TYPE.get(action_type, "Default")
            icon = ACTION_ICONS.get(action_type, "üì¶")

            # Create node
            node = NodeData(
                id=f"action_{i}",
                node_type=node_type,
                title=f"{icon} {action_type}",
                x=x_pos,
                y=y_pos,
                inputs=[Pin("Exec", "exec_in", "exec")],
                outputs=[Pin("Done", "exec_out", "exec")],
                properties=self._action_to_properties(action),
            )

            # Add data pins based on action type
            self._add_action_pins(node, action)

            nodes.append(node)

            # Create connection from previous node
            connections.append(
                ConnectionData(
                    from_node=prev_node_id,
                    from_pin="Exec" if prev_node_id == "start" else "Done",
                    to_node=node.id,
                    to_pin="Exec",
                )
            )

            prev_node_id = node.id

            # Auto-layout: wrap after every 4 nodes
            if (i + 1) % 4 == 0:
                x_pos = 50 + self.NODE_WIDTH + self.H_SPACING
                y_pos += self.NODE_HEIGHT + self.V_SPACING
            else:
                x_pos += self.NODE_WIDTH + self.H_SPACING

        # Add End node
        end_node = NodeData(
            id="end",
            node_type="End",
            title="üèÅ End",
            x=x_pos,
            y=y_pos,
            inputs=[Pin("Exec", "exec_in", "exec")],
        )
        nodes.append(end_node)

        # Connect last action to End
        connections.append(
            ConnectionData(from_node=prev_node_id, from_pin="Done", to_node="end", to_pin="Exec")
        )

        logger.info(f"Converted {len(actions)} actions to {len(nodes)} nodes")
        return nodes, connections

    def _action_to_properties(self, action: Action) -> dict:
        """Extract action properties as dict."""
        try:
            return action.model_dump(exclude={"action"})
        except Exception:
            return {}

    def _add_action_pins(self, node: NodeData, action: Action) -> None:
        """Add data pins based on action type."""
        from app.ui.flow_editor import Pin

        action_type = type(action).__name__

        if action_type in ("ClickImage", "WaitImage", "IfImage"):
            node.inputs.append(Pin("Asset", "data_in", "asset"))

        if action_type in ("IfImage", "IfPixel", "IfText"):
            # Replace single output with True/False
            node.outputs = [
                Pin("True", "exec_out", "exec"),
                Pin("False", "exec_out", "exec"),
            ]

        if action_type == "Loop":
            node.inputs.append(Pin("Count", "data_in", "int"))

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Graph ‚Üí Actions
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def graph_to_actions(
        self, nodes: list[NodeData], connections: list[ConnectionData]
    ) -> list[Action]:
        """
        Convert visual graph back to actions list.

        Traverses the graph starting from 'start' node following connections.
        """
        if not nodes:
            return []

        # Build connection map: node_id -> next_node_id
        conn_map: dict[str, str] = {}
        for conn in connections:
            key = f"{conn.from_node}:{conn.from_pin}"
            conn_map[key] = conn.to_node

        # Build node map
        node_map = {node.id: node for node in nodes}

        actions: list[Action] = []

        # Start from 'start' node or first node
        current_id = "start"
        if current_id not in node_map:
            current_id = nodes[0].id if nodes else None

        visited = set()

        while current_id and current_id not in visited:
            visited.add(current_id)

            node = node_map.get(current_id)
            if not node:
                break

            # Skip Start/End nodes
            if node.node_type not in ("Start", "End"):
                action = self._node_to_action(node)
                if action:
                    actions.append(action)

            # Find next node
            next_id = None
            for pin in node.outputs:
                key = f"{current_id}:{pin.name}"
                if key in conn_map:
                    next_id = conn_map[key]
                    break

            current_id = next_id

        logger.info(f"Converted {len(nodes)} nodes to {len(actions)} actions")
        return actions

    def _node_to_action(self, node: NodeData) -> Action | None:
        """Convert a single node back to an action."""
        props = node.properties or {}

        # Extract action type from title (remove icon)
        title_parts = node.title.split(" ", 1)
        action_type = title_parts[1] if len(title_parts) > 1 else node.node_type

        # Map back to action classes
        action_classes = {
            "Click": Click,
            "ClickImage": ClickImage,
            "ClickRandom": ClickRandom,
            "ClickUntil": ClickUntil,
            "WaitImage": WaitImage,
            "WaitPixel": WaitPixel,
            "Delay": Delay,
            "DelayRandom": DelayRandom,
            "IfImage": IfImage,
            "IfPixel": IfPixel,
            "IfText": IfText,
            "Loop": Loop,
            "WhileImage": WhileImage,
            "Hotkey": Hotkey,
            "TypeText": TypeText,
            "ReadText": ReadText,
            "RunFlow": RunFlow,
            "Goto": Goto,
            "Label": Label,
            "Notify": Notify,
            "Scroll": Scroll,
            "Else": Else,
            "EndIf": EndIf,
            "EndLoop": EndLoop,
            "EndWhile": EndWhile,
        }

        action_class = action_classes.get(action_type)
        if not action_class:
            logger.warning(f"Unknown action type: {action_type}")
            return None

        try:
            return action_class(**props)
        except Exception as e:
            logger.warning(f"Failed to create {action_type}: {e}")
            # Try with defaults
            try:
                return action_class()
            except Exception:
                return None


# Global converter instance
flow_converter = FlowConverter()


================================================================================
FILE PATH: app\ui\flow_editor.py
LINES: 825
================================================================================

"""
RetroAuto v2 - Visual Flow Editor

Node-based visual scripting editor using Qt Graphics Framework.
Inspired by Unreal Blueprints and node-based editors.
"""

from __future__ import annotations

import uuid
from dataclasses import dataclass, field
from typing import Any

from PySide6.QtCore import QPointF, QRectF, Qt, Signal
from PySide6.QtGui import (
    QBrush,
    QColor,
    QFont,
    QPainter,
    QPainterPath,
    QPen,
    QWheelEvent,
)
from PySide6.QtWidgets import (
    QGraphicsItem,
    QGraphicsPathItem,
    QGraphicsScene,
    QGraphicsView,
    QStyleOptionGraphicsItem,
    QWidget,
)

from infra import get_logger

logger = get_logger("FlowEditor")


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Data Models
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


@dataclass
class Pin:
    """A connection point on a node."""

    name: str
    pin_type: str  # "exec_in", "exec_out", "data_in", "data_out"
    data_type: str = "any"  # "exec", "bool", "string", "asset", etc.
    value: Any = None


@dataclass
class NodeData:
    """Data model for a visual node."""

    id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    node_type: str = "Action"
    title: str = "Node"
    x: float = 0.0
    y: float = 0.0
    inputs: list[Pin] = field(default_factory=list)
    outputs: list[Pin] = field(default_factory=list)
    properties: dict = field(default_factory=dict)


@dataclass
class ConnectionData:
    """Data model for a wire connection."""

    id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    from_node: str = ""
    from_pin: str = ""
    to_node: str = ""
    to_pin: str = ""


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Node Colors by Category
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

NODE_COLORS = {
    "Start": "#4CAF50",  # Green
    "Click": "#2196F3",  # Blue
    "Wait": "#03A9F4",  # Light Blue
    "If": "#FF9800",  # Orange
    "Loop": "#9C27B0",  # Purple
    "End": "#F44336",  # Red
    "Default": "#607D8B",  # Gray
}


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Socket (Pin) Item
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class SocketItem(QGraphicsItem):
    """A connection socket/pin on a node."""

    RADIUS = 6

    def __init__(self, pin: Pin, is_output: bool, parent: NodeItem) -> None:
        super().__init__(parent)
        self.pin = pin
        self.is_output = is_output
        self.setAcceptHoverEvents(True)
        self._hovered = False

        # Color based on pin type
        if pin.pin_type.startswith("exec"):
            self._color = QColor("#FFFFFF")
        else:
            self._color = QColor("#00BFFF")

    def boundingRect(self) -> QRectF:
        return QRectF(
            -self.RADIUS - 2, -self.RADIUS - 2, (self.RADIUS + 2) * 2, (self.RADIUS + 2) * 2
        )

    def paint(
        self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: QWidget | None = None
    ) -> None:
        # Draw socket
        if self.pin.pin_type.startswith("exec"):
            # Triangle for exec
            path = QPainterPath()
            if self.is_output:
                path.moveTo(-self.RADIUS, -self.RADIUS)
                path.lineTo(self.RADIUS, 0)
                path.lineTo(-self.RADIUS, self.RADIUS)
            else:
                path.moveTo(self.RADIUS, -self.RADIUS)
                path.lineTo(-self.RADIUS, 0)
                path.lineTo(self.RADIUS, self.RADIUS)
            path.closeSubpath()

            painter.setPen(QPen(Qt.GlobalColor.white, 1))
            painter.setBrush(QBrush(self._color if self._hovered else QColor("#808080")))
            painter.drawPath(path)
        else:
            # Circle for data
            painter.setPen(QPen(Qt.GlobalColor.white, 1))
            painter.setBrush(QBrush(self._color if self._hovered else QColor("#404040")))
            painter.drawEllipse(QPointF(0, 0), self.RADIUS, self.RADIUS)

        # Draw label
        font = QFont("Arial", 8)
        painter.setFont(font)
        painter.setPen(Qt.GlobalColor.white)

        if self.is_output:
            painter.drawText(
                QRectF(-80, -10, 70, 20),
                Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter,
                self.pin.name,
            )
        else:
            painter.drawText(
                QRectF(12, -10, 70, 20),
                Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter,
                self.pin.name,
            )

    def hoverEnterEvent(self, event) -> None:
        self._hovered = True
        self.update()

    def hoverLeaveEvent(self, event) -> None:
        self._hovered = False
        self.update()

    def get_center_scene_pos(self) -> QPointF:
        """Get socket center in scene coordinates."""
        return self.scenePos()

    def mousePressEvent(self, event) -> None:
        """Start dragging a connection from this socket."""
        if event.button() == Qt.MouseButton.LeftButton and self.is_output:
            scene = self.scene()
            if scene and hasattr(scene, "start_connection"):
                scene.start_connection(self)
            event.accept()
        else:
            super().mousePressEvent(event)

    def mouseReleaseEvent(self, event) -> None:
        """End dragging a connection."""
        if event.button() == Qt.MouseButton.LeftButton:
            scene = self.scene()
            if scene and hasattr(scene, "end_connection"):
                scene.end_connection(self)
            event.accept()
        else:
            super().mouseReleaseEvent(event)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Node Item
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class NodeItem(QGraphicsItem):
    """A visual node in the flow editor."""

    WIDTH = 160
    HEADER_HEIGHT = 28
    PIN_SPACING = 24
    CORNER_RADIUS = 8

    def __init__(self, data: NodeData, parent=None) -> None:
        super().__init__(parent)
        self.data = data
        self.input_sockets: list[SocketItem] = []
        self.output_sockets: list[SocketItem] = []

        # Flags
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges)
        self.setAcceptHoverEvents(True)

        # Set position
        self.setPos(data.x, data.y)

        # Calculate height
        max_pins = max(len(data.inputs), len(data.outputs), 1)
        self._height = self.HEADER_HEIGHT + max_pins * self.PIN_SPACING + 8

        # Get color
        category = data.node_type.split("_")[0] if "_" in data.node_type else data.node_type
        self._header_color = QColor(NODE_COLORS.get(category, NODE_COLORS["Default"]))

        # Create sockets
        self._create_sockets()

    def _create_sockets(self) -> None:
        """Create socket items for inputs and outputs."""
        # Input sockets (left side)
        for i, pin in enumerate(self.data.inputs):
            socket = SocketItem(pin, is_output=False, parent=self)
            socket.setPos(0, self.HEADER_HEIGHT + 12 + i * self.PIN_SPACING)
            self.input_sockets.append(socket)

        # Output sockets (right side)
        for i, pin in enumerate(self.data.outputs):
            socket = SocketItem(pin, is_output=True, parent=self)
            socket.setPos(self.WIDTH, self.HEADER_HEIGHT + 12 + i * self.PIN_SPACING)
            self.output_sockets.append(socket)

    def boundingRect(self) -> QRectF:
        return QRectF(-2, -2, self.WIDTH + 4, self._height + 4)

    def paint(
        self, painter: QPainter, option: QStyleOptionGraphicsItem, widget: QWidget | None = None
    ) -> None:
        # Body
        body_rect = QRectF(0, 0, self.WIDTH, self._height)

        # Shadow
        shadow_rect = body_rect.translated(3, 3)
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QColor(0, 0, 0, 80))
        painter.drawRoundedRect(shadow_rect, self.CORNER_RADIUS, self.CORNER_RADIUS)

        # Main body
        painter.setBrush(QColor("#2d2d2d"))
        if self.isSelected():
            painter.setPen(QPen(QColor("#00aaff"), 2))
        else:
            painter.setPen(QPen(QColor("#555555"), 1))
        painter.drawRoundedRect(body_rect, self.CORNER_RADIUS, self.CORNER_RADIUS)

        # Header
        header_rect = QRectF(0, 0, self.WIDTH, self.HEADER_HEIGHT)
        path = QPainterPath()
        path.addRoundedRect(header_rect, self.CORNER_RADIUS, self.CORNER_RADIUS)
        # Clip bottom corners
        path.addRect(
            QRectF(0, self.HEADER_HEIGHT - self.CORNER_RADIUS, self.WIDTH, self.CORNER_RADIUS)
        )

        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(self._header_color)
        painter.drawPath(path.simplified())

        # Title
        font = QFont("Arial", 10, QFont.Weight.Bold)
        painter.setFont(font)
        painter.setPen(Qt.GlobalColor.white)
        painter.drawText(
            header_rect.adjusted(8, 0, -8, 0),
            Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft,
            self.data.title,
        )

    def itemChange(self, change, value):
        """Track position changes."""
        if change == QGraphicsItem.GraphicsItemChange.ItemPositionHasChanged:
            # Update data
            pos = self.pos()
            self.data.x = pos.x()
            self.data.y = pos.y()
            # Notify connections to update
            scene = self.scene()
            if scene and hasattr(scene, "update_connections"):
                scene.update_connections(self)
        return super().itemChange(change, value)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Connection Item (Wire)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class ConnectionItem(QGraphicsPathItem):
    """A wire connecting two sockets."""

    def __init__(
        self,
        data: ConnectionData,
        start_socket: SocketItem | None = None,
        end_socket: SocketItem | None = None,
        parent=None,
    ) -> None:
        super().__init__(parent)
        self.data = data
        self.start_socket = start_socket
        self.end_socket = end_socket

        # Styling
        self._pen = QPen(QColor("#cccccc"), 2)
        self._pen.setCapStyle(Qt.PenCapStyle.RoundCap)
        self.setPen(self._pen)

        self.setZValue(-1)  # Behind nodes
        self.update_path()

    def update_path(self) -> None:
        """Update the bezier curve path."""
        if not self.start_socket or not self.end_socket:
            return

        start = self.start_socket.get_center_scene_pos()
        end = self.end_socket.get_center_scene_pos()

        # Bezier control points
        dx = abs(end.x() - start.x()) * 0.5

        path = QPainterPath(start)
        path.cubicTo(QPointF(start.x() + dx, start.y()), QPointF(end.x() - dx, end.y()), end)

        self.setPath(path)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Flow Scene
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class FlowScene(QGraphicsScene):
    """Scene containing the node graph."""

    node_selected = Signal(NodeData)
    node_added = Signal(NodeData)
    connection_made = Signal(ConnectionData)

    GRID_SIZE = 20
    GRID_COLOR_SMALL = QColor("#353535")
    GRID_COLOR_LARGE = QColor("#454545")

    def __init__(self, parent=None) -> None:
        super().__init__(parent)
        self.nodes: dict[str, NodeItem] = {}
        self.connections: list[ConnectionItem] = []

        # Large scene rect
        self.setSceneRect(-5000, -5000, 10000, 10000)
        self.setBackgroundBrush(QColor("#1e1e1e"))

    def drawBackground(self, painter: QPainter, rect: QRectF) -> None:
        """Draw grid background."""
        super().drawBackground(painter, rect)

        left = int(rect.left()) - (int(rect.left()) % self.GRID_SIZE)
        top = int(rect.top()) - (int(rect.top()) % self.GRID_SIZE)

        # Small grid
        lines_small = []
        x = left
        while x < rect.right():
            if x % (self.GRID_SIZE * 5) != 0:
                lines_small.append((x, rect.top(), x, rect.bottom()))
            x += self.GRID_SIZE

        y = top
        while y < rect.bottom():
            if y % (self.GRID_SIZE * 5) != 0:
                lines_small.append((rect.left(), y, rect.right(), y))
            y += self.GRID_SIZE

        painter.setPen(QPen(self.GRID_COLOR_SMALL, 0.5))
        for line in lines_small:
            painter.drawLine(int(line[0]), int(line[1]), int(line[2]), int(line[3]))

        # Large grid
        lines_large = []
        x = left
        while x < rect.right():
            if x % (self.GRID_SIZE * 5) == 0:
                lines_large.append((x, rect.top(), x, rect.bottom()))
            x += self.GRID_SIZE

        y = top
        while y < rect.bottom():
            if y % (self.GRID_SIZE * 5) == 0:
                lines_large.append((rect.left(), y, rect.right(), y))
            y += self.GRID_SIZE

        painter.setPen(QPen(self.GRID_COLOR_LARGE, 1))
        for line in lines_large:
            painter.drawLine(int(line[0]), int(line[1]), int(line[2]), int(line[3]))

    def add_node(self, data: NodeData) -> NodeItem:
        """Add a node to the scene."""
        node = NodeItem(data)
        self.addItem(node)
        self.nodes[data.id] = node
        logger.info(f"Added node: {data.title} ({data.id})")
        return node

    def remove_node(self, node_id: str) -> None:
        """Remove a node from the scene."""
        if node_id in self.nodes:
            node = self.nodes.pop(node_id)
            self.removeItem(node)

    def update_connections(self, node: NodeItem) -> None:
        """Update all connections involving this node."""
        for conn in self.connections:
            if conn.start_socket and conn.start_socket.parentItem() == node:
                conn.update_path()
            if conn.end_socket and conn.end_socket.parentItem() == node:
                conn.update_path()

    def start_connection(self, socket: SocketItem) -> None:
        """Start dragging a new connection from a socket."""
        self._dragging_connection = True
        self._drag_start_socket = socket

        # Create temporary connection for preview
        self._temp_connection = ConnectionItem(
            ConnectionData(), start_socket=socket, end_socket=None
        )
        self.addItem(self._temp_connection)
        logger.info(f"Started connection from {socket.pin.name}")

    def end_connection(self, socket: SocketItem) -> None:
        """Complete connection to a socket."""
        if not hasattr(self, "_dragging_connection") or not self._dragging_connection:
            return

        self._dragging_connection = False

        # Remove temp connection
        if hasattr(self, "_temp_connection") and self._temp_connection:
            self.removeItem(self._temp_connection)
            self._temp_connection = None

        # Validate connection
        start_socket = self._drag_start_socket
        if not start_socket or socket == start_socket:
            return

        # Check compatible: output -> input
        if start_socket.is_output and not socket.is_output:
            self.add_connection(start_socket, socket)
        elif not start_socket.is_output and socket.is_output:
            self.add_connection(socket, start_socket)

    def add_connection(
        self, from_socket: SocketItem, to_socket: SocketItem
    ) -> ConnectionItem | None:
        """Create a connection between two sockets."""
        # Get parent nodes
        from_node = from_socket.parentItem()
        to_node = to_socket.parentItem()

        if not isinstance(from_node, NodeItem) or not isinstance(to_node, NodeItem):
            return None

        # Create connection data
        data = ConnectionData(
            from_node=from_node.data.id,
            from_pin=from_socket.pin.name,
            to_node=to_node.data.id,
            to_pin=to_socket.pin.name,
        )

        # Create connection item
        conn = ConnectionItem(data, from_socket, to_socket)
        self.addItem(conn)
        self.connections.append(conn)

        logger.info(
            f"Connected {from_node.data.title}.{from_socket.pin.name} -> {to_node.data.title}.{to_socket.pin.name}"
        )
        return conn

    def cancel_connection(self) -> None:
        """Cancel the in-progress connection drag."""
        if hasattr(self, "_temp_connection") and self._temp_connection:
            self.removeItem(self._temp_connection)
            self._temp_connection = None
        self._dragging_connection = False


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Flow View
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class FlowView(QGraphicsView):
    """View widget for the flow editor with pan and zoom."""

    def __init__(self, scene: FlowScene, parent=None) -> None:
        super().__init__(scene, parent)
        self.flow_scene = scene

        # Settings
        self.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.setRenderHint(QPainter.RenderHint.TextAntialiasing)
        self.setViewportUpdateMode(QGraphicsView.ViewportUpdateMode.FullViewportUpdate)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setTransformationAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)
        self.setDragMode(QGraphicsView.DragMode.RubberBandDrag)

        # Zoom
        self._zoom = 1.0
        self._min_zoom = 0.1
        self._max_zoom = 3.0

        # Pan
        self._panning = False
        self._pan_start = QPointF()

        # Style
        self.setStyleSheet(
            """
            QGraphicsView {
                border: 1px solid #3c3c3c;
                background-color: #1e1e1e;
            }
        """
        )

    def wheelEvent(self, event: QWheelEvent) -> None:
        """Zoom with mouse wheel."""
        factor = 1.1 if event.angleDelta().y() > 0 else 0.9
        new_zoom = self._zoom * factor

        if self._min_zoom <= new_zoom <= self._max_zoom:
            self._zoom = new_zoom
            self.scale(factor, factor)

    def mousePressEvent(self, event) -> None:
        """Handle pan start."""
        if event.button() == Qt.MouseButton.MiddleButton:
            self._panning = True
            self._pan_start = event.position()
            self.setCursor(Qt.CursorShape.ClosedHandCursor)
        else:
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event) -> None:
        """Handle panning."""
        if self._panning:
            delta = self._pan_start - event.position()
            self._pan_start = event.position()
            self.horizontalScrollBar().setValue(int(self.horizontalScrollBar().value() + delta.x()))
            self.verticalScrollBar().setValue(int(self.verticalScrollBar().value() + delta.y()))
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event) -> None:
        """Handle pan end."""
        if event.button() == Qt.MouseButton.MiddleButton:
            self._panning = False
            self.setCursor(Qt.CursorShape.ArrowCursor)
        else:
            super().mouseReleaseEvent(event)

    def fit_in_view_all(self) -> None:
        """Fit all nodes in view."""
        items_rect = self.scene().itemsBoundingRect()
        if not items_rect.isEmpty():
            self.fitInView(
                items_rect.adjusted(-50, -50, 50, 50), Qt.AspectRatioMode.KeepAspectRatio
            )


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Flow Editor Widget (Main Panel)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class FlowEditorWidget(QWidget):
    """Main widget containing the flow editor."""

    # Signal to export actions
    actions_exported = Signal(list)  # list[Action]

    def __init__(self, parent=None, actions: list = None) -> None:
        super().__init__(parent)
        from PySide6.QtWidgets import QHBoxLayout, QLabel, QPushButton, QVBoxLayout

        self._initial_actions = actions or []

        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Toolbar
        toolbar = QHBoxLayout()
        toolbar.setContentsMargins(4, 4, 4, 4)

        add_btn = QPushButton("+ Add Node")
        add_btn.clicked.connect(self._on_add_node)
        toolbar.addWidget(add_btn)

        fit_btn = QPushButton("üìê Fit All")
        fit_btn.clicked.connect(self._on_fit_all)
        toolbar.addWidget(fit_btn)

        toolbar.addWidget(QLabel(" | "))

        import_btn = QPushButton("üì• Import Actions")
        import_btn.clicked.connect(self._on_import_actions)
        toolbar.addWidget(import_btn)

        export_btn = QPushButton("üì§ Export Actions")
        export_btn.clicked.connect(self._on_export_actions)
        toolbar.addWidget(export_btn)

        toolbar.addStretch()

        zoom_label = QLabel("üîç Zoom: 100%")
        self._zoom_label = zoom_label
        toolbar.addWidget(zoom_label)

        layout.addLayout(toolbar)

        # Flow editor
        self.scene = FlowScene()
        self.view = FlowView(self.scene)
        layout.addWidget(self.view)

        # Load initial actions or demo
        if self._initial_actions:
            self.import_actions(self._initial_actions)
        else:
            self._add_demo_nodes()

    def _add_demo_nodes(self) -> None:
        """Add demo nodes to show the editor."""
        # Start node
        start = NodeData(
            node_type="Start",
            title="üöÄ Start",
            x=100,
            y=100,
            outputs=[Pin("Exec", "exec_out", "exec")],
        )
        self.scene.add_node(start)

        # Click node
        click = NodeData(
            node_type="Click",
            title="üéØ Click Image",
            x=350,
            y=100,
            inputs=[
                Pin("Exec", "exec_in", "exec"),
                Pin("Asset", "data_in", "asset"),
            ],
            outputs=[
                Pin("Done", "exec_out", "exec"),
                Pin("Found", "data_out", "bool"),
            ],
        )
        self.scene.add_node(click)

        # If node
        if_node = NodeData(
            node_type="If",
            title="‚ùì If Found",
            x=600,
            y=100,
            inputs=[
                Pin("Exec", "exec_in", "exec"),
                Pin("Condition", "data_in", "bool"),
            ],
            outputs=[
                Pin("True", "exec_out", "exec"),
                Pin("False", "exec_out", "exec"),
            ],
        )
        self.scene.add_node(if_node)

    def _on_add_node(self) -> None:
        """Add a new node at center."""
        center = self.view.mapToScene(self.view.viewport().rect().center())
        node = NodeData(
            node_type="Default",
            title="New Node",
            x=center.x(),
            y=center.y(),
            inputs=[Pin("In", "exec_in", "exec")],
            outputs=[Pin("Out", "exec_out", "exec")],
        )
        self.scene.add_node(node)

    def _on_fit_all(self) -> None:
        """Fit all nodes in view."""
        self.view.fit_in_view_all()

    def _on_import_actions(self) -> None:
        """Import actions from MainWindow's actions panel."""
        from PySide6.QtWidgets import QMessageBox

        QMessageBox.information(
            self,
            "Import Actions",
            "Use import_actions(actions_list) method to import actions programmatically.\n\n"
            "Or connect this Flow Editor to the main window to sync with ActionsPanel.",
        )

    def _on_export_actions(self) -> None:
        """Export graph back to actions."""
        actions = self.export_actions()
        self.actions_exported.emit(actions)

        from PySide6.QtWidgets import QMessageBox

        QMessageBox.information(
            self,
            "Export Actions",
            f"Exported {len(actions)} actions.\n\n"
            "Connect to actions_exported signal to receive the actions list.",
        )

    def import_actions(self, actions: list) -> None:
        """
        Import actions into the flow editor.

        Clears current graph and creates nodes from actions.
        """
        from app.ui.flow_converter import flow_converter

        # Clear current scene
        for node_id in list(self.scene.nodes.keys()):
            self.scene.remove_node(node_id)
        for conn in list(self.scene.connections):
            self.scene.removeItem(conn)
        self.scene.connections.clear()

        # Convert actions to graph
        nodes, connections = flow_converter.actions_to_graph(actions)

        # Add nodes
        for node_data in nodes:
            self.scene.add_node(node_data)

        # Add connections
        for conn_data in connections:
            from_node = self.scene.nodes.get(conn_data.from_node)
            to_node = self.scene.nodes.get(conn_data.to_node)

            if from_node and to_node:
                # Find matching sockets
                from_socket = None
                for sock in from_node.output_sockets:
                    if sock.pin.name == conn_data.from_pin:
                        from_socket = sock
                        break
                # Fallback to first output
                if not from_socket and from_node.output_sockets:
                    from_socket = from_node.output_sockets[0]

                to_socket = None
                for sock in to_node.input_sockets:
                    if sock.pin.name == conn_data.to_pin:
                        to_socket = sock
                        break
                # Fallback to first input
                if not to_socket and to_node.input_sockets:
                    to_socket = to_node.input_sockets[0]

                if from_socket and to_socket:
                    self.scene.add_connection(from_socket, to_socket)

        # Fit view
        self.view.fit_in_view_all()
        logger.info(f"Imported {len(actions)} actions as {len(nodes)} nodes")

    def export_actions(self) -> list:
        """
        Export the current graph back to an actions list.

        Returns:
            List of Action objects
        """
        from app.ui.flow_converter import flow_converter

        # Collect node data
        nodes = [node.data for node in self.scene.nodes.values()]

        # Collect connection data
        connections = [conn.data for conn in self.scene.connections]

        # Convert to actions
        actions = flow_converter.graph_to_actions(nodes, connections)
        logger.info(f"Exported {len(nodes)} nodes as {len(actions)} actions")
        return actions


================================================================================
FILE PATH: app\ui\flow_visualizer.py
LINES: 362
================================================================================

"""
RetroAuto v2 - Flow Visualizer

Visual diagram display for RetroScript flows.
Part of RetroScript Phase 14 - Visual Editor Components.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any

from PySide6.QtCore import QPointF, Signal
from PySide6.QtGui import (
    QBrush,
    QColor,
    QFont,
    QPainter,
    QPainterPath,
    QPen,
)
from PySide6.QtWidgets import (
    QGraphicsItem,
    QGraphicsPathItem,
    QGraphicsRectItem,
    QGraphicsScene,
    QGraphicsSimpleTextItem,
    QGraphicsView,
    QVBoxLayout,
    QWidget,
)


@dataclass
class FlowNode:
    """A node in the flow diagram."""

    id: str
    label: str
    node_type: str = "default"  # default, start, end, condition, action
    x: float = 0
    y: float = 0
    width: float = 120
    height: float = 40
    data: dict[str, Any] = field(default_factory=dict)


@dataclass
class FlowConnection:
    """A connection between nodes."""

    from_node: str
    to_node: str
    label: str = ""
    connection_type: str = "default"  # default, true, false


class NodeItem(QGraphicsRectItem):
    """Visual representation of a flow node."""

    def __init__(self, node: FlowNode, parent: QGraphicsItem | None = None) -> None:
        super().__init__(parent)
        self.node = node

        # Setup rect
        self.setRect(0, 0, node.width, node.height)
        self.setPos(node.x, node.y)

        # Make interactive
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable)
        self.setAcceptHoverEvents(True)

        # Style based on type
        self._setup_style()

        # Add label
        self._label = QGraphicsSimpleTextItem(node.label, self)
        self._label.setFont(QFont("Segoe UI", 10))
        self._center_label()

    def _setup_style(self) -> None:
        """Setup visual style based on node type."""
        colors = {
            "default": ("#2d3748", "#4a5568"),
            "start": ("#22543d", "#38a169"),
            "end": ("#742a2a", "#e53e3e"),
            "condition": ("#744210", "#dd6b20"),
            "action": ("#2c5282", "#4299e1"),
            "loop": ("#553c9a", "#805ad5"),
        }

        fill, border = colors.get(self.node.node_type, colors["default"])

        self.setBrush(QBrush(QColor(fill)))
        self.setPen(QPen(QColor(border), 2))

    def _center_label(self) -> None:
        """Center the label in the node."""
        rect = self._label.boundingRect()
        x = (self.node.width - rect.width()) / 2
        y = (self.node.height - rect.height()) / 2
        self._label.setPos(x, y)
        self._label.setBrush(QColor("#ffffff"))

    def hoverEnterEvent(self, event) -> None:
        """Handle hover enter."""
        self.setPen(QPen(QColor("#63b3ed"), 3))
        super().hoverEnterEvent(event)

    def hoverLeaveEvent(self, event) -> None:
        """Handle hover leave."""
        self._setup_style()
        super().hoverLeaveEvent(event)


class ConnectionItem(QGraphicsPathItem):
    """Visual representation of a connection."""

    def __init__(
        self,
        from_item: NodeItem,
        to_item: NodeItem,
        connection: FlowConnection,
        parent: QGraphicsItem | None = None,
    ) -> None:
        super().__init__(parent)
        self.from_item = from_item
        self.to_item = to_item
        self.connection = connection

        # Style
        color = "#718096"
        if connection.connection_type == "true":
            color = "#38a169"
        elif connection.connection_type == "false":
            color = "#e53e3e"

        self.setPen(QPen(QColor(color), 2))

        # Create path
        self._update_path()

    def _update_path(self) -> None:
        """Update the connection path."""
        # Get node centers
        from_rect = self.from_item.sceneBoundingRect()
        to_rect = self.to_item.sceneBoundingRect()

        # Start from bottom of from_node
        start = QPointF(
            from_rect.center().x(),
            from_rect.bottom(),
        )

        # End at top of to_node
        end = QPointF(
            to_rect.center().x(),
            to_rect.top(),
        )

        # Create curved path
        path = QPainterPath()
        path.moveTo(start)

        # Control points for bezier curve
        mid_y = (start.y() + end.y()) / 2
        ctrl1 = QPointF(start.x(), mid_y)
        ctrl2 = QPointF(end.x(), mid_y)

        path.cubicTo(ctrl1, ctrl2, end)

        self.setPath(path)

        # Add arrow head
        self._add_arrow(end)

    def _add_arrow(self, tip: QPointF) -> None:
        """Add arrow head at the tip."""
        # Arrow is drawn as part of the scene separately
        pass


class FlowDiagram(QGraphicsView):
    """Flow diagram viewer.

    Usage:
        diagram = FlowDiagram()
        diagram.add_node(FlowNode("start", "Start", "start"))
        diagram.add_node(FlowNode("action1", "Click Button", "action"))
        diagram.connect("start", "action1")
    """

    node_selected = Signal(str)  # node id
    node_double_clicked = Signal(str)  # node id

    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)

        # Create scene
        self._scene = QGraphicsScene(self)
        self.setScene(self._scene)

        # Settings
        self.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.setViewportUpdateMode(QGraphicsView.ViewportUpdateMode.FullViewportUpdate)
        self.setDragMode(QGraphicsView.DragMode.ScrollHandDrag)
        self.setBackgroundBrush(QColor("#1a202c"))

        # Node storage
        self._nodes: dict[str, NodeItem] = {}
        self._connections: list[ConnectionItem] = []

    def add_node(self, node: FlowNode) -> NodeItem:
        """Add a node to the diagram."""
        item = NodeItem(node)
        self._scene.addItem(item)
        self._nodes[node.id] = item
        return item

    def remove_node(self, node_id: str) -> None:
        """Remove a node from the diagram."""
        if node_id in self._nodes:
            item = self._nodes.pop(node_id)
            self._scene.removeItem(item)

    def connect(
        self,
        from_id: str,
        to_id: str,
        label: str = "",
        connection_type: str = "default",
    ) -> ConnectionItem | None:
        """Connect two nodes."""
        if from_id not in self._nodes or to_id not in self._nodes:
            return None

        connection = FlowConnection(from_id, to_id, label, connection_type)
        item = ConnectionItem(
            self._nodes[from_id],
            self._nodes[to_id],
            connection,
        )
        self._scene.addItem(item)
        self._connections.append(item)
        return item

    def clear(self) -> None:
        """Clear all nodes and connections."""
        self._scene.clear()
        self._nodes.clear()
        self._connections.clear()

    def auto_layout(self) -> None:
        """Auto-layout nodes in a tree structure."""
        if not self._nodes:
            return

        # Simple vertical layout
        x = 50
        y = 50
        spacing_y = 80

        for _node_id, item in self._nodes.items():
            item.setPos(x, y)
            y += spacing_y

        # Update connections
        for conn in self._connections:
            conn._update_path()

    def from_ast(self, flows: list[Any]) -> None:
        """Build diagram from AST flows.

        Args:
            flows: List of FlowDecl AST nodes
        """
        self.clear()
        y = 50

        for flow in flows:
            # Add flow start node
            start_node = FlowNode(
                id=f"{flow.name}_start",
                label=f"flow {flow.name}",
                node_type="start",
                x=50,
                y=y,
            )
            self.add_node(start_node)
            y += 80

            # Add end node
            end_node = FlowNode(
                id=f"{flow.name}_end",
                label="end",
                node_type="end",
                x=50,
                y=y,
            )
            self.add_node(end_node)

            # Connect
            self.connect(start_node.id, end_node.id)
            y += 100

    def wheelEvent(self, event) -> None:
        """Handle zoom with mouse wheel."""
        factor = 1.15

        if event.angleDelta().y() > 0:
            self.scale(factor, factor)
        else:
            self.scale(1 / factor, 1 / factor)


class FlowVisualizer(QWidget):
    """Complete flow visualizer widget.

    Usage:
        viz = FlowVisualizer()
        viz.load_from_source(source_code)
    """

    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self.diagram = FlowDiagram()
        layout.addWidget(self.diagram)

    def load_from_source(self, source: str) -> None:
        """Load diagram from RetroScript source."""
        try:
            from core.dsl.parser import Parser

            parser = Parser(source)
            program = parser.parse()

            if program.flows:
                self.diagram.from_ast(program.flows)

        except Exception as e:
            print(f"Error parsing source: {e}")

    def add_sample(self) -> None:
        """Add a sample diagram for testing."""
        self.diagram.add_node(FlowNode("start", "Start", "start", 100, 50))
        self.diagram.add_node(FlowNode("find", "find(button)", "action", 100, 150))
        self.diagram.add_node(FlowNode("check", "if found?", "condition", 100, 250))
        self.diagram.add_node(FlowNode("click", "click(x, y)", "action", 50, 350))
        self.diagram.add_node(FlowNode("wait", "sleep(1s)", "action", 200, 350))
        self.diagram.add_node(FlowNode("end", "End", "end", 100, 450))

        self.diagram.connect("start", "find")
        self.diagram.connect("find", "check")
        self.diagram.connect("check", "click", "yes", "true")
        self.diagram.connect("check", "wait", "no", "false")
        self.diagram.connect("click", "end")
        self.diagram.connect("wait", "end")


================================================================================
FILE PATH: app\ui\graph_connection.py
LINES: 121
================================================================================

"""
RetroAuto v2 - Graph Connections

Phase 3: Connection System
- ConnectionItem: Bezier curve wires between nodes
- Drag-and-drop wiring
- Dynamic updates when nodes move
"""

from PySide6.QtCore import QPointF, Qt
from PySide6.QtGui import QColor, QPainter, QPainterPath, QPen
from PySide6.QtWidgets import QGraphicsItem, QGraphicsPathItem

from infra import get_logger

logger = get_logger("GraphConnection")


class ConnectionItem(QGraphicsPathItem):
    """
    Connection wire between two sockets.

    Uses Cubic Bezier curves for smooth S-shaped wires.
    """

    def __init__(self, start_socket=None, end_socket=None):
        super().__init__()

        self.start_socket = start_socket
        self.end_socket = end_socket

        # Visual settings
        self.setZValue(-1)  # Draw behind nodes
        self._update_pen()

        # Enable selection
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable)

        # Update path
        self.update_path()

    def _update_pen(self):
        """Update pen based on selection state."""
        if self.isSelected():
            pen = QPen(QColor(255, 255, 100), 3)
        else:
            # White wire for exec connections
            pen = QPen(QColor(255, 255, 255, 200), 2.5)

        pen.setCapStyle(Qt.PenCapStyle.RoundCap)
        self.setPen(pen)

    def update_path(self):
        """Update the Bezier curve path between sockets."""
        if not self.start_socket or not self.end_socket:
            return

        # Get socket positions in scene coordinates
        start_pos = self.start_socket.scenePos()
        end_pos = self.end_socket.scenePos()

        self._draw_bezier(start_pos, end_pos)

    def update_path_to_point(self, end_point: QPointF):
        """Update path to a specific point (for dragging)."""
        if not self.start_socket:
            return

        start_pos = self.start_socket.scenePos()
        self._draw_bezier(start_pos, end_point)

    def _draw_bezier(self, start: QPointF, end: QPointF):
        """Draw Bezier curve from start to end point."""
        path = QPainterPath()
        path.moveTo(start)

        # Calculate control points for S-curve
        dx = end.x() - start.x()

        # Horizontal offset for control points (creates the S shape)
        offset = abs(dx) * 0.5
        if offset < 100:
            offset = 100
        if offset > 300:
            offset = 300

        # Control points
        cp1 = QPointF(start.x() + offset, start.y())
        cp2 = QPointF(end.x() - offset, end.y())

        # Draw cubic Bezier
        path.cubicTo(cp1, cp2, end)

        self.setPath(path)

    def itemChange(self, change, value):
        """Handle selection changes."""
        if change == QGraphicsItem.GraphicsItemChange.ItemSelectedChange:
            self._update_pen()
        return super().itemChange(change, value)

    def paint(self, painter: QPainter, option, widget=None):
        """Custom paint to add selection highlight."""
        self._update_pen()
        super().paint(painter, option, widget)


class DragConnection(ConnectionItem):
    """
    Temporary connection item used during drag-and-drop wiring.
    Follows mouse cursor until dropped on a valid socket.
    """

    def __init__(self, start_socket):
        super().__init__(start_socket, None)

        # Different visual for drag connection
        pen = QPen(QColor(255, 255, 255, 150), 2.5)
        pen.setStyle(Qt.PenStyle.DashLine)
        pen.setCapStyle(Qt.PenCapStyle.RoundCap)
        self.setPen(pen)


================================================================================
FILE PATH: app\ui\graph_node.py
LINES: 374
================================================================================

"""
RetroAuto v2 - Graph Node Items

Phase 2: Node Rendering
- NodeItem: Visual representation of actions
- SocketItem: Connection points (inputs/outputs)
- Professional Blueprint-style aesthetics
"""

from PySide6.QtCore import QPointF, QRectF, Qt
from PySide6.QtGui import (
    QBrush,
    QColor,
    QFont,
    QLinearGradient,
    QPainter,
    QPainterPath,
    QPen,
)
from PySide6.QtWidgets import (
    QGraphicsEllipseItem,
    QGraphicsItem,
    QGraphicsSceneMouseEvent,
)

from app.ui.graph_connection import ConnectionItem, DragConnection
from core.models import Action
from infra import get_logger

logger = get_logger("GraphNode")


# Color scheme for different action types
NODE_COLORS = {
    "ClickImage": QColor(76, 175, 80),  # Green
    "Click": QColor(76, 175, 80),
    "ClickUntil": QColor(76, 175, 80),
    "ClickRandom": QColor(76, 175, 80),
    "WaitImage": QColor(33, 150, 243),  # Blue
    "WaitPixel": QColor(33, 150, 243),
    "IfImage": QColor(255, 152, 0),  # Orange
    "IfText": QColor(255, 152, 0),
    "IfPixel": QColor(255, 152, 0),
    "Loop": QColor(156, 39, 176),  # Purple
    "WhileImage": QColor(156, 39, 176),
    "Delay": QColor(158, 158, 158),  # Gray
    "DelayRandom": QColor(158, 158, 158),
    "Hotkey": QColor(244, 67, 54),  # Red
    "TypeText": QColor(244, 67, 54),
    "ReadText": QColor(244, 67, 54),
    "Label": QColor(96, 125, 139),  # Blue Gray
    "Goto": QColor(96, 125, 139),
    "RunFlow": QColor(96, 125, 139),
}

DEFAULT_NODE_COLOR = QColor(100, 100, 100)


class SocketType:
    """Socket type enum."""

    EXEC = "exec"  # Execution flow (white triangle)
    DATA = "data"  # Data (colored circle)


class SocketItem(QGraphicsEllipseItem):
    """
    Connection socket (input/output point on a node).

    Types:
    - Exec: Execution flow sockets (triangular shape)
    - Data: Data sockets (circular shape)
    """

    def __init__(self, socket_type: str, socket_name: str, is_output: bool, parent=None):
        super().__init__(-6, -6, 12, 12, parent)

        self.socket_type = socket_type
        self.socket_name = socket_name
        self.is_output = is_output

        # Visual settings
        if socket_type == SocketType.EXEC:
            # Exec sockets: white background
            self.setBrush(QBrush(QColor(255, 255, 255, 200)))
            self.setPen(QPen(QColor(200, 200, 200), 2))
        else:
            # Data sockets: colored
            color = QColor(100, 200, 255)  # Default cyan for data
            self.setBrush(QBrush(color))
            self.setPen(QPen(color.darker(120), 2))

        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable, False)
        self.setAcceptHoverEvents(True)
        self.setAcceptedMouseButtons(Qt.MouseButton.LeftButton)

        # Connections
        self.connections = []  # List of ConnectionItem
        self._drag_connection = None  # Temporary connection during drag

    def hoverEnterEvent(self, event):
        """Highlight on hover."""
        self.setPen(QPen(QColor(255, 255, 100), 3))
        self.setCursor(Qt.CursorShape.CrossCursor)
        super().hoverEnterEvent(event)

    def hoverLeaveEvent(self, event):
        """Remove highlight."""
        if self.socket_type == SocketType.EXEC:
            self.setPen(QPen(QColor(200, 200, 200), 2))
        else:
            self.setPen(QPen(self.brush().color().darker(120), 2))
        self.setCursor(Qt.CursorShape.ArrowCursor)
        super().hoverLeaveEvent(event)

    def mousePressEvent(self, event: QGraphicsSceneMouseEvent):
        """Start drag connection."""
        if event.button() == Qt.MouseButton.LeftButton:
            # Only output sockets can initiate connections
            if self.is_output:
                self._drag_connection = DragConnection(self)
                self.scene().addItem(self._drag_connection)
                event.accept()
                return
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event: QGraphicsSceneMouseEvent):
        """Update drag connection."""
        if self._drag_connection:
            self._drag_connection.update_path_to_point(event.scenePos())
            event.accept()
            return
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event: QGraphicsSceneMouseEvent):
        """Complete or cancel drag connection."""
        if self._drag_connection:
            # Try to find target socket under cursor
            target = self._find_socket_at(event.scenePos())

            if target and self._can_connect_to(target):
                # Create permanent connection
                connection = ConnectionItem(self, target)
                self.scene().addItem(connection)
                connection.update_path()

                # Track connection in both sockets
                self.connections.append(connection)
                target.connections.append(connection)

                logger.info(f"Connected {self.socket_name} -> {target.socket_name}")

            # Remove drag connection
            self.scene().removeItem(self._drag_connection)
            self._drag_connection = None
            event.accept()
            return

        super().mouseReleaseEvent(event)

    def _find_socket_at(self, pos: QPointF):
        """Find socket item at given position."""
        items = self.scene().items(pos)
        for item in items:
            if isinstance(item, SocketItem) and item != self:
                return item
        return None

    def _can_connect_to(self, target) -> bool:
        """Check if can connect to target socket."""
        # Must be different sockets
        if target == self:
            return False

        # Must be input socket (we are output)
        if target.is_output:
            return False

        # Type must match
        if target.socket_type != self.socket_type:
            return False

        # Can't connect to same node
        return target.parentItem() != self.parentItem()

    def update_connections(self):
        """Update all connection paths (called when node moves)."""
        for conn in self.connections:
            conn.update_path()


class NodeItem(QGraphicsItem):
    """
    Visual representation of an action as a node.

    Layout:
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ [Icon] Action Name        ‚ñ∂ ‚îÇ ‚Üê Header
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ ‚óÄ Input 1                   ‚îÇ
    ‚îÇ ‚óÄ Input 2                   ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ                   Output ‚ñ∂  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    """

    def __init__(self, action: Action, x: float = 0, y: float = 0):
        super().__init__()

        self.action = action
        self.action_type = type(action).__name__

        # Visual settings
        self.width = 200
        self.header_height = 30
        self.socket_spacing = 25
        self.padding = 10

        # Color
        self.color = NODE_COLORS.get(self.action_type, DEFAULT_NODE_COLOR)

        # Flags
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges)
        self.setAcceptHoverEvents(True)

        # Position
        self.setPos(x, y)

        # Create sockets
        self.input_sockets = []
        self.output_sockets = []
        self._create_sockets()

        # Connections (all connections attached to this node)
        self.connections = []

        # Cache
        self._height = None

    def _create_sockets(self):
        """Create input/output sockets based on action type."""
        # Every action has exec in/out
        exec_in = SocketItem(SocketType.EXEC, "exec_in", False, self)
        exec_in.setPos(0, self.header_height / 2)
        self.input_sockets.append(exec_in)

        exec_out = SocketItem(SocketType.EXEC, "exec_out", True, self)
        exec_out.setPos(self.width, self.header_height / 2)
        self.output_sockets.append(exec_out)

        # TODO: Add data sockets based on action type
        # For now, just exec flow

    def boundingRect(self) -> QRectF:
        """Return bounding rectangle."""
        return QRectF(0, 0, self.width, self._get_height())

    def _get_height(self) -> float:
        """Calculate node height."""
        if self._height is None:
            # Header + body + padding
            body_height = max(
                len(self.input_sockets) * self.socket_spacing,
                len(self.output_sockets) * self.socket_spacing,
                50,  # Minimum body height
            )
            self._height = self.header_height + body_height + self.padding
        return self._height

    def paint(self, painter: QPainter, option, widget=None):
        """Paint the node."""
        height = self._get_height()

        # Selection outline
        if self.isSelected():
            painter.setPen(QPen(QColor(255, 255, 100), 3))
            painter.setBrush(Qt.BrushStyle.NoBrush)
            painter.drawRoundedRect(-2, -2, self.width + 4, height + 4, 7, 7)

        # Node body shadow
        shadow_offset = 3
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QBrush(QColor(0, 0, 0, 80)))
        painter.drawRoundedRect(shadow_offset, shadow_offset, self.width, height, 5, 5)

        # Node body background
        painter.setPen(QPen(QColor(60, 60, 60), 1))
        painter.setBrush(QBrush(QColor(45, 45, 45)))
        painter.drawRoundedRect(0, 0, self.width, height, 5, 5)

        # Header background (gradient)
        header_gradient = QLinearGradient(0, 0, 0, self.header_height)
        header_gradient.setColorAt(0, self.color)
        header_gradient.setColorAt(1, self.color.darker(120))

        painter.setBrush(QBrush(header_gradient))
        painter.setPen(Qt.PenStyle.NoPen)

        # Draw header with rounded top corners
        header_path = QPainterPath()
        header_path.moveTo(0, self.header_height)
        header_path.lineTo(0, 5)
        header_path.arcTo(0, 0, 10, 10, 180, -90)
        header_path.lineTo(self.width - 5, 0)
        header_path.arcTo(self.width - 10, 0, 10, 10, 90, -90)
        header_path.lineTo(self.width, self.header_height)
        header_path.closeSubpath()
        painter.drawPath(header_path)

        # Header text
        painter.setPen(QPen(QColor(255, 255, 255)))
        font = QFont("Segoe UI", 9, QFont.Weight.Bold)
        painter.setFont(font)

        # Get action display name
        display_name = self._get_display_name()

        # Draw text centered in header
        text_rect = QRectF(self.padding, 0, self.width - 2 * self.padding, self.header_height)
        painter.drawText(
            text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, display_name
        )

        # Body separator line
        painter.setPen(QPen(QColor(80, 80, 80), 1))
        painter.drawLine(0, self.header_height, self.width, self.header_height)

    def _get_display_name(self) -> str:
        """Get display name for the action."""
        # Map action types to friendly names
        names = {
            "ClickImage": "Click Image",
            "WaitImage": "Wait Image",
            "IfImage": "If Image",
            "IfText": "If Text",
            "ReadText": "Read Text",
            "Delay": "Delay",
            "Hotkey": "Hotkey",
            "TypeText": "Type Text",
            "Loop": "Loop",
            "RunFlow": "Run Flow",
        }
        return names.get(self.action_type, self.action_type)

    def itemChange(self, change, value):
        """Handle item changes (for connection updates)."""
        if change == QGraphicsItem.GraphicsItemChange.ItemPositionHasChanged:
            # Update all socket connections
            for socket in self.input_sockets + self.output_sockets:
                socket.update_connections()
        return super().itemChange(change, value)

    def hoverEnterEvent(self, event):
        """Highlight on hover."""
        self.setCursor(Qt.CursorShape.OpenHandCursor)
        self.update()

    def hoverLeaveEvent(self, event):
        """Remove highlight."""
        self.setCursor(Qt.CursorShape.ArrowCursor)
        self.update()

    def mousePressEvent(self, event):
        """Handle mouse press."""
        if event.button() == Qt.MouseButton.LeftButton:
            self.setCursor(Qt.CursorShape.ClosedHandCursor)
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        """Handle mouse release."""
        self.setCursor(Qt.CursorShape.OpenHandCursor)
        super().mouseReleaseEvent(event)


================================================================================
FILE PATH: app\ui\graph_view.py
LINES: 172
================================================================================

"""
RetroAuto v2 - Flow Graph View (Visual Scripting Canvas)

Phase 1: Foundation Layer
- QGraphicsView with zoom/pan
- Grid background
- Infinite canvas
"""

from PySide6.QtCore import QPointF, QRectF, Qt, Signal
from PySide6.QtGui import QColor, QMouseEvent, QPainter, QPen, QWheelEvent
from PySide6.QtWidgets import QGraphicsScene, QGraphicsView

from infra import get_logger

logger = get_logger("FlowGraph")


class FlowGraphScene(QGraphicsScene):
    """
    Graphics scene for the flow graph.
    Manages all nodes and connections.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        # Set scene rect to very large area for infinite canvas
        self.setSceneRect(-10000, -10000, 20000, 20000)

    def drawBackground(self, painter: QPainter, rect: QRectF) -> None:
        """Draw grid background."""
        painter.fillRect(rect, QColor(30, 30, 30))  # Dark background

        # Grid settings
        grid_size = 20
        left = int(rect.left()) - (int(rect.left()) % grid_size)
        top = int(rect.top()) - (int(rect.top()) % grid_size)

        # Draw grid dots
        pen = QPen(QColor(50, 50, 50))
        pen.setWidth(1)
        painter.setPen(pen)

        x = left
        while x < rect.right():
            y = top
            while y < rect.bottom():
                painter.drawPoint(x, y)
                y += grid_size
            x += grid_size


class FlowGraphView(QGraphicsView):
    """
    Main view for the flow graph canvas.

    Features:
    - Zoom with mouse wheel
    - Pan with middle mouse button or drag
    - Infinite canvas
    - Grid background
    """

    # Signals
    zoom_changed = Signal(float)  # Emits zoom level (1.0 = 100%)

    def __init__(self, parent=None):
        super().__init__(parent)

        # Create scene
        self.scene = FlowGraphScene(self)
        self.setScene(self.scene)

        # View settings
        self.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.setRenderHint(QPainter.RenderHint.TextAntialiasing)
        self.setViewportUpdateMode(QGraphicsView.ViewportUpdateMode.FullViewportUpdate)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setTransformationAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)

        # Zoom settings
        self._zoom = 1.0
        self._zoom_min = 0.1
        self._zoom_max = 3.0
        self._zoom_step = 1.15

        # Pan settings
        self._is_panning = False
        self._pan_start = QPointF()

        # Initial view position (center)
        self.centerOn(0, 0)

    def wheelEvent(self, event: QWheelEvent) -> None:
        """Handle zoom with mouse wheel."""
        # Get delta
        delta = event.angleDelta().y()

        if delta > 0:
            # Zoom in
            zoom_factor = self._zoom_step
        else:
            # Zoom out
            zoom_factor = 1.0 / self._zoom_step

        # Calculate new zoom
        new_zoom = self._zoom * zoom_factor

        # Clamp zoom
        if new_zoom < self._zoom_min:
            zoom_factor = self._zoom_min / self._zoom
        elif new_zoom > self._zoom_max:
            zoom_factor = self._zoom_max / self._zoom

        # Apply zoom
        self.scale(zoom_factor, zoom_factor)
        self._zoom *= zoom_factor

        # Emit signal
        self.zoom_changed.emit(self._zoom)

    def mousePressEvent(self, event: QMouseEvent) -> None:
        """Handle mouse press for panning."""
        if event.button() == Qt.MouseButton.MiddleButton:
            # Start panning
            self._is_panning = True
            self._pan_start = event.pos()
            self.setCursor(Qt.CursorShape.ClosedHandCursor)
            event.accept()
        else:
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event: QMouseEvent) -> None:
        """Handle mouse move for panning."""
        if self._is_panning:
            # Pan the view
            delta = event.pos() - self._pan_start
            self._pan_start = event.pos()

            # Translate view
            self.horizontalScrollBar().setValue(self.horizontalScrollBar().value() - delta.x())
            self.verticalScrollBar().setValue(self.verticalScrollBar().value() - delta.y())
            event.accept()
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event: QMouseEvent) -> None:
        """Handle mouse release."""
        if event.button() == Qt.MouseButton.MiddleButton:
            # Stop panning
            self._is_panning = False
            self.setCursor(Qt.CursorShape.ArrowCursor)
            event.accept()
        else:
            super().mouseReleaseEvent(event)

    def reset_zoom(self) -> None:
        """Reset zoom to 100%."""
        factor = 1.0 / self._zoom
        self.scale(factor, factor)
        self._zoom = 1.0
        self.zoom_changed.emit(self._zoom)

    def zoom_to_fit(self) -> None:
        """Zoom to fit all items in view."""
        items_rect = self.scene.itemsBoundingRect()
        if not items_rect.isEmpty():
            self.fitInView(items_rect, Qt.AspectRatioMode.KeepAspectRatio)
            # Update zoom level
            self._zoom = self.transform().m11()
            self.zoom_changed.emit(self._zoom)


================================================================================
FILE PATH: app\ui\hybrid_panel.py
LINES: 259
================================================================================

"""
RetroAuto v2 - Hybrid Actions Panel

Shows GUI actions alongside their DSL code representation.
Bridges the gap between low-code and high-tech users.
"""

from __future__ import annotations

from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QFont
from PySide6.QtWidgets import (
    QHBoxLayout,
    QPlainTextEdit,
    QPushButton,
    QSplitter,
    QVBoxLayout,
    QWidget,
)

from app.ui.actions_panel import ActionsPanel
from core.dsl.adapter import action_to_ir
from core.dsl.ir import IRMapper
from core.models import Action
from infra import get_logger

logger = get_logger("HybridPanel")


class CodePreview(QPlainTextEdit):
    """Read-only code preview with syntax highlighting style."""

    def __init__(self) -> None:
        super().__init__()
        self.setReadOnly(True)
        self.setFont(QFont("Consolas", 10))
        self.setStyleSheet(
            """
            QPlainTextEdit {
                background-color: #1e1e1e;
                color: #d4d4d4;
                border: 1px solid #3c3c3c;
                padding: 8px;
            }
        """
        )
        self.setPlaceholderText("// Code preview will appear here...")


class HybridActionsPanel(QWidget):
    """
    Hybrid panel showing Actions GUI + Code side-by-side.

    Layout:
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ [GUI Mode] [Code Mode] [Hybrid Mode*]           ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ  Actions Panel       ‚îÇ  Code Preview            ‚îÇ
    ‚îÇ  (Drag-drop GUI)     ‚îÇ  (Read-only DSL)         ‚îÇ
    ‚îÇ                      ‚îÇ                          ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    """

    # Forward signals from ActionsPanel
    action_selected = Signal(dict)
    action_changed = Signal()
    run_step_requested = Signal(int)
    flow_editor_requested = Signal()

    def __init__(self) -> None:
        super().__init__()
        self._view_mode = "gui"  # "gui", "code", "hybrid" - default GUI mode
        self._init_ui()
        self._connect_signals()
        self._setup_shortcuts()
        # Hide code preview for default GUI mode
        self.code_preview.hide()

    def _setup_shortcuts(self) -> None:
        """Setup keyboard shortcuts for the hybrid panel."""
        from PySide6.QtGui import QKeySequence, QShortcut

        # Delete shortcut - forward to ActionsPanel
        self.del_shortcut = QShortcut(QKeySequence(Qt.Key.Key_Delete), self)
        self.del_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.del_shortcut.activated.connect(self.actions_panel._on_delete)

        # Ctrl+A - select all in action list
        self.select_all_shortcut = QShortcut(QKeySequence.StandardKey.SelectAll, self)
        self.select_all_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.select_all_shortcut.activated.connect(self.actions_panel.action_list.selectAll)

        # Ctrl+D - duplicate
        self.dup_shortcut = QShortcut(QKeySequence("Ctrl+D"), self)
        self.dup_shortcut.setContext(Qt.ShortcutContext.WidgetWithChildrenShortcut)
        self.dup_shortcut.activated.connect(self.actions_panel._on_duplicate)

    def _init_ui(self) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(2)

        # View mode toggle buttons
        btn_bar = QHBoxLayout()
        btn_bar.setSpacing(2)

        self.btn_gui = QPushButton("üìã GUI")
        self.btn_gui.setCheckable(True)
        self.btn_gui.setChecked(True)  # Default to GUI mode
        self.btn_gui.clicked.connect(lambda: self._set_view_mode("gui"))

        self.btn_code = QPushButton("üìù Code")
        self.btn_code.setCheckable(True)
        self.btn_code.clicked.connect(lambda: self._set_view_mode("code"))

        self.btn_hybrid = QPushButton("üîÄ Hybrid")
        self.btn_hybrid.setCheckable(True)
        self.btn_hybrid.clicked.connect(lambda: self._set_view_mode("hybrid"))

        btn_bar.addWidget(self.btn_gui)
        btn_bar.addWidget(self.btn_code)
        btn_bar.addWidget(self.btn_hybrid)

        btn_bar.addStretch()

        # Link to Visual Flow Editor
        self.btn_flow = QPushButton("üé® Flow Editor")
        self.btn_flow.clicked.connect(self.flow_editor_requested.emit)
        btn_bar.addWidget(self.btn_flow)

        layout.addLayout(btn_bar)

        # Splitter for side-by-side view
        self.splitter = QSplitter(Qt.Orientation.Horizontal)

        # Left: Actions Panel (GUI)
        self.actions_panel = ActionsPanel()
        self.splitter.addWidget(self.actions_panel)

        # Right: Code Preview
        self.code_preview = CodePreview()
        self.splitter.addWidget(self.code_preview)

        # Default split 60/40
        self.splitter.setStretchFactor(0, 6)
        self.splitter.setStretchFactor(1, 4)

        layout.addWidget(self.splitter)

    def _connect_signals(self) -> None:
        # Forward ActionsPanel signals
        self.actions_panel.action_selected.connect(self.action_selected.emit)
        self.actions_panel.action_changed.connect(self._on_actions_changed)
        self.actions_panel.run_step_requested.connect(self.run_step_requested.emit)

        # Update code preview when selection changes
        self.actions_panel.action_selected.connect(self._highlight_selected_code)

    def _set_view_mode(self, mode: str) -> None:
        """Switch between GUI, Code, and Hybrid view modes."""
        self._view_mode = mode

        # Update button states
        self.btn_gui.setChecked(mode == "gui")
        self.btn_code.setChecked(mode == "code")
        self.btn_hybrid.setChecked(mode == "hybrid")

        # Update visibility
        if mode == "gui":
            self.actions_panel.show()
            self.code_preview.hide()
        elif mode == "code":
            self.actions_panel.hide()
            self.code_preview.show()
        else:  # hybrid
            self.actions_panel.show()
            self.code_preview.show()

        logger.info(f"View mode changed to: {mode}")

    def _on_actions_changed(self) -> None:
        """Regenerate code preview when actions change."""
        self._update_code_preview()
        self.action_changed.emit()

    def _update_code_preview(self) -> None:
        """Generate DSL code from current actions."""
        actions = self.actions_panel.get_actions()

        lines = ["// Auto-generated from Actions Panel", ""]

        for action in actions:
            try:
                action_ir = action_to_ir(action)
                code = IRMapper._action_to_code(action_ir)
                lines.append(f"  {code}")
            except Exception as e:
                lines.append(f"  // Error: {e}")

        self.code_preview.setPlainText("\n".join(lines))

    def _highlight_selected_code(self, data: dict) -> None:
        """Highlight the code line corresponding to selected action."""
        idx = data.get("index", -1)
        if idx >= 0:
            # Move cursor to that line (line = idx + 2 for header)
            cursor = self.code_preview.textCursor()
            block = self.code_preview.document().findBlockByLineNumber(idx + 2)
            if block.isValid():
                cursor.setPosition(block.position())
                self.code_preview.setTextCursor(cursor)
                self.code_preview.centerCursor()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Proxy methods to ActionsPanel for compatibility
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def load_actions(self, actions: list[Action]) -> None:
        """Load actions into the panel."""
        self.actions_panel.load_actions(actions)
        self._update_code_preview()

    def get_actions(self) -> list[Action]:
        """Get current actions list."""
        return self.actions_panel.get_actions()

    def update_action(self, data: dict) -> None:
        """Update action from properties panel."""
        self.actions_panel.update_action(data)
        self._update_code_preview()

    def highlight_step(self, idx: int) -> None:
        """Highlight currently executing step."""
        self.actions_panel.highlight_step(idx)

    def insert_action_for_asset(self, asset_id: str, action_type: str) -> None:
        """Insert action for asset."""
        self.actions_panel.insert_action_for_asset(asset_id, action_type)
        self._update_code_preview()

    @property
    def _actions(self) -> list[Action]:
        """Proxy to internal ActionsPanel._actions for compatibility."""
        return self.actions_panel._actions

    @_actions.setter
    def _actions(self, value: list[Action]) -> None:
        """Set actions and update code preview."""
        self.actions_panel._actions = value

    def _refresh_list(self) -> None:
        """Proxy to internal ActionsPanel._refresh_list."""
        self.actions_panel._refresh_list()
        self._update_code_preview()

    @property
    def action_list(self):
        """Proxy to action_list widget for compatibility."""
        return self.actions_panel.action_list


================================================================================
FILE PATH: app\ui\ide_main_window.py
LINES: 857
================================================================================

"""
RetroAuto v2 - MacroIDE 95 Main Window

The main IDE window with Win95/98 styling.
Layout:
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ Menu Bar                                                ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ Toolbar                                                 ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ Explorer‚îÇ         Code Editor           ‚îÇ   Inspector   ‚îÇ
  ‚îÇ         ‚îÇ                               ‚îÇ               ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ Output Panel (Output | Problems)                        ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ Status Bar: Ln X, Col Y | Ready                         ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

from __future__ import annotations

from pathlib import Path

from PySide6.QtCore import QSettings, Qt, Signal
from PySide6.QtGui import QAction, QCloseEvent, QKeySequence
from PySide6.QtWidgets import (
    QDockWidget,
    QFileDialog,
    QLabel,
    QMainWindow,
    QMessageBox,
    QSplitter,
    QStatusBar,
    QTabWidget,
    QToolBar,
    QVBoxLayout,
    QWidget,
)

from app.ui.code_editor import DSLCodeEditor
from app.ui.interrupts_panel import InterruptsPanel
from app.ui.output_panel import OutputPanel
from app.ui.project_explorer import ProjectExplorer
from app.ui.properties_panel import PropertiesPanel
from core.dsl.formatter import format_code
from core.dsl.parser import Parser
from core.dsl.semantic import analyze


class IDEMainWindow(QMainWindow):
    """
    MacroIDE 95 - Main IDE Window.

    Features:
    - Project explorer with folder navigation
    - DSL code editor with syntax highlighting
    - Property inspector
    - Output/Problems panels
    - Win95/98 classic styling
    """

    # Signals
    code_saved = Signal(str)  # Emits the saved code content

    def __init__(self) -> None:
        super().__init__()
        self._current_file: Path | None = None
        self._is_modified = False
        self._script = None  # Current loaded script
        self._intellisense = None  # Will be initialized after editor
        self._init_ui()
        self._init_intellisense()
        self._init_menu()
        self._init_toolbar()
        self._init_status_bar()
        self._connect_signals()
        self._restore_state()

    def _init_ui(self) -> None:
        """Initialize the main UI layout."""
        self.setWindowTitle("MacroIDE 95 - RetroAuto")
        self.setMinimumSize(1024, 768)

        # Central widget
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(4, 4, 4, 4)
        main_layout.setSpacing(4)

        # Main vertical splitter (editor area | output)
        vsplitter = QSplitter(Qt.Orientation.Vertical)

        # Top horizontal splitter (explorer | editor | inspector)
        hsplitter = QSplitter(Qt.Orientation.Horizontal)

        # Project Explorer (already has header)
        # Left Panel (Explorer | Assets | Interrupts)
        self.left_tabs = QTabWidget()
        self.left_tabs.setTabPosition(QTabWidget.TabPosition.South)

        # Explorer Tab
        self.explorer = ProjectExplorer()
        self.left_tabs.addTab(self.explorer, "üìÇ Explorer")

        # Assets Tab (Placeholder for now, or move AssetsPanel here later if desired)
        # For now, just keep Explorer and Interrupts

        # Interrupts Tab
        self.interrupts_panel = InterruptsPanel()
        self.left_tabs.addTab(self.interrupts_panel, "‚ö° Interrupts")

        hsplitter.addWidget(self.left_tabs)

        # Code Editor with header
        editor_container = QWidget()
        editor_layout = QVBoxLayout(editor_container)
        editor_layout.setContentsMargins(0, 0, 0, 0)
        editor_layout.setSpacing(0)

        editor_header = QLabel("Code Editor")
        editor_header.setStyleSheet(
            """
            QLabel {
                font-weight: bold;
                padding: 4px;
                background-color: #0078d4;
                color: #FFFFFF;
            }
        """
        )
        editor_layout.addWidget(editor_header)

        self.editor = DSLCodeEditor()
        # Connect asset provider for Asset Peek
        self.editor.set_asset_provider(self._get_asset_path)
        editor_layout.addWidget(self.editor)

        hsplitter.addWidget(editor_container)

        # Inspector
        self.inspector = PropertiesPanel()
        hsplitter.addWidget(self.inspector)

        # Set proportions (1:3:1)
        hsplitter.setStretchFactor(0, 1)
        hsplitter.setStretchFactor(1, 3)
        hsplitter.setStretchFactor(2, 1)
        hsplitter.setSizes([200, 600, 200])

        vsplitter.addWidget(hsplitter)

        # Output panel
        self.output = OutputPanel()
        vsplitter.addWidget(self.output)

        # Set proportions (3:1)
        vsplitter.setStretchFactor(0, 3)
        vsplitter.setStretchFactor(1, 1)
        vsplitter.setSizes([500, 200])

        main_layout.addWidget(vsplitter)

    def _init_intellisense(self) -> None:
        """Initialize IntelliSense for code editor."""
        from app.ui.intellisense import IntelliSenseManager

        self._intellisense = IntelliSenseManager(self.editor)

    def _init_menu(self) -> None:
        """Initialize menu bar."""
        menubar = self.menuBar()

        # File menu
        file_menu = menubar.addMenu("&File")

        new_action = QAction("&New Project", self)
        new_action.setShortcut(QKeySequence.StandardKey.New)
        new_action.triggered.connect(self._new_project)
        file_menu.addAction(new_action)

        open_project_action = QAction("Open &Project...", self)
        open_project_action.setShortcut(QKeySequence("Ctrl+Shift+O"))
        open_project_action.triggered.connect(self._open_project)
        file_menu.addAction(open_project_action)

        open_file_action = QAction("&Open File...", self)
        open_file_action.setShortcut(QKeySequence.StandardKey.Open)
        open_file_action.triggered.connect(self._open_single_file)
        file_menu.addAction(open_file_action)

        file_menu.addSeparator()

        save_action = QAction("&Save", self)
        save_action.setShortcut(QKeySequence.StandardKey.Save)
        save_action.triggered.connect(self._save_file)
        file_menu.addAction(save_action)

        save_as_action = QAction("Save &As...", self)
        save_as_action.setShortcut(QKeySequence("Ctrl+Shift+S"))
        save_as_action.triggered.connect(self._save_file_as)
        file_menu.addAction(save_as_action)

        file_menu.addSeparator()

        exit_action = QAction("E&xit", self)
        exit_action.setShortcut(QKeySequence("Alt+F4"))
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # Edit menu
        edit_menu = menubar.addMenu("&Edit")

        undo_action = QAction("&Undo", self)
        undo_action.setShortcut(QKeySequence.StandardKey.Undo)
        undo_action.triggered.connect(self.editor.undo)
        edit_menu.addAction(undo_action)

        redo_action = QAction("&Redo", self)
        redo_action.setShortcut(QKeySequence.StandardKey.Redo)
        redo_action.triggered.connect(self.editor.redo)
        edit_menu.addAction(redo_action)

        edit_menu.addSeparator()

        cut_action = QAction("Cu&t", self)
        cut_action.setShortcut(QKeySequence.StandardKey.Cut)
        cut_action.triggered.connect(self.editor.cut)
        edit_menu.addAction(cut_action)

        copy_action = QAction("&Copy", self)
        copy_action.setShortcut(QKeySequence.StandardKey.Copy)
        copy_action.triggered.connect(self.editor.copy)
        edit_menu.addAction(copy_action)

        paste_action = QAction("&Paste", self)
        paste_action.setShortcut(QKeySequence.StandardKey.Paste)
        paste_action.triggered.connect(self.editor.paste)
        edit_menu.addAction(paste_action)

        edit_menu.addSeparator()

        format_action = QAction("&Format Document", self)
        format_action.setShortcut(QKeySequence("Ctrl+Shift+F"))
        format_action.triggered.connect(self._format_document)
        edit_menu.addAction(format_action)

        # Run menu
        run_menu = menubar.addMenu("&Run")

        run_action = QAction("‚ñ∂ &Run", self)
        run_action.setShortcut(QKeySequence("F5"))
        run_action.triggered.connect(self._run_script)
        run_menu.addAction(run_action)

        stop_action = QAction("‚ñ† &Stop", self)
        stop_action.setShortcut(QKeySequence("F6"))
        stop_action.triggered.connect(self._stop_script)
        run_menu.addAction(stop_action)

        run_menu.addSeparator()

        check_action = QAction("‚úì &Check Syntax", self)
        check_action.setShortcut(QKeySequence("Ctrl+Shift+C"))
        check_action.triggered.connect(self._check_syntax)
        run_menu.addAction(check_action)

        # View menu
        view_menu = menubar.addMenu("&View")

        flow_editor_action = QAction("üé® &Flow Editor", self)
        flow_editor_action.setShortcut(QKeySequence("Ctrl+Shift+V"))
        flow_editor_action.triggered.connect(self._show_flow_editor)
        view_menu.addAction(flow_editor_action)

        # Help menu
        help_menu = menubar.addMenu("&Help")

        about_action = QAction("&About MacroIDE 95", self)
        about_action.triggered.connect(self._show_about)
        help_menu.addAction(about_action)

    def _init_toolbar(self) -> None:
        """Initialize toolbar."""
        toolbar = QToolBar()
        toolbar.setMovable(False)
        self.addToolBar(toolbar)

        # New
        new_btn = QAction("üìÑ New", self)
        new_btn.setToolTip("New Project (Ctrl+N)")
        new_btn.triggered.connect(self._new_project)
        toolbar.addAction(new_btn)

        # Open Folder
        open_folder_btn = QAction("üìÇ Folder", self)
        open_folder_btn.setToolTip("Open Project Folder (Ctrl+Shift+O)")
        open_folder_btn.triggered.connect(self._open_project)
        toolbar.addAction(open_folder_btn)

        # Open File
        open_file_btn = QAction("üìÑ File", self)
        open_file_btn.setToolTip("Open File (Ctrl+O)")
        open_file_btn.triggered.connect(self._open_single_file)
        toolbar.addAction(open_file_btn)

        # Save
        save_btn = QAction("üíæ Save", self)
        save_btn.setToolTip("Save (Ctrl+S)")
        save_btn.triggered.connect(self._save_file)
        toolbar.addAction(save_btn)

        toolbar.addSeparator()

        # Run
        self.run_btn = QAction("‚ñ∂ Run", self)
        self.run_btn.setToolTip("Run Script (F5)")
        self.run_btn.triggered.connect(self._run_script)
        toolbar.addAction(self.run_btn)

        # Stop
        self.stop_btn = QAction("‚ñ† Stop", self)
        self.stop_btn.setToolTip("Stop Script (F6)")
        self.stop_btn.setEnabled(False)
        self.stop_btn.triggered.connect(self._stop_script)
        toolbar.addAction(self.stop_btn)

        toolbar.addSeparator()

        # Check
        check_btn = QAction("‚úì Check", self)
        check_btn.setToolTip("Check Syntax (Ctrl+Shift+C)")
        check_btn.triggered.connect(self._check_syntax)
        toolbar.addAction(check_btn)

        # Format
        format_btn = QAction("üìã Format", self)
        format_btn.setToolTip("Format Code (Ctrl+Shift+F)")
        format_btn.triggered.connect(self._format_document)
        toolbar.addAction(format_btn)

    def _init_status_bar(self) -> None:
        """Initialize status bar."""
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)

        # Cursor position
        self.cursor_label = QLabel("Ln 1, Col 1")
        self.cursor_label.setMinimumWidth(100)
        self.status_bar.addPermanentWidget(self.cursor_label)

        # Status message
        self.status_bar.showMessage("Ready")

    def _connect_signals(self) -> None:
        """Connect signals from child widgets."""
        # Explorer
        self.explorer.file_opened.connect(self._open_file)

        # Structure Panel
        # Structure Panel
        from app.ui.structure_panel import StructurePanel

        self.structure_panel = StructurePanel()
        self.structure_panel.navigate_requested.connect(self._navigate_to_line)

        # Structure Dock
        structure_dock = QDockWidget("Structure", self)
        structure_dock.setObjectName("StructureDock")
        structure_dock.setWidget(self.structure_panel)
        self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, structure_dock)

        # Try to tabify with Explorer if exists
        explorer_dock = self.findChild(QDockWidget, "ExplorerDock")
        if explorer_dock:
            self.tabifyDockWidget(explorer_dock, structure_dock)

        # Editor
        self.editor.content_changed.connect(self._on_code_changed)
        self.editor.cursor_position_changed.connect(self._on_cursor_moved)

        # Output
        self.output.diagnostic_clicked.connect(self._goto_diagnostic)

        # Interrupts Panel
        self.interrupts_panel.rule_selected.connect(self._on_rule_selected)
        self.interrupts_panel.rule_changed.connect(self._on_rules_changed)

        # Inspector (PropertiesPanel doesn't need signal connection in IDE)

    def _restore_state(self) -> None:
        """Restore window state from settings."""
        settings = QSettings("RetroAuto", "MacroIDE95")

        geometry = settings.value("geometry")
        if geometry:
            self.restoreGeometry(geometry)

        last_project = settings.value("last_project")
        if last_project and Path(last_project).exists():
            self.explorer.load_project(Path(last_project))

        # Restore interrupts if script loaded
        if self._script:
            self.interrupts_panel.set_rules(self._script.interrupts)

    def closeEvent(self, event: QCloseEvent) -> None:
        """Handle window close."""
        if self._is_modified:
            reply = QMessageBox.question(
                self,
                "Unsaved Changes",
                "Save changes before closing?",
                QMessageBox.StandardButton.Save
                | QMessageBox.StandardButton.Discard
                | QMessageBox.StandardButton.Cancel,
            )
            if reply == QMessageBox.StandardButton.Save:
                self._save_file()
            elif reply == QMessageBox.StandardButton.Cancel:
                event.ignore()
                return

        # Save state
        settings = QSettings("RetroAuto", "MacroIDE95")
        settings.setValue("geometry", self.saveGeometry())

        event.accept()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # File Operations
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _new_project(self) -> None:
        """Create a new project."""
        folder = QFileDialog.getExistingDirectory(self, "Select Project Folder")
        if folder:
            path = Path(folder)
            # Create standard structure
            (path / "assets").mkdir(exist_ok=True)
            (path / "scripts").mkdir(exist_ok=True)
            (path / "flows").mkdir(exist_ok=True)

            # Create main.dsl with new RetroScript syntax
            main_dsl = path / "scripts" / "main.dsl"
            if not main_dsl.exists():
                main_dsl.write_text(
                    """// main.dsl - RetroScript 9.0
// Press F5 to run, F6 to stop

@config
  timeout = 30s
  loop_limit = 1000
  click_delay = 50..100ms
  on_error = pause

@hotkeys
  start = "F5"
  stop = "F6"

@main:
  log "Script started..."

  // Example: Wait for a button and click it
  $target = find(login_btn, timeout: 10s)
  match $target:
    Found(pos, score):
      log "Found button at {pos} (score: {score}%)"
      click pos
    NotFound:
      log.warn "Button not found, skipping..."

  // Loop example
  repeat 5:
    $item = find(item_icon)
    if $item.found:
      click $item.pos
      sleep 500ms
  end

  log "Script completed!"

@interrupts:
  // Handle common popups
  close_popup -> press Escape
  error_dialog -> click ok_btn
""",
                    encoding="utf-8",
                )

            self.explorer.load_project(path)
            self._open_file(str(main_dsl), "script")
            self.output.log_success(f"Created new project: {path.name}")

    def _open_project(self) -> None:
        """Open an existing project folder."""
        folder = QFileDialog.getExistingDirectory(self, "Open Project Folder")
        if folder:
            path = Path(folder)
            self.explorer.load_project(path)

            # Save as last project
            settings = QSettings("RetroAuto", "MacroIDE95")
            settings.setValue("last_project", str(path))

            self.output.log_info(f"Opened project: {path.name}")

    def _open_single_file(self) -> None:
        """Open a file directly (DSL, YAML, JSON, TXT)."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Open File",
            "",
            "DSL Scripts (*.dsl);;"
            "YAML Files (*.yaml *.yml);;"
            "JSON Files (*.json);;"
            "Text Files (*.txt);;"
            "All Files (*)",
        )
        if file_path:
            # Determine file type from extension
            ext = Path(file_path).suffix.lower()
            if ext == ".dsl":
                file_type = "script"
            elif ext in (".yaml", ".yml"):
                file_type = "yaml"
            elif ext == ".json":
                file_type = "json"
            else:
                file_type = "text"
            self._open_file(file_path, file_type)

    def _open_file(self, file_path: str, file_type: str) -> None:
        """Open a file in the editor."""
        if self._is_modified:
            reply = QMessageBox.question(
                self,
                "Unsaved Changes",
                "Save changes before opening another file?",
                QMessageBox.StandardButton.Save
                | QMessageBox.StandardButton.Discard
                | QMessageBox.StandardButton.Cancel,
            )
            if reply == QMessageBox.StandardButton.Save:
                self._save_file()
            elif reply == QMessageBox.StandardButton.Cancel:
                return

        path = Path(file_path)
        if path.exists():
            try:
                content = path.read_text(encoding="utf-8")
                self.editor.set_code(content)
                self._current_file = path
                self._is_modified = False
                self._update_title()
                self.output.log_info(f"Opened: {path.name}")

                # Check syntax on open
                self._check_syntax()
            except Exception as e:
                self.output.log_error(f"Error opening file: {e}")

    def _save_file(self) -> None:
        """Save the current file."""
        if not self._current_file:
            self._save_file_as()
            return

        try:
            # Ensure parent directory exists
            self._current_file.parent.mkdir(parents=True, exist_ok=True)

            content = self.editor.get_code()
            self._current_file.write_text(content, encoding="utf-8")
            self._is_modified = False
            self._update_title()
            self.status_bar.showMessage("Saved", 3000)
            self.output.log_success(f"Saved: {self._current_file.name}")

            # Emit signal for sync with MainWindow
            self.code_saved.emit(content)
        except Exception as e:
            self.output.log_error(f"Error saving: {e}")

    def _save_file_as(self) -> None:
        """Save as new file."""
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Save As",
            str(self._current_file or ""),
            "DSL Files (*.dsl);;All Files (*)",
        )
        if file_path:
            self._current_file = Path(file_path)
            self._save_file()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Code Operations
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _format_document(self) -> None:
        """Format the current document."""
        code = self.editor.get_code()
        formatted = format_code(code)
        if formatted != code:
            cursor_pos = self.editor.get_cursor_position()
            self.editor.set_code(formatted)
            self.editor.goto_line(*cursor_pos)
            self.output.log_info("Document formatted")
        else:
            self.output.log_info("Document already formatted")

    def _check_syntax(self) -> None:
        """Check syntax and update problems panel."""
        code = self.editor.get_code()
        parser = Parser(code)
        program = parser.parse()

        # Get parse errors
        diagnostics = list(parser.errors)

        # Add semantic errors
        if not parser.errors:
            # TODO: Get known assets from project
            semantic_errors = analyze(program, known_assets=[])
            diagnostics.extend(semantic_errors)

        file_name = self._current_file.name if self._current_file else "untitled"
        self.output.set_diagnostics(diagnostics, file_name)

        if diagnostics:
            errors = sum(1 for d in diagnostics if d.severity.value == "error")
            warnings = len(diagnostics) - errors
            self.output.log_warning(f"Found {errors} error(s), {warnings} warning(s)")
        else:
            self.output.log_success("No problems found")

    def _goto_diagnostic(self, file_path: str, line: int, col: int) -> None:
        """Go to diagnostic location in editor."""
        self.editor.goto_line(line, col)
        self.editor.setFocus()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Run Operations
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _run_script(self) -> None:
        """Run the current script."""
        self.output.log_info("Running script...")
        self.run_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        # TODO: Implement actual script execution
        self.status_bar.showMessage("Running...")

    def _stop_script(self) -> None:
        """Stop the running script."""
        self.output.log_warning("Script stopped")
        self.run_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.status_bar.showMessage("Stopped")

    def _show_flow_editor(self) -> None:
        """Show the visual flow editor in a new window."""
        from PySide6.QtWidgets import QMainWindow

        from app.ui.flow_editor import FlowEditorWidget
        from core.dsl.document import ScriptDocument

        # Parse current code to IR
        code = self.editor.get_code()
        doc = ScriptDocument()
        doc.update_from_code(code)

        if not doc.ir.is_valid:
            QMessageBox.warning(
                self,
                "Parse Error",
                "Cannot open Flow Editor because the code contains syntax errors.\nPlease fix the errors and try again.",
            )
            return

        # Convert IR to Actions
        try:
            # Flatten all flows into a single list for now (or handle multiple flows)
            # FlowEditor usually expects a list of actions for a single flow.
            # Let's use the 'main' flow or the first flow.
            target_flow = doc.ir.get_flow("main") or (doc.ir.flows[0] if doc.ir.flows else None)

            if not target_flow:
                current_actions = []
            else:
                # We need a converter from IR to Actions (GUI objects)
                # core.dsl.adapter.ir_to_action ? No, adapter is for single action
                # Let's grab the adapter
                from core.dsl.adapter import ir_to_action

                current_actions = [ir_to_action(a) for a in target_flow.actions]

        except Exception as e:
            QMessageBox.critical(
                self, "Conversion Error", f"Failed to convert code to actions: {e}"
            )
            return

        # Create flow editor window
        self._flow_window = QMainWindow(self)
        self._flow_window.setWindowTitle("üé® Visual Flow Editor - RetroAuto")
        self._flow_window.setMinimumSize(800, 600)

        flow_widget = FlowEditorWidget(actions=current_actions)
        flow_widget.actions_exported.connect(self._on_flow_actions_exported)

        self._flow_window.setCentralWidget(flow_widget)

        self._flow_window.show()
        self.output.log_info("Opened Visual Flow Editor")

    def _on_flow_actions_exported(self, actions: list) -> None:
        """Handle actions exported from flow editor."""
        from core.dsl.adapter import action_to_ir
        from core.dsl.document import ScriptDocument
        from core.dsl.ir import FlowIR, ir_to_code

        try:
            # Convert UI Actions back to IR
            action_irs = []
            for action in actions:
                ir = action_to_ir(action)
                if ir:
                    action_irs.append(ir)

            # Reconstruct Code
            # We preserve existing IR structure (assets, config)
            # regenerate with new main flow

            current_code = self.editor.get_code()
            doc = ScriptDocument()
            doc.update_from_code(current_code)

            # Find main flow to replace
            # If doc was invalid, maybe we overwrite? But safer to rely on valid doc.
            if not doc.ir.is_valid:
                # If code was invalid, we might lose data.
                # But we checked validity on open.
                pass

            main_flow = doc.ir.get_flow("main")
            if not main_flow:
                main_flow = FlowIR(name="main")
                doc.ir.flows.append(main_flow)

            main_flow.actions = action_irs

            # Generate new code
            new_code = ir_to_code(doc.ir)

            # Update Editor
            self.editor.set_code(new_code)

            self.output.log_success(f"Synced {len(actions)} actions from Flow Editor")
            self.status_bar.showMessage("Synced actions from Flow Editor")

        except Exception as e:
            self.output.log_error(f"Failed to sync actions: {e}")
            QMessageBox.critical(self, "Sync Error", f"Failed to sync actions: {e}")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # UI Updates
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _on_code_changed(self) -> None:
        """Handle code changes."""
        if not self._is_modified:
            self._is_modified = True
            self._update_title()
        # Update structure panel
        self.structure_panel.refresh(self.editor.get_code())

    def _navigate_to_line(self, line: int) -> None:
        """Scroll editor to specific line."""
        self.editor.goto_line(line)
        self.editor.setFocus()

    def _on_content_changed(self) -> None:
        """Handle content change in editor."""
        # This method is now effectively replaced by _on_code_changed
        # Keeping it for now, but its signal connection should be updated.
        # The instruction implies _on_content_changed is renamed/replaced by _on_code_changed
        # and the logic for _is_modified and _update_title is moved into _on_code_changed.
        # The original _on_content_changed signal connection is updated in _connect_signals.
        pass  # The logic is now in _on_code_changed

    def _on_cursor_moved(self, line: int, col: int) -> None:
        """Handle cursor movement."""
        self.cursor_label.setText(f"Ln {line}, Col {col}")

    def _update_title(self) -> None:
        """Update window title with full script path."""
        if self._current_file:
            file_path = Path(self._current_file)
            file_name = file_path.name
            parent_dir = file_path.parent
            display = f"{file_name} - {parent_dir}"
        else:
            display = "Untitled"

        modified = " *" if self._is_modified else ""
        self.setWindowTitle(f"RetroAuto v2 - {display}{modified}")

    def _show_about(self) -> None:
        """Show about dialog."""
        QMessageBox.about(
            self,
            "About MacroIDE 95",
            "MacroIDE 95\nVersion 1.0\n\n"
            "A Windows automation IDE with\n"
            "classic Win95/98 styling.\n\n"
            "¬© 2024 RetroAuto",
        )

    def _on_rule_selected(self, data: dict) -> None:
        """Handle interrupt rule selection."""
        # data = {"index": int, "rule": InterruptRule}
        self.inspector.load_action(
            {"action": data["rule"], "type": "interrupt", "index": data["index"]}
        )

    def _on_rules_changed(self, rules: list) -> None:
        """Handle interrupt rules update."""
        if self._script:
            self._script.interrupts = rules
            self._mark_modified()

    def _get_asset_path(self, asset_id: str) -> Path | None:
        """Get path to asset image file."""
        if not self._current_file:
            return None

        # Assuming standard structure: project/assets/asset_id.png
        # Assets are in "assets" sibling folder of "scripts" folder?
        # Standard: project_root/assets/
        # Current file: project_root/scripts/main.dsl

        project_root = self._current_file.parent.parent
        assets_dir = project_root / "assets"

        if not assets_dir.exists():
            return None

        # Try common extensions
        for ext in [".png", ".jpg", ".jpeg", ".bmp"]:
            path = assets_dir / f"{asset_id}{ext}"
            if path.exists():
                return path

        return None


================================================================================
FILE PATH: app\ui\image_preview.py
LINES: 349
================================================================================

"""
RetroAuto v2 - Image Preview

Asset preview widget with zoom, pan, and match highlighting.
Part of RetroScript Phase 14 - Visual Editor Components.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path

from PySide6.QtCore import QPoint, Qt, Signal
from PySide6.QtGui import QColor, QImage, QPainter, QPen, QPixmap, QWheelEvent
from PySide6.QtWidgets import (
    QFileDialog,
    QHBoxLayout,
    QLabel,
    QPushButton,
    QScrollArea,
    QSlider,
    QVBoxLayout,
    QWidget,
)


@dataclass
class MatchHighlight:
    """A match result to highlight on the image."""

    x: int
    y: int
    width: int
    height: int
    score: float = 1.0
    label: str = ""


class ImagePreviewWidget(QLabel):
    """Image display widget with zoom and pan support."""

    clicked = Signal(int, int)  # x, y position

    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self._pixmap: QPixmap | None = None
        self._zoom = 1.0
        self._highlights: list[MatchHighlight] = []
        self._pan_start: QPoint | None = None

        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.setMinimumSize(100, 100)
        self.setStyleSheet("background: #1e1e1e; border: 1px solid #3c3c3c;")

    def set_image(self, image: QPixmap | QImage | str | Path) -> None:
        """Set the image to display.

        Args:
            image: QPixmap, QImage, or path to image file
        """
        if isinstance(image, (str, Path)):
            self._pixmap = QPixmap(str(image))
        elif isinstance(image, QImage):
            self._pixmap = QPixmap.fromImage(image)
        else:
            self._pixmap = image

        self._update_display()

    def set_zoom(self, zoom: float) -> None:
        """Set zoom level (1.0 = 100%)."""
        self._zoom = max(0.1, min(10.0, zoom))
        self._update_display()

    def zoom_in(self) -> None:
        """Zoom in by 25%."""
        self.set_zoom(self._zoom * 1.25)

    def zoom_out(self) -> None:
        """Zoom out by 25%."""
        self.set_zoom(self._zoom * 0.8)

    def zoom_fit(self) -> None:
        """Zoom to fit the widget."""
        if not self._pixmap:
            return

        # Calculate zoom to fit
        w_ratio = self.width() / self._pixmap.width()
        h_ratio = self.height() / self._pixmap.height()
        self._zoom = min(w_ratio, h_ratio, 1.0)
        self._update_display()

    def zoom_reset(self) -> None:
        """Reset zoom to 100%."""
        self.set_zoom(1.0)

    def add_highlight(self, highlight: MatchHighlight) -> None:
        """Add a match highlight."""
        self._highlights.append(highlight)
        self._update_display()

    def clear_highlights(self) -> None:
        """Clear all highlights."""
        self._highlights.clear()
        self._update_display()

    def _update_display(self) -> None:
        """Update the displayed image."""
        if not self._pixmap:
            self.setText("No image")
            return

        # Scale image
        scaled_size = self._pixmap.size() * self._zoom
        scaled = self._pixmap.scaled(
            scaled_size,
            Qt.AspectRatioMode.KeepAspectRatio,
            Qt.TransformationMode.SmoothTransformation,
        )

        # Draw highlights
        if self._highlights:
            scaled = self._draw_highlights(scaled)

        self.setPixmap(scaled)

    def _draw_highlights(self, pixmap: QPixmap) -> QPixmap:
        """Draw match highlights on the pixmap."""
        result = QPixmap(pixmap)
        painter = QPainter(result)

        for hl in self._highlights:
            # Scale coordinates
            x = int(hl.x * self._zoom)
            y = int(hl.y * self._zoom)
            w = int(hl.width * self._zoom)
            h = int(hl.height * self._zoom)

            # Color based on score
            if hl.score >= 0.9:
                color = QColor(0, 200, 0, 180)  # Green
            elif hl.score >= 0.7:
                color = QColor(255, 165, 0, 180)  # Orange
            else:
                color = QColor(255, 0, 0, 180)  # Red

            # Draw rectangle
            pen = QPen(color, 2)
            painter.setPen(pen)
            painter.drawRect(x, y, w, h)

            # Draw label
            if hl.label:
                painter.setPen(QColor(255, 255, 255))
                painter.drawText(x, y - 4, hl.label)

        painter.end()
        return result

    def wheelEvent(self, event: QWheelEvent) -> None:
        """Handle mouse wheel for zooming."""
        delta = event.angleDelta().y()
        if delta > 0:
            self.zoom_in()
        else:
            self.zoom_out()

    def mousePressEvent(self, event) -> None:
        """Handle mouse press for panning."""
        if event.button() == Qt.MouseButton.MiddleButton:
            self._pan_start = event.position().toPoint()
        elif event.button() == Qt.MouseButton.LeftButton:  # noqa: SIM102
            # Calculate click position on original image
            if self._pixmap:
                pos = event.position().toPoint()
                x = int(pos.x() / self._zoom)
                y = int(pos.y() / self._zoom)
                self.clicked.emit(x, y)

    def mouseMoveEvent(self, event) -> None:
        """Handle mouse move for panning."""
        if self._pan_start:
            event.position().toPoint() - self._pan_start
            # Pan is handled by scroll area
            self._pan_start = event.position().toPoint()

    def mouseReleaseEvent(self, event) -> None:
        """Handle mouse release."""
        self._pan_start = None


class ImagePreview(QWidget):
    """Complete image preview with controls.

    Usage:
        preview = ImagePreview()
        preview.load_image("assets/button.png")
        preview.add_match(100, 100, 50, 30, 0.95)
    """

    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self._current_path: str = ""
        self._setup_ui()

    def _setup_ui(self) -> None:
        """Setup UI components."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)

        # Toolbar
        toolbar = QHBoxLayout()

        open_btn = QPushButton("üìÇ Open")
        open_btn.clicked.connect(self._on_open)
        toolbar.addWidget(open_btn)

        toolbar.addStretch()

        zoom_out_btn = QPushButton("-")
        zoom_out_btn.setMaximumWidth(30)
        zoom_out_btn.clicked.connect(self._on_zoom_out)
        toolbar.addWidget(zoom_out_btn)

        self._zoom_slider = QSlider(Qt.Orientation.Horizontal)
        self._zoom_slider.setRange(10, 500)
        self._zoom_slider.setValue(100)
        self._zoom_slider.setMaximumWidth(150)
        self._zoom_slider.valueChanged.connect(self._on_zoom_slider)
        toolbar.addWidget(self._zoom_slider)

        zoom_in_btn = QPushButton("+")
        zoom_in_btn.setMaximumWidth(30)
        zoom_in_btn.clicked.connect(self._on_zoom_in)
        toolbar.addWidget(zoom_in_btn)

        fit_btn = QPushButton("Fit")
        fit_btn.setMaximumWidth(40)
        fit_btn.clicked.connect(self._on_fit)
        toolbar.addWidget(fit_btn)

        layout.addLayout(toolbar)

        # Scroll area for image
        self._scroll = QScrollArea()
        self._scroll.setWidgetResizable(True)
        self._scroll.setAlignment(Qt.AlignmentFlag.AlignCenter)

        self._image_widget = ImagePreviewWidget()
        self._scroll.setWidget(self._image_widget)

        layout.addWidget(self._scroll)

        # Info bar
        self._info_label = QLabel("No image loaded")
        self._info_label.setStyleSheet("color: #888; padding: 4px;")
        layout.addWidget(self._info_label)

        # Style
        self.setStyleSheet(
            """
            QPushButton {
                border: 1px solid #3c3c3c;
                border-radius: 4px;
                padding: 4px 8px;
                background: #2d2d2d;
            }
            QPushButton:hover {
                background: #404040;
            }
        """
        )

    def load_image(self, path: str | Path) -> None:
        """Load an image from file."""
        path = Path(path)
        if path.exists():
            self._current_path = str(path)
            self._image_widget.set_image(path)
            self._update_info()

    def set_pixmap(self, pixmap: QPixmap) -> None:
        """Set image from pixmap."""
        self._image_widget.set_image(pixmap)
        self._current_path = ""
        self._update_info()

    def add_match(
        self,
        x: int,
        y: int,
        width: int,
        height: int,
        score: float = 1.0,
        label: str = "",
    ) -> None:
        """Add a match highlight."""
        self._image_widget.add_highlight(MatchHighlight(x, y, width, height, score, label))

    def clear_matches(self) -> None:
        """Clear all match highlights."""
        self._image_widget.clear_highlights()

    def _update_info(self) -> None:
        """Update the info label."""
        if self._image_widget._pixmap:
            pm = self._image_widget._pixmap
            zoom = int(self._image_widget._zoom * 100)
            self._info_label.setText(
                f"{self._current_path or 'Image'} | " f"{pm.width()}x{pm.height()} | " f"{zoom}%"
            )
        else:
            self._info_label.setText("No image loaded")

    def _on_open(self) -> None:
        """Open file dialog."""
        path, _ = QFileDialog.getOpenFileName(
            self,
            "Open Image",
            "",
            "Images (*.png *.jpg *.jpeg *.bmp *.gif)",
        )
        if path:
            self.load_image(path)

    def _on_zoom_in(self) -> None:
        """Zoom in."""
        self._image_widget.zoom_in()
        self._zoom_slider.setValue(int(self._image_widget._zoom * 100))
        self._update_info()

    def _on_zoom_out(self) -> None:
        """Zoom out."""
        self._image_widget.zoom_out()
        self._zoom_slider.setValue(int(self._image_widget._zoom * 100))
        self._update_info()

    def _on_zoom_slider(self, value: int) -> None:
        """Handle zoom slider change."""
        self._image_widget.set_zoom(value / 100)
        self._update_info()

    def _on_fit(self) -> None:
        """Zoom to fit."""
        self._image_widget.zoom_fit()
        self._zoom_slider.setValue(int(self._image_widget._zoom * 100))
        self._update_info()


================================================================================
FILE PATH: app\ui\inspector_panel.py
LINES: 329
================================================================================

"""
RetroAuto v2 - Inspector Panel

Win95-style property inspector for:
- Script properties
- Asset properties
- Action properties
"""

from __future__ import annotations

from typing import Any

from PySide6.QtCore import Qt, Signal
from PySide6.QtWidgets import (
    QCheckBox,
    QComboBox,
    QDoubleSpinBox,
    QFormLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QScrollArea,
    QSpinBox,
    QVBoxLayout,
    QWidget,
)


class InspectorPanel(QWidget):
    """
    Property inspector panel with Win95 styling.

    Displays and edits properties of:
    - Scripts (metadata)
    - Assets (threshold, ROI)
    - Actions (parameters)

    Signals:
        property_changed: Emitted when any property changes (key, value)
    """

    property_changed = Signal(str, object)

    def __init__(self, parent=None) -> None:  # type: ignore
        super().__init__(parent)
        self._init_ui()
        self._current_data: dict[str, Any] = {}

    def _init_ui(self) -> None:
        """Initialize the UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(4)

        # Title - dark theme matching other panels
        self.title_label = QLabel("Inspector")
        self.title_label.setStyleSheet(
            """
            QLabel {
                font-weight: bold;
                padding: 4px;
                background-color: #0078d4;
                color: #FFFFFF;
            }
        """
        )
        layout.addWidget(self.title_label)

        # Scroll area for properties - dark theme
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet(
            """
            QScrollArea {
                border: 1px solid #555555;
                background-color: #3c3c3c;
            }
        """
        )

        self.content = QWidget()
        self.content.setStyleSheet("background-color: #3c3c3c;")
        self.content_layout = QVBoxLayout(self.content)
        self.content_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        scroll.setWidget(self.content)
        layout.addWidget(scroll)

        # Empty state
        self._show_empty_state()

    def _show_empty_state(self) -> None:
        """Show empty state message."""
        self._clear_content()
        label = QLabel("No selection")
        label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        label.setStyleSheet("color: #808080;")
        self.content_layout.addWidget(label)

    def _clear_content(self) -> None:
        """Clear all content widgets."""
        while self.content_layout.count():
            item = self.content_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Script Properties
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def show_script_properties(self, data: dict[str, Any]) -> None:
        """Display script metadata properties."""
        self._clear_content()
        self._current_data = data
        self.title_label.setText("üìÑ Script Properties")

        # Metadata group
        group = QGroupBox("Metadata")
        form = QFormLayout(group)

        name_edit = QLineEdit(data.get("name", ""))
        name_edit.textChanged.connect(lambda v: self._emit_change("name", v))
        form.addRow("Name:", name_edit)

        version_edit = QLineEdit(data.get("version", "1.0"))
        version_edit.textChanged.connect(lambda v: self._emit_change("version", v))
        form.addRow("Version:", version_edit)

        author_edit = QLineEdit(data.get("author", ""))
        author_edit.textChanged.connect(lambda v: self._emit_change("author", v))
        form.addRow("Author:", author_edit)

        self.content_layout.addWidget(group)

        # Hotkeys group
        hotkeys_group = QGroupBox("Hotkeys")
        hotkeys_form = QFormLayout(hotkeys_group)

        hotkeys = data.get("hotkeys", {})

        start_edit = QLineEdit(hotkeys.get("start", "F5"))
        start_edit.textChanged.connect(lambda v: self._emit_change("hotkeys.start", v))
        hotkeys_form.addRow("Start:", start_edit)

        stop_edit = QLineEdit(hotkeys.get("stop", "F6"))
        stop_edit.textChanged.connect(lambda v: self._emit_change("hotkeys.stop", v))
        hotkeys_form.addRow("Stop:", stop_edit)

        pause_edit = QLineEdit(hotkeys.get("pause", "F7"))
        pause_edit.textChanged.connect(lambda v: self._emit_change("hotkeys.pause", v))
        hotkeys_form.addRow("Pause:", pause_edit)

        self.content_layout.addWidget(hotkeys_group)
        self.content_layout.addStretch()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Asset Properties
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def show_asset_properties(self, data: dict[str, Any]) -> None:
        """Display asset properties."""
        self._clear_content()
        self._current_data = data
        self.title_label.setText("üñºÔ∏è Asset Properties")

        group = QGroupBox("Image Asset")
        form = QFormLayout(group)

        # ID
        id_edit = QLineEdit(data.get("id", ""))
        id_edit.textChanged.connect(lambda v: self._emit_change("id", v))
        form.addRow("ID:", id_edit)

        # Path (read-only)
        path_label = QLabel(data.get("path", ""))
        path_label.setStyleSheet("color: #808080;")
        form.addRow("Path:", path_label)

        # Threshold
        threshold_spin = QDoubleSpinBox()
        threshold_spin.setRange(0.0, 1.0)
        threshold_spin.setSingleStep(0.05)
        threshold_spin.setValue(data.get("threshold", 0.8))
        threshold_spin.valueChanged.connect(lambda v: self._emit_change("threshold", v))
        form.addRow("Threshold:", threshold_spin)

        self.content_layout.addWidget(group)

        # ROI group
        roi = data.get("roi", {})
        if roi:
            roi_group = QGroupBox("Region of Interest")
            roi_form = QFormLayout(roi_group)

            x_spin = QSpinBox()
            x_spin.setRange(0, 9999)
            x_spin.setValue(roi.get("x", 0))
            x_spin.valueChanged.connect(lambda v: self._emit_change("roi.x", v))
            roi_form.addRow("X:", x_spin)

            y_spin = QSpinBox()
            y_spin.setRange(0, 9999)
            y_spin.setValue(roi.get("y", 0))
            y_spin.valueChanged.connect(lambda v: self._emit_change("roi.y", v))
            roi_form.addRow("Y:", y_spin)

            w_spin = QSpinBox()
            w_spin.setRange(0, 9999)
            w_spin.setValue(roi.get("width", 0))
            w_spin.valueChanged.connect(lambda v: self._emit_change("roi.width", v))
            roi_form.addRow("Width:", w_spin)

            h_spin = QSpinBox()
            h_spin.setRange(0, 9999)
            h_spin.setValue(roi.get("height", 0))
            h_spin.valueChanged.connect(lambda v: self._emit_change("roi.height", v))
            roi_form.addRow("Height:", h_spin)

            self.content_layout.addWidget(roi_group)

        self.content_layout.addStretch()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Action Properties
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def show_action_properties(self, action_type: str, data: dict[str, Any]) -> None:
        """Display action properties based on type."""
        self._clear_content()
        self._current_data = data
        self.title_label.setText(f"‚ö° {action_type}")

        group = QGroupBox("Parameters")
        form = QFormLayout(group)

        # Common action fields based on type
        if action_type == "wait_image":
            self._add_asset_field(form, data)
            self._add_timeout_field(form, data)
            self._add_bool_field(form, "appear", data.get("appear", True))

        elif action_type == "click":
            self._add_position_fields(form, data)
            self._add_button_field(form, data)

        elif action_type == "type_text":
            text_edit = QLineEdit(data.get("text", ""))
            text_edit.textChanged.connect(lambda v: self._emit_change("text", v))
            form.addRow("Text:", text_edit)

            self._add_bool_field(form, "paste", data.get("paste", False))
            self._add_bool_field(form, "enter", data.get("enter", False))

        elif action_type == "sleep":
            duration_spin = QSpinBox()
            duration_spin.setRange(0, 999999)
            duration_spin.setSuffix(" ms")
            duration_spin.setValue(data.get("duration_ms", 1000))
            duration_spin.valueChanged.connect(lambda v: self._emit_change("duration_ms", v))
            form.addRow("Duration:", duration_spin)

        elif action_type == "run_flow":
            flow_edit = QLineEdit(data.get("flow_name", ""))
            flow_edit.textChanged.connect(lambda v: self._emit_change("flow_name", v))
            form.addRow("Flow:", flow_edit)

        elif action_type == "goto":
            label_edit = QLineEdit(data.get("target", ""))
            label_edit.textChanged.connect(lambda v: self._emit_change("target", v))
            form.addRow("Label:", label_edit)

        self.content_layout.addWidget(group)
        self.content_layout.addStretch()

    def _add_asset_field(self, form: QFormLayout, data: dict) -> None:
        """Add asset ID field."""
        asset_edit = QLineEdit(data.get("asset_id", ""))
        asset_edit.textChanged.connect(lambda v: self._emit_change("asset_id", v))
        form.addRow("Asset:", asset_edit)

    def _add_timeout_field(self, form: QFormLayout, data: dict) -> None:
        """Add timeout field."""
        timeout_spin = QSpinBox()
        timeout_spin.setRange(0, 999999)
        timeout_spin.setSuffix(" ms")
        timeout_spin.setValue(data.get("timeout_ms", 5000))
        timeout_spin.valueChanged.connect(lambda v: self._emit_change("timeout_ms", v))
        form.addRow("Timeout:", timeout_spin)

    def _add_position_fields(self, form: QFormLayout, data: dict) -> None:
        """Add X/Y position fields."""
        x_spin = QSpinBox()
        x_spin.setRange(0, 9999)
        x_spin.setValue(data.get("x", 0))
        x_spin.valueChanged.connect(lambda v: self._emit_change("x", v))
        form.addRow("X:", x_spin)

        y_spin = QSpinBox()
        y_spin.setRange(0, 9999)
        y_spin.setValue(data.get("y", 0))
        y_spin.valueChanged.connect(lambda v: self._emit_change("y", v))
        form.addRow("Y:", y_spin)

    def _add_button_field(self, form: QFormLayout, data: dict) -> None:
        """Add mouse button field."""
        button_combo = QComboBox()
        button_combo.addItems(["left", "right", "middle"])
        button_combo.setCurrentText(data.get("button", "left"))
        button_combo.currentTextChanged.connect(lambda v: self._emit_change("button", v))
        form.addRow("Button:", button_combo)

    def _add_bool_field(self, form: QFormLayout, name: str, value: bool) -> None:
        """Add boolean checkbox field."""
        checkbox = QCheckBox()
        checkbox.setChecked(value)
        checkbox.stateChanged.connect(
            lambda s: self._emit_change(name, s == Qt.CheckState.Checked.value)
        )
        form.addRow(f"{name.title()}:", checkbox)

    def _emit_change(self, key: str, value: Any) -> None:
        """Emit property change signal."""
        self.property_changed.emit(key, value)

    def clear(self) -> None:
        """Clear the inspector."""
        self._show_empty_state()
        self.title_label.setText("Inspector")


================================================================================
FILE PATH: app\ui\intellisense.py
LINES: 268
================================================================================

"""
RetroAuto v2 - IntelliSense Completer

Provides autocomplete suggestions for DSL code editor.
Features:
- Action function names (click, wait_image, etc.)
- Asset ID completion
- Parameter hints
- Context-aware suggestions
"""

from __future__ import annotations

from PySide6.QtCore import QRect, QStringListModel, Qt
from PySide6.QtGui import QTextCursor
from PySide6.QtWidgets import QCompleter, QPlainTextEdit, QToolTip

from infra import get_logger

logger = get_logger("IntelliSense")


# DSL Built-in functions
DSL_FUNCTIONS = [
    "click",
    "click_image",
    "click_random",
    "wait_image",
    "wait_pixel",
    "if_image",
    "if_pixel",
    "if_text",
    "while_image",
    "sleep",
    "delay",
    "delay_random",
    "hotkey",
    "type_text",
    "read_text",
    "label",
    "goto",
    "run_flow",
    "drag",
    "scroll",
    "loop",
    "end_loop",
    "end_if",
    "end_while",
    "notify",
]

# DSL Keywords
DSL_KEYWORDS = [
    "flow",
    "interrupt",
    "hotkeys",
    "when",
    "priority",
    "true",
    "false",
]

# Common snippets
DSL_SNIPPETS = {
    "loop": "loop {\n  \n}",
    "flow": "flow name {\n  \n}",
    "if_image": 'if_image("asset_id") {\n  \n}',
    "while_image": 'while_image("asset_id") {\n  \n}',
}

# DSL Function Signatures
DSL_SIGNATURES = {
    "click": "click(x: int, y: int, button: str = 'left', clicks: int = 1)",
    "click_image": "click_image(asset_id: str, timeout: int = 30, region: tuple = None)",
    "click_random": "click_random(min_x: int, max_x: int, min_y: int, max_y: int)",
    "wait_image": "wait_image(asset_id: str, timeout: int = 30) -> Match",
    "wait_pixel": "wait_pixel(x: int, y: int, color: str, timeout: int = 30)",
    "if_image": "if_image(asset_id: str, region: tuple = None) -> bool",
    "if_pixel": "if_pixel(x: int, y: int, color: str) -> bool",
    "if_text": "if_text(text: str, region: tuple = None) -> bool",
    "while_image": "while_image(asset_id: str, timeout: int = 30)",
    "sleep": "sleep(duration: int_or_str)",
    "delay": "delay(ms: int)",
    "delay_random": "delay_random(min_ms: int, max_ms: int)",
    "hotkey": "hotkey(keys: str)",
    "type_text": "type_text(text: str, interval: float = 0.0)",
    "read_text": "read_text(region: tuple = None, lang: str = 'eng') -> str",
    "run_flow": "run_flow(flow_name: str)",
    "scroll": "scroll(amount: int)",
    "drag": "drag(x1: int, y1: int, x2: int, y2: int, duration: float = 0.5)",
    "notify": "notify(title: str, message: str)",
}


class DSLCompleter(QCompleter):
    """
    Autocomplete for DSL code editor.

    Provides context-aware suggestions for:
    - Function names (click, wait_image, etc.)
    - Asset IDs (from project)
    - Keywords (flow, interrupt, etc.)
    """

    def __init__(self, parent=None) -> None:
        super().__init__(parent)

        # Combine all completions
        self._base_completions = sorted(set(DSL_FUNCTIONS + DSL_KEYWORDS))
        self._asset_ids: list[str] = []

        # Setup model
        self._model = QStringListModel()
        self._update_model()
        self.setModel(self._model)

        # Completion settings
        self.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        self.setCompletionMode(QCompleter.CompletionMode.PopupCompletion)
        self.setFilterMode(Qt.MatchFlag.MatchContains)

        # Styling
        popup = self.popup()
        popup.setStyleSheet(
            """
            QListView {
                background-color: #2d2d2d;
                color: #d4d4d4;
                border: 1px solid #454545;
                selection-background-color: #094771;
                font-family: Consolas;
                font-size: 10pt;
            }
        """
        )

    def _update_model(self) -> None:
        """Update completion model with current data."""
        all_items = sorted(set(self._base_completions + self._asset_ids))
        self._model.setStringList(all_items)

    def set_asset_ids(self, asset_ids: list[str]) -> None:
        """Update available asset IDs for completion."""
        self._asset_ids = [f'"{aid}"' for aid in asset_ids]  # Add quotes
        self._update_model()
        logger.info(f"IntelliSense: Updated {len(asset_ids)} asset IDs")


class IntelliSenseManager:
    """
    Manages IntelliSense for a code editor.

    Handles:
    - Detecting completion context
    - Triggering completion popup
    - Inserting selected completion
    """

    def __init__(self, editor: QPlainTextEdit) -> None:
        self.editor = editor
        self.completer = DSLCompleter()
        self.completer.setWidget(editor)
        self.completer.activated.connect(self._insert_completion)

        # Connect to editor events
        editor.textChanged.connect(self._on_text_changed)
        editor.cursorPositionChanged.connect(self._on_cursor_moved)

    def _on_cursor_moved(self) -> None:
        """Check for signature help context."""
        cursor = self.editor.textCursor()
        pos = cursor.position()

        # Look backwards for function call
        # Simple heuristic: find '(' backwards within current line
        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine, QTextCursor.MoveMode.KeepAnchor)
        line_text = cursor.selectedText()

        # Cursor is at end of line_text. Find last '(' before cursor
        # Since we selected from start of line, `line_text` length matches position in line
        # Logic: iterate backwards from current char

        # Get char before cursor
        current_line_idx = pos - self.editor.document().findBlock(pos).position()
        text_before_cursor = line_text[:current_line_idx]

        # Find opening parenthesis of current scope
        open_paren_idx = text_before_cursor.rfind("(")
        close_paren_idx = text_before_cursor.rfind(")")

        # If we are inside parens (last open > last close)
        if open_paren_idx > close_paren_idx:
            # Check what's before the '('
            # e.g. "click(..."
            pre_paren = text_before_cursor[:open_paren_idx].strip()
            # Get last word
            words = pre_paren.split()
            if words:
                func_name = words[-1]
                if func_name in DSL_SIGNATURES:
                    # Show signature
                    signature = DSL_SIGNATURES[func_name]
                    QToolTip.showText(
                        self.editor.cursorRect().bottomRight(),  # Position
                        signature,
                        self.editor,
                        QRect(),  # No specific rect
                    )
                    return

        # If we reached here, no signature found or outside parens
        # We don't hide immediately to allow hovering, but typically we should hide if moved away
        # For now, let's rely on QToolTip auto-hide or explicit hide if strictly outside
        # But QToolTip might flicker if we hide/show constantly.
        # Let's hide if we are clearly not in specific context or if completer is showing
        if self.completer.popup().isVisible():
            return  # Don't interfere with completer

        # Optional: Hide if not identifying a function
        # QToolTip.hideText()

    def _on_text_changed(self) -> None:
        """Check if we should show completion popup."""
        cursor = self.editor.textCursor()

        # Get current word being typed
        cursor.movePosition(QTextCursor.MoveOperation.StartOfWord, QTextCursor.MoveMode.KeepAnchor)
        prefix = cursor.selectedText()

        # Show popup if typing at least 2 characters
        if len(prefix) >= 2:
            self.completer.setCompletionPrefix(prefix)

            if self.completer.completionCount() > 0:
                self.completer.popup()

                # Position popup below cursor
                rect = self.editor.cursorRect()
                rect.setWidth(250)
                self.completer.complete(rect)
            else:
                self.completer.popup().hide()
        else:
            self.completer.popup().hide()

    def _insert_completion(self, completion: str) -> None:
        """Insert selected completion into editor."""
        cursor = self.editor.textCursor()

        # Remove the typed prefix
        cursor.movePosition(QTextCursor.MoveOperation.StartOfWord, QTextCursor.MoveMode.KeepAnchor)

        # Check if completion is a snippet
        if completion in DSL_SNIPPETS:
            cursor.insertText(DSL_SNIPPETS[completion])
        else:
            cursor.insertText(completion)

            # If it's a function, add parentheses
            if completion in DSL_FUNCTIONS:
                cursor.insertText("(")

        self.editor.setTextCursor(cursor)
        logger.debug(f"IntelliSense: Inserted '{completion}'")

    def set_asset_ids(self, asset_ids: list[str]) -> None:
        """Update available asset IDs."""
        self.completer.set_asset_ids(asset_ids)


================================================================================
FILE PATH: app\ui\interrupts_panel.py
LINES: 125
================================================================================

"""
RetroAuto v2 - Interrupts Panel

Manage global interrupt rules that trigger on specific image events OR hotkeys.
"""

from PySide6.QtCore import Qt, Signal
from PySide6.QtWidgets import (
    QHBoxLayout,
    QLabel,
    QListWidget,
    QListWidgetItem,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

from core.models import InterruptRule
from infra import get_logger

logger = get_logger("InterruptsPanel")


class InterruptsPanel(QWidget):
    """
    Panel for managing global interrupt rules.
    Supports both Image triggers and Hotkey triggers.
    """

    rule_selected = Signal(dict)  # Emits {"index": int, "rule": InterruptRule}
    rule_changed = Signal(list)  # Emits updated list of rules

    def __init__(self, rules: list[InterruptRule] = None) -> None:
        super().__init__()
        self._rules = rules or []
        self._init_ui()

    def _init_ui(self) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # Header
        header = QLabel("‚ö° GLOBAL INTERRUPTS")
        header.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header.setStyleSheet("font-weight: bold; color: #ff5555; padding: 5px;")
        layout.addWidget(header)

        # List
        self.rule_list = QListWidget()
        self.rule_list.setSelectionMode(QListWidget.SelectionMode.SingleSelection)
        self.rule_list.setDragDropMode(QListWidget.DragDropMode.InternalMove)
        self.rule_list.itemClicked.connect(self._on_item_clicked)
        self.rule_list.model().rowsMoved.connect(self._on_reorder)  # type: ignore
        layout.addWidget(self.rule_list)

        # Buttons
        btn_layout = QHBoxLayout()
        self.btn_add = QPushButton("‚ûï Add Rule")
        self.btn_add.clicked.connect(self._add_rule)
        self.btn_remove = QPushButton("üóëÔ∏è Remove")
        self.btn_remove.clicked.connect(self._remove_rule)

        btn_layout.addWidget(self.btn_add)
        btn_layout.addWidget(self.btn_remove)
        layout.addLayout(btn_layout)

        self._refresh_list()

    def set_rules(self, rules: list[InterruptRule]) -> None:
        """Update rules list."""
        self._rules = rules
        self._refresh_list()

    def _refresh_list(self) -> None:
        """Refresh logic."""
        self.rule_list.clear()
        for _i, rule in enumerate(self._rules):
            item = QListWidgetItem(self._get_rule_label(rule))
            self.rule_list.addItem(item)

    def _get_rule_label(self, rule: InterruptRule) -> str:
        """Format rule display for both Image and Hotkey triggers."""
        # Determine trigger display
        if rule.trigger_type == "hotkey" and rule.when_hotkey:
            trigger = f"‚å®Ô∏è {rule.when_hotkey.upper()}"
        else:
            trigger = f"üñºÔ∏è '{rule.when_image or '?'}'"

        # Determine action display
        action = (
            f"Run Flow: {rule.run_flow}" if rule.run_flow else f"{len(rule.do_actions)} Actions"
        )
        return f"[P{rule.priority}] WHEN {trigger} ‚Üí {action}"

    def _on_item_clicked(self, item: QListWidgetItem) -> None:
        row = self.rule_list.row(item)
        if 0 <= row < len(self._rules):
            self.rule_selected.emit({"index": row, "rule": self._rules[row]})

    def _add_rule(self) -> None:
        new_rule = InterruptRule(when_image="", priority=10)
        self._rules.append(new_rule)
        self._refresh_list()
        self.rule_changed.emit(self._rules)
        # Select new item
        self.rule_list.setCurrentRow(len(self._rules) - 1)
        self.rule_selected.emit({"index": len(self._rules) - 1, "rule": new_rule})

    def _remove_rule(self) -> None:
        row = self.rule_list.currentRow()
        if row >= 0:
            self._rules.pop(row)
            self._refresh_list()
            self.rule_changed.emit(self._rules)

    def _on_reorder(self) -> None:
        # Sync internal list with UI order if needed
        pass

    def update_rule(self, index: int, updated: InterruptRule) -> None:
        """Update a specific rule after editing."""
        if 0 <= index < len(self._rules):
            self._rules[index] = updated
            self._refresh_list()
            self.rule_changed.emit(self._rules)


================================================================================
FILE PATH: app\ui\log_panel.py
LINES: 108
================================================================================

"""
RetroAuto v2 - Log Panel

Displays application logs with filtering.
"""

from PySide6.QtWidgets import (
    QComboBox,
    QGroupBox,
    QHBoxLayout,
    QPushButton,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

from infra import log_emitter


class LogPanel(QWidget):
    """
    Panel for displaying logs.

    Features:
    - Append text with level coloring
    - Filter by log level
    - Clear button
    """

    COLORS = {
        "DEBUG": "#808080",
        "INFO": "#000000",
        "WARNING": "#FF8C00",
        "ERROR": "#FF0000",
        "CRITICAL": "#FF0000",
    }

    def __init__(self) -> None:
        super().__init__()
        self._filter_level = "DEBUG"
        self._init_ui()
        self._connect_log_emitter()

    def _init_ui(self) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(4, 4, 4, 4)

        # Group box
        group = QGroupBox("Log")
        group_layout = QVBoxLayout(group)

        # Toolbar
        toolbar = QHBoxLayout()

        # Level filter
        self.filter_combo = QComboBox()
        self.filter_combo.addItems(["DEBUG", "INFO", "WARNING", "ERROR"])
        self.filter_combo.setCurrentText("DEBUG")
        self.filter_combo.currentTextChanged.connect(self._on_filter_changed)
        toolbar.addWidget(self.filter_combo)

        toolbar.addStretch()

        # Clear button
        btn_clear = QPushButton("Clear")
        btn_clear.clicked.connect(self._on_clear)
        toolbar.addWidget(btn_clear)

        group_layout.addLayout(toolbar)

        # Log text area
        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        self.log_text.setFont(self.log_text.document().defaultFont())
        group_layout.addWidget(self.log_text)

        layout.addWidget(group)

    def _connect_log_emitter(self) -> None:
        """Connect to global log emitter."""
        log_emitter.add_callback(self._on_log)

    def _on_log(self, level: str, timestamp: str, message: str) -> None:
        """Handle incoming log message."""
        # Filter by level
        levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
        if levels.index(level) < levels.index(self._filter_level):
            return

        color = self.COLORS.get(level, "#000000")
        html = f'<span style="color:{color}">[{timestamp}] {level}: {message}</span>'
        self.log_text.append(html)

        # Auto-scroll to bottom
        scrollbar = self.log_text.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())

    def _on_filter_changed(self, level: str) -> None:
        """Change log filter level."""
        self._filter_level = level

    def _on_clear(self) -> None:
        """Clear log text."""
        self.log_text.clear()

    def append(self, text: str) -> None:
        """Append plain text to log."""
        self.log_text.append(text)


================================================================================
FILE PATH: app\ui\main_window.py
LINES: 884
================================================================================

"""
RetroAuto v2 - Main Window (Win95/98 Style)

3-column layout: Assets | Actions | Properties
Bottom: Log panel
Full engine integration with QThread.
"""

import contextlib
import json
from pathlib import Path

from PySide6.QtCore import Qt, QTimer, Slot
from PySide6.QtWidgets import (
    QFileDialog,
    QMainWindow,
    QMessageBox,
    QSplitter,
    QStatusBar,
    QToolBar,
    QVBoxLayout,
    QWidget,
)

from app.ui.assets_panel import AssetsPanel
from app.ui.capture_tool import CaptureTool
from app.ui.coordinates_panel import CoordinatesPanel
from app.ui.engine_worker import EngineWorker
from app.ui.hybrid_panel import HybridActionsPanel
from app.ui.log_panel import LogPanel
from app.ui.properties_panel import PropertiesPanel
from core.dsl.document import ScriptDocument
from core.dsl.sync_manager import SyncManager
from core.engine.hotkey_listener import get_hotkey_listener
from infra import get_logger

logger = get_logger("MainWindow")


class MainWindow(QMainWindow):
    """
    Main application window with Win95/98 style.

    Layout:
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Toolbar: Open | Save | Run | Pause | Stop | Capture ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ  Assets  ‚îÇ    Actions (Flow)     ‚îÇ   Properties     ‚îÇ
    ‚îÇ  Panel   ‚îÇ      - list           ‚îÇ     Panel        ‚îÇ
    ‚îÇ          ‚îÇ      - add/delete     ‚îÇ                  ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ                    Log Panel                        ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ Status: Ready | Step: 0/0                           ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    """

    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("RetroAuto v2")
        self.resize(1200, 800)

        # Engine worker (QThread)
        # Engine worker (QThread)
        self.engine = EngineWorker()
        self._project_path: Path | None = None

        # Auto-detect project in CWD
        cwd = Path.cwd()
        if (cwd / "script.yaml").exists():
            self._project_path = cwd
            logger.info(f"Auto-detected project at {cwd}")

        self._draft_path = Path.home() / ".retroauto" / "draft.json"

        # ScriptDocument and SyncManager for GUI-IDE sync
        self._script_doc = ScriptDocument()
        self._sync_manager = SyncManager(self._script_doc)

        self._init_ui()
        self._connect_engine_signals()
        self._connect_sync_signals()

        # Create new empty script on start
        self.engine.new_script()
        self._update_title()

        # Load draft if exists
        self._load_draft()

        # Set assets directory for preview functionality
        if self._project_path:
            self.assets_panel.set_assets_dir(self._project_path / "assets")

        # Auto-save timer (every 30 seconds)
        self._auto_save_timer = QTimer(self)
        self._auto_save_timer.timeout.connect(self._save_draft)
        self._auto_save_timer.start(30000)  # 30 seconds

        # Global hotkey for capture (works even when app is minimized)
        # Note: pynput callbacks run on a different thread, so we use QMetaObject.invokeMethod
        # to marshal the call to the Qt main thread
        self._hotkey_listener = get_hotkey_listener()
        self._hotkey_listener.register("ctrl+shift+c", self._on_capture_hotkey)
        self._hotkey_listener.register("ctrl+shift+s", self._on_stop_hotkey)  # Global stop
        self._hotkey_listener.register("f4", self._on_coord_capture_hotkey)  # Coordinate capture
        self._hotkey_listener.register("ctrl+space", self._on_coord_capture_hotkey)  # Alt coordinate capture
        self._hotkey_listener.start()

        logger.info("MainWindow initialized")

    def _on_capture_hotkey(self) -> None:
        """Handle global capture hotkey - marshals to Qt main thread."""
        logger.info("Hotkey callback invoked, scheduling capture on main thread...")
        # Use QMetaObject.invokeMethod for thread-safe cross-thread invocation
        from PySide6.QtCore import QMetaObject, Qt as QtCore_Qt
        QMetaObject.invokeMethod(self, "_trigger_capture_from_hotkey", QtCore_Qt.ConnectionType.QueuedConnection)

    def _on_stop_hotkey(self) -> None:
        """Handle global stop hotkey - stops script execution from anywhere."""
        logger.info("Global stop hotkey triggered")
        from PySide6.QtCore import QMetaObject, Qt as QtCore_Qt
        QMetaObject.invokeMethod(self, "_trigger_stop_from_hotkey", QtCore_Qt.ConnectionType.QueuedConnection)

    @Slot()
    def _trigger_stop_from_hotkey(self) -> None:
        """Actually stop script - this runs on Qt main thread."""
        logger.info("Stopping script from global hotkey")
        if self.engine.isRunning():
            self._on_stop()
            # Show notification
            self.statusBar().showMessage("‚èπ Script stopped via Ctrl+Shift+S", 3000)

    @Slot()
    def _trigger_capture_from_hotkey(self) -> None:
        """Actually trigger capture - this runs on Qt main thread."""
        logger.info("Triggering capture from hotkey on main thread")
        # Show/restore window first if minimized
        if self.isMinimized():
            self.showNormal()
            self.raise_()  # Bring to front
            self.activateWindow()
            # Ensure window is fully visible before capture
            from PySide6.QtWidgets import QApplication
            QApplication.processEvents()
        # Small delay to ensure window is visible
        QTimer.singleShot(150, self._on_capture)

    def _on_coord_capture_hotkey(self) -> None:
        """Handle global coordinate capture hotkey (F4 / Ctrl+Space)."""
        logger.info("Coordinate capture hotkey triggered (F4 / Ctrl+Space)")
        from PySide6.QtCore import QMetaObject, Qt as QtCore_Qt
        QMetaObject.invokeMethod(self, "_trigger_coord_capture_from_hotkey", QtCore_Qt.ConnectionType.QueuedConnection)

    @Slot()
    def _trigger_coord_capture_from_hotkey(self) -> None:
        """Capture current mouse coordinates - this runs on Qt main thread."""
        # Get current mouse position
        from PySide6.QtGui import QCursor
        pos = QCursor.pos()
        x, y = pos.x(), pos.y()
        logger.info(f"Captured coordinates via global hotkey: ({x}, {y})")

        # Add to coordinates panel
        if hasattr(self, 'coordinates_panel'):
            self.coordinates_panel._on_capture()
            # Show notification in status bar
            self.statusBar().showMessage(f"üìç Captured: ({x}, {y})", 3000)

    def _init_ui(self) -> None:
        """Initialize UI components."""
        # Central widget
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(4, 4, 4, 4)
        main_layout.setSpacing(4)

        # Toolbar
        self._init_toolbar()

        # Main content splitter (vertical: panels | log)
        vsplitter = QSplitter(Qt.Orientation.Vertical)

        # Top: 3-column panels
        hsplitter = QSplitter(Qt.Orientation.Horizontal)

        self.assets_panel = AssetsPanel()
        self.actions_panel = HybridActionsPanel()
        self.properties_panel = PropertiesPanel()
        self.coordinates_panel = CoordinatesPanel()

        hsplitter.addWidget(self.assets_panel)
        hsplitter.addWidget(self.actions_panel)
        hsplitter.addWidget(self.properties_panel)
        hsplitter.addWidget(self.coordinates_panel)
        hsplitter.setStretchFactor(0, 1)  # Assets: 1
        hsplitter.setStretchFactor(1, 2)  # Actions: 2
        hsplitter.setStretchFactor(2, 1)  # Properties: 1
        hsplitter.setStretchFactor(3, 1)  # Coordinates: 1

        # Bottom: Log panel
        self.log_panel = LogPanel()

        vsplitter.addWidget(hsplitter)
        vsplitter.addWidget(self.log_panel)
        vsplitter.setStretchFactor(0, 3)  # Panels: 3
        vsplitter.setStretchFactor(1, 1)  # Log: 1

        main_layout.addWidget(vsplitter)

        # Status bar
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        self.status_bar.showMessage("Ready")

        # Connect panel signals
        self._connect_panel_signals()

        # Variable Watch Dock
        from PySide6.QtWidgets import QDockWidget

        from app.ui.variable_watch import VariableWatchDock

        self.watch_dock = QDockWidget("Variables", self)
        self.watch_dock.setWidget(VariableWatchDock())
        self.watch_dock.setAllowedAreas(
            Qt.DockWidgetArea.RightDockWidgetArea | Qt.DockWidgetArea.BottomDockWidgetArea
        )
        self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.watch_dock)

    def _init_toolbar(self) -> None:
        """Create toolbar with actions."""
        toolbar = QToolBar("Main Toolbar")
        toolbar.setMovable(False)
        self.addToolBar(toolbar)

        # File actions
        self.action_new = toolbar.addAction("üìÑ New", self._on_new)
        self.action_open = toolbar.addAction("üìÇ Open", self._on_open)
        self.action_save = toolbar.addAction("üíæ Save", self._on_save)
        self.action_save_as = toolbar.addAction("üíæ Save As", self._on_save_as)
        toolbar.addSeparator()

        # Run actions
        self.action_run = toolbar.addAction("‚ñ∂ Run", self._on_run)
        self.action_run.setShortcut("F10")
        self.action_run.setToolTip("Run script (F10)")
        self.action_pause = toolbar.addAction("‚è∏ Pause", self._on_pause)
        self.action_stop = toolbar.addAction("‚èπ Stop", self._on_stop)
        self.action_stop.setShortcut("Ctrl+F10")
        self.action_stop.setToolTip("Stop script (Ctrl+F10)")
        self.action_pause.setEnabled(False)
        self.action_stop.setEnabled(False)
        toolbar.addSeparator()

        # Tools
        self.action_capture = toolbar.addAction("üì∑ Capture", self._on_capture)
        self.action_capture.setShortcut("Ctrl+Shift+C")
        self.action_capture.setToolTip("Capture screen region (Ctrl+Shift+C)")
        toolbar.addSeparator()

        # IDE
        self.action_open_ide = toolbar.addAction("üñ•Ô∏è Open IDE", self._on_open_ide)

    def _connect_panel_signals(self) -> None:
        """Connect panel signals."""
        # When action selected in actions panel, show properties
        self.actions_panel.action_selected.connect(self.properties_panel.load_action)

        # When properties changed, update action
        self.properties_panel.properties_changed.connect(self.actions_panel.update_action)

        # When coordinate click added to script
        self.coordinates_panel.add_to_script.connect(self._on_add_click_to_script)

        # When assets change, sync to script for persistence
        self.assets_panel.assets_changed.connect(self._on_assets_changed)

        # Run step from actions panel
        # self.actions_panel.run_step_requested.connect(self._on_run_step)

        # Open Flow Editor
        self.actions_panel.flow_editor_requested.connect(self._show_flow_editor)

    def _connect_engine_signals(self) -> None:
        """Connect engine worker signals."""
        self.engine.state_changed.connect(self._on_state_changed)
        self.engine.step_started.connect(self._on_step_started)
        self.engine.flow_completed.connect(self._on_flow_completed)
        self.engine.error_occurred.connect(self._on_error)
        self.engine.notification_received.connect(self._on_notification)

    def _on_notification(self, title: str, message: str) -> None:
        """Handle notification from engine."""
        QMessageBox.information(self, title, message)

    def _connect_sync_signals(self) -> None:
        """Connect SyncManager signals for GUI-IDE synchronization."""
        # When IR changes from code editor, refresh Actions panel
        self._sync_manager.ir_changed.connect(self._on_ir_changed_from_code)

        # When code regenerated from GUI changes, update IDE if open
        self._sync_manager.code_regenerated.connect(self._on_code_regenerated)

        # Note: action_changed signal will be connected when we need
        # full bidirectional sync (actions_panel -> IR -> code)
        # For now, focus on code -> IR -> GUI direction

        logger.info("Sync signals connected")

    def _on_ir_changed_from_code(self, change_type: str) -> None:
        """Handle IR changes from code editor."""
        logger.info("IR changed signal received: %s", change_type)
        if change_type.startswith("code_"):
            # Refresh actions panel from IR
            actions = self._sync_manager.get_flow_actions("main")
            logger.info("Got %d actions from IR for panel refresh", len(actions) if actions else 0)
            if actions:
                self.actions_panel.load_actions(actions)
                logger.info("Actions panel updated with %d actions", len(actions))
            else:
                logger.warning("No actions returned from IR - panel not updated")

    def _on_code_regenerated(self, new_code: str) -> None:
        """Handle code regenerated from GUI changes."""
        # Update IDE window if open
        if hasattr(self, "_ide_window") and self._ide_window:
            self._ide_window.set_code(new_code)
        logger.debug("Code regenerated from GUI changes")

    def _update_title(self) -> None:
        """Update window title with project name."""
        if self.engine.script:
            name = self.engine.script.name
            path = f" - {self._project_path}" if self._project_path else ""
            self.setWindowTitle(f"RetroAuto v2 - {name}{path}")
        else:
            self.setWindowTitle("RetroAuto v2")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Toolbar handlers
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _on_new(self) -> None:
        """Create new project."""
        # Confirm if unsaved changes
        self.engine.new_script()
        self._project_path = None
        self._update_title()
        self._sync_ui_from_script()
        logger.info("Created new project")

    def _on_open(self) -> None:
        """Open project file."""
        path, _ = QFileDialog.getOpenFileName(
            self,
            "Open Script",
            "",
            "YAML Files (*.yaml *.yml);;All Files (*)",
        )
        if path:
            self._project_path = Path(path).parent
            self.engine.load_project(Path(path))
            self._update_title()
            self._sync_ui_from_script()
            logger.info("Opened project: %s", path)

    def _on_save(self) -> None:
        """Save project."""
        self._sync_script_from_ui()

        if self._project_path:
            path = self._project_path / "script.yaml"
        else:
            path_str, _ = QFileDialog.getSaveFileName(
                self,
                "Save Script",
                "script.yaml",
                "YAML Files (*.yaml);;All Files (*)",
            )
            if not path_str:
                return
            path = Path(path_str)
            self._project_path = path.parent

        if self.engine.save_project(path):
            self._update_title()
            logger.info("Saved project: %s", path)

    def _on_save_as(self) -> None:
        """Save project to a new location."""
        self._sync_script_from_ui()

        path_str, _ = QFileDialog.getSaveFileName(
            self,
            "Save Script As",
            "script.yaml",
            "YAML Files (*.yaml);;All Files (*)",
        )
        if not path_str:
            return

        path = Path(path_str)
        self._project_path = path.parent

        # Update assets directory for the new location
        self.assets_panel.set_assets_dir(self._project_path / "assets")

        if self.engine.save_project(path):
            self._update_title()
            logger.info("Saved project as: %s", path)

    def _on_run(self) -> None:
        """Start script execution."""
        if self.engine.isRunning():
            return

        self._sync_script_from_ui()

        logger.info("Starting script execution...")
        self.action_run.setEnabled(False)
        self.action_pause.setEnabled(True)
        self.action_stop.setEnabled(True)
        self.engine.start()

    def _on_pause(self) -> None:
        """Toggle pause/resume."""
        if self.engine.get_state() == "paused":
            self.engine.resume()
            self.action_pause.setText("‚è∏ Pause")
        else:
            self.engine.pause()
            self.action_pause.setText("‚ñ∂ Resume")

    def _on_stop(self) -> None:
        """Stop script execution."""
        logger.info("Stopping script...")
        self.engine.stop()

    def _update_title(self) -> None:
        """Update window title with project path and script name."""
        if self._project_path:
            script_file = self._project_path / "script.yaml"
            if script_file.exists():
                title = f"RetroAuto v2 - script.yaml - {self._project_path}"
            else:
                title = f"RetroAuto v2 - Untitled - {self._project_path}"
        else:
            title = "RetroAuto v2 - Untitled"

        self.setWindowTitle(title)

    def _on_capture(self) -> None:
        """Open capture tool."""
        logger.info("Opening capture tool...")

        # Determine assets directory
        assets_dir = self._project_path / "assets" if self._project_path else Path(".")

        # Get existing asset IDs from the assets panel to avoid duplicates
        existing_asset_ids = {asset.id for asset in self.assets_panel.get_assets()}

        # Create capture tool with existing asset info
        self._capture_tool = CaptureTool(assets_dir, existing_asset_ids)
        self._capture_tool.capture(self._on_capture_complete, parent_window=self)

    def _on_capture_complete(self, asset, roi) -> None:  # type: ignore
        """Handle capture completion."""
        logger.info(
            "Captured asset: %s with ROI (%d, %d, %d, %d)", asset.id, roi.x, roi.y, roi.w, roi.h
        )

        # Add asset with ROI to panel
        asset.roi = roi
        self.assets_panel.add_asset(asset)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Engine callbacks
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _on_state_changed(self, state: str) -> None:
        """Handle engine state change."""
        self.status_bar.showMessage(f"Status: {state.upper()}")

        if state in ("idle", "error", "stopping"):
            self.action_run.setEnabled(True)
            self.action_pause.setEnabled(False)
            self.action_stop.setEnabled(False)
            self.action_pause.setText("‚è∏ Pause")

    def _on_step_started(self, flow: str, idx: int, action_type: str) -> None:
        """Handle step start."""
        self.status_bar.showMessage(f"Running: {flow}[{idx}] - {action_type}")
        # Highlight current step in actions panel
        self.actions_panel.highlight_step(idx)

    def _on_add_click_to_script(self, x: int, y: int, button: str, clicks: int) -> None:
        """Add a click action from coordinates panel to script."""
        from core.models import Click

        click_action = Click(x=x, y=y, button=button, clicks=clicks)
        self.actions_panel._actions.append(click_action)
        self.actions_panel._refresh_list()

        logger.info(f"Added Click({x}, {y}, {button}, {clicks}) to script")
        self.status_bar.showMessage(f"Added: Click({x}, {y}) - {button}")

    def _on_flow_completed(self, flow: str, success: bool) -> None:
        """Handle flow completion."""
        if success:
            self.status_bar.showMessage(f"Completed: {flow}")
        else:
            self.status_bar.showMessage(f"Stopped/Failed: {flow}")

    def _on_error(self, message: str) -> None:
        """Handle engine error."""
        QMessageBox.critical(self, "Error", message)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Sync UI <-> Script
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _sync_ui_from_script(self) -> None:
        """Update UI from current script."""
        script = self.engine.script
        if not script:
            return

        # Update assets panel
        self.assets_panel.load_assets(script.assets)

        # Update actions panel with main flow
        main_flow = script.get_flow(script.main_flow)
        if main_flow:
            self.actions_panel.load_actions(main_flow.actions)

    def _sync_script_from_ui(self) -> None:
        """Update script from UI state."""
        script = self.engine.script
        if not script:
            return

        # Get assets from panel
        script.assets = self.assets_panel.get_assets()

        # Get actions from panel
        main_flow = script.get_flow(script.main_flow)
        if main_flow:
            main_flow.actions = self.actions_panel.get_actions()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Visual Flow Editor Integration
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _show_flow_editor(self) -> None:
        """Show the visual flow editor in a new window."""
        from PySide6.QtWidgets import QMainWindow

        from app.ui.flow_editor import FlowEditorWidget

        # Create flow editor window
        self._flow_window = QMainWindow(self)
        self._flow_window.setWindowTitle("üé® Visual Flow Editor - RetroAuto")
        self._flow_window.setMinimumSize(800, 600)

        # Get current actions
        current_actions = self.actions_panel.get_actions()

        # Initialize with current actions
        flow_widget = FlowEditorWidget(actions=current_actions)

        # Connect export signal to sync back
        flow_widget.actions_exported.connect(self._on_flow_actions_exported)

        self._flow_window.setCentralWidget(flow_widget)
        self._flow_window.show()

        logger.info("Opened Visual Flow Editor window")

    def _on_flow_actions_exported(self, actions: list) -> None:
        """Handle actions exported from flow editor."""
        self.actions_panel.load_actions(actions)
        self.status_bar.showMessage(f"Synced {len(actions)} actions from Flow Editor")
        logger.info(f"Updated Actions Panel with {len(actions)} actions from Flow Editor")

    def _on_open_ide(self) -> None:
        """Open the DSL IDE window with current script code."""
        from app.ui.ide_main_window import IDEMainWindow
        from core.dsl.adapter import action_to_ir
        from core.dsl.ir import FlowIR, ScriptIR, ir_to_code

        # Generate DSL code from current actions
        actions = self.actions_panel.get_actions()

        # Build IR from actions
        ir = ScriptIR()
        main_flow = FlowIR(name="main")
        for action in actions:
            action_ir = action_to_ir(action)
            main_flow.actions.append(action_ir)
        ir.flows.append(main_flow)

        # Generate code
        code = ir_to_code(ir)

        # Create and show IDE window
        self._ide_window = IDEMainWindow()

        # Set file path if project exists
        if self._project_path:
            self._ide_window._current_file = self._project_path / "scripts" / "main.dsl"

        # Apply dark theme matching Main Window
        dark_stylesheet = self._get_ide_dark_stylesheet()
        self._ide_window.setStyleSheet(dark_stylesheet)

        # Set the generated code in editor
        if hasattr(self._ide_window, "editor") and self._ide_window.editor:
            self._ide_window.editor.setPlainText(code)
            # Reset modified flag since this is initial content, not user edit
            self._ide_window._is_modified = False
            self._ide_window._update_title()

        # Connect IDE save signal to sync back to actions panel
        self._ide_window.code_saved.connect(self._on_ide_code_saved)

        self._ide_window.show()
        logger.info("Opened IDE window with %d actions", len(actions))

    def _on_ide_code_saved(self, code: str) -> None:
        """Handle code saved from IDE - sync back to actions panel immediately."""
        self._sync_manager.on_code_saved(code)
        logger.info("IDE code synced to actions panel")

    def _get_ide_dark_stylesheet(self) -> str:
        """Get dark theme stylesheet for IDE Editor matching Main Window."""
        return """
        /* Dark Theme for IDE Editor - Matches Main Window */
        QMainWindow, QWidget {
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        QMenuBar {
            background-color: #2d2d2d;
            color: #e0e0e0;
            border-bottom: 1px solid #3c3c3c;
        }
        QMenuBar::item:selected {
            background-color: #404040;
        }
        QMenu {
            background-color: #2d2d2d;
            color: #e0e0e0;
            border: 1px solid #3c3c3c;
        }
        QMenu::item:selected {
            background-color: #0078d4;
        }

        QToolBar {
            background-color: #2d2d2d;
            border: none;
            spacing: 4px;
            padding: 2px;
        }
        QToolButton {
            background-color: #2d2d2d;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            padding: 4px 8px;
            color: #e0e0e0;
        }
        QToolButton:hover {
            background-color: #404040;
        }
        QToolButton:pressed {
            background-color: #0078d4;
        }

        QPlainTextEdit, QTextEdit {
            background-color: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #3c3c3c;
            selection-background-color: #264f78;
            selection-color: #ffffff;
        }

        QTreeWidget, QListWidget {
            background-color: #252526;
            color: #e0e0e0;
            border: 1px solid #3c3c3c;
        }
        QTreeWidget::item:selected, QListWidget::item:selected {
            background-color: #0078d4;
        }

        QTabWidget::pane {
            background-color: #1e1e1e;
            border: 1px solid #3c3c3c;
        }
        QTabBar::tab {
            background-color: #2d2d2d;
            color: #e0e0e0;
            padding: 6px 12px;
            border: 1px solid #3c3c3c;
        }
        QTabBar::tab:selected {
            background-color: #1e1e1e;
            border-bottom: none;
        }

        QSplitter::handle {
            background-color: #3c3c3c;
        }

        QStatusBar {
            background-color: #007acc;
            color: white;
        }

        QLabel {
            color: #e0e0e0;
        }

        QGroupBox {
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            margin-top: 8px;
            color: #e0e0e0;
        }
        QGroupBox::title {
            color: #e0e0e0;
        }

        QScrollBar:vertical {
            background: #1e1e1e;
            width: 12px;
        }
        QScrollBar::handle:vertical {
            background: #5a5a5a;
            border-radius: 6px;
            min-height: 20px;
        }
        QScrollBar::handle:vertical:hover {
            background: #808080;
        }

        QPushButton {
            background-color: #0078d4;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
        }
        QPushButton:hover {
            background-color: #1084d8;
        }
        QPushButton:pressed {
            background-color: #006cc1;
        }
        QPushButton:disabled {
            background-color: #3c3c3c;
            color: #808080;
        }
        """

    def _save_draft(self) -> None:
        """Auto-save actions draft to file."""
        try:
            # Ensure directory exists
            self._draft_path.parent.mkdir(parents=True, exist_ok=True)

            # Serialize actions + assets
            actions = self.actions_panel.get_actions()
            assets = self.assets_panel.get_assets()
            draft_data = {
                "version": 1,
                "actions": [action.model_dump() for action in actions],
                "assets": [asset.model_dump() for asset in assets],
                "coordinates": self.coordinates_panel.get_coordinates(),
            }

            with open(self._draft_path, "w", encoding="utf-8") as f:
                json.dump(draft_data, f, indent=2, default=str)

            logger.debug(f"Auto-saved draft: {len(actions)} actions")
        except Exception as e:
            logger.warning(f"Failed to save draft: {e}")

    def _load_draft(self) -> None:
        """Load actions draft from file on startup."""
        try:
            if not self._draft_path.exists():
                return

            with open(self._draft_path, encoding="utf-8") as f:
                draft_data = json.load(f)

            if draft_data.get("version") != 1:
                return

            # Load actions
            from core.models import (
                Click,
                Delay,
                Goto,
                Hotkey,
                IfImage,
                Label,
                RunFlow,
                TypeText,
                WaitImage,
            )

            action_map = {
                "Click": Click,
                "WaitImage": WaitImage,
                "IfImage": IfImage,
                "Hotkey": Hotkey,
                "TypeText": TypeText,
                "Label": Label,
                "Goto": Goto,
                "RunFlow": RunFlow,
                "Delay": Delay,
            }

            actions = []
            for action_data in draft_data.get("actions", []):
                action_type = action_data.get("action")
                if action_type in action_map:
                    with contextlib.suppress(Exception):
                        actions.append(action_map[action_type](**action_data))

            if actions:
                self.actions_panel._actions = actions
                self.actions_panel._refresh_list()
                logger.info(f"Loaded draft: {len(actions)} actions")

            # Load assets
            from core.models import AssetImage

            assets = []
            for asset_data in draft_data.get("assets", []):
                with contextlib.suppress(Exception):
                    assets.append(AssetImage(**asset_data))

            if assets:
                self.assets_panel.load_assets(assets)
                logger.info(f"Loaded draft: {len(assets)} assets")

            if actions or assets:
                self.status_bar.showMessage(
                    f"Loaded draft: {len(actions)} actions, {len(assets)} assets"
                )

        except Exception as e:
            logger.warning(f"Failed to load draft: {e}")

    def closeEvent(self, event) -> None:  # type: ignore
        """Handle window close."""
        # Save draft before closing
        self._save_draft()

        # Stop global hotkey listener
        if hasattr(self, "_hotkey_listener") and self._hotkey_listener:
            self._hotkey_listener.stop()
            logger.info("Hotkey listener stopped")

        if self.engine.isRunning():
            self.engine.stop()
            if not self.engine.wait(2000):
                logger.warning("Engine did not stop gracefully, forcing termination")
                self.engine.terminate()
                self.engine.wait()
        event.accept()

    def _on_assets_changed(self) -> None:
        """Sync assets from UI to script when they change."""
        if self.engine.script:
            # Get current assets from panel
            self.engine.script.assets = self.assets_panel.get_assets()
            logger.info("Assets synced to script (%d assets)", len(self.engine.script.assets))


================================================================================
FILE PATH: app\ui\minimap.py
LINES: 162
================================================================================

"""
RetroAuto v2 - Code Minimap (The Navigator)

Visual minimap for DSL code editor.
Renders a scaled-down version of the code with syntax coloring.
"""

from __future__ import annotations

from PySide6.QtCore import Qt
from PySide6.QtGui import QColor, QMouseEvent, QPainter, QPaintEvent
from PySide6.QtWidgets import QPlainTextEdit, QWidget

# Minimap Colors
COLORS = {
    "bg": "#1e1e1e",
    "viewport": "#ffffff10",  # Transparent white
    "viewport_border": "#ffffff40",
    "default": "#808080",
    "flow": "#569cd6",  # Blue
    "logic": "#c586c0",  # Purple (Control flow)
    "comment": "#6a9955",  # Green
    "string": "#ce9178",  # Orange
}


class Minimap(QWidget):
    """
    Code Minimap widget.

    Displays a high-level view of the code structure.
    Handles scrolling interactions.
    """

    WIDTH = 60
    LINE_HEIGHT = 2  # Pixels per line

    def __init__(self, editor: QPlainTextEdit):
        super().__init__(editor)
        self.editor = editor
        self.setFixedWidth(self.WIDTH)
        self.setMouseTracking(True)
        self.show()

        # Update when editor changes
        self.editor.blockCountChanged.connect(self.update)
        # Use lambda to ignore arguments and trigger update
        self.editor.updateRequest.connect(lambda rect, dy: self.update())
        self.editor.verticalScrollBar().valueChanged.connect(self.update)

    # _on_update_request removed in favor of lambda

    def paintEvent(self, event: QPaintEvent):
        """Paint the minimap."""
        painter = QPainter(self)
        painter.fillRect(self.rect(), QColor(COLORS["bg"]))

        # Paint lines
        block = self.editor.document().firstBlock()
        pixel_y = 0
        max_y = self.height()

        while block.isValid():
            if pixel_y > max_y:
                break

            text = block.text().strip()
            if text:
                color = self._get_line_color(text)
                painter.fillRect(
                    2, pixel_y, min(len(text) * 2, self.WIDTH - 4), self.LINE_HEIGHT, QColor(color)
                )

            block = block.next()
            pixel_y += self.LINE_HEIGHT + 1  # 1px gap

        # Paint Viewport (Visible Area)
        self._paint_viewport(painter)

    def _get_line_color(self, text: str) -> str:
        """Determine color based on content."""
        if text.startswith("//") or text.startswith("#"):
            return COLORS["comment"]
        if text.startswith("@") or text.startswith("flow "):
            return COLORS["flow"]
        if any(text.startswith(k) for k in ("if", "else", "while", "loop", "match")):
            return COLORS["logic"]
        if '"' in text:
            return COLORS["string"]
        return COLORS["default"]

    def _paint_viewport(self, painter: QPainter):
        """Paint the rectangle representing visible area."""

        # Calculate viewport position
        # Ratio of visible lines to total lines

        max(1, self.editor.blockCount())
        lines_visible = self.editor.viewport().height() / self.editor.fontMetrics().height()

        # Scaling factor: map editor scroll range to minimap height?
        # Typically minimap shows the WHOLE file scaled down, or a window of it?
        # Let's map 1 code line = LINE_HEIGHT pixels on minimap.

        # If file is too long for minimap, we might need a scrollable minimap or scaling.
        # For simple implementation: Fixed scale.

        first_visible = self.editor.firstVisibleBlock().blockNumber()

        y = first_visible * (self.LINE_HEIGHT + 1)
        h = lines_visible * (self.LINE_HEIGHT + 1)

        # Draw viewport rect
        painter.fillRect(0, int(y), self.WIDTH, int(h), QColor(COLORS["viewport"]))

        # Draw border
        painter.setPen(QColor(COLORS["viewport_border"]))
        painter.drawRect(0, int(y), self.WIDTH - 1, int(h))

    def mousePressEvent(self, event: QMouseEvent):
        """Scroll to clicked position."""
        self._handle_mouse(event)

    def mouseMoveEvent(self, event: QMouseEvent):
        """Drag scroll."""
        if event.buttons() & Qt.MouseButton.LeftButton:
            self._handle_mouse(event)

    def _handle_mouse(self, event: QMouseEvent):
        """Map mouse Y to scroll position."""
        y = event.position().y()

        # Reverse map: y pixels -> line number
        line = int(y / (self.LINE_HEIGHT + 1))

        # Center viewport on click?
        # Or simpler: Jump to that line

        viewport_lines = self.editor.viewport().height() / self.editor.fontMetrics().height()
        target_line = int(line - (viewport_lines / 2))

        scrollbar = self.editor.verticalScrollBar()
        # Map line to scroll value?
        # QPlainTextEdit scroll is by lines usually, or pixels?
        # Default is usually lines if not smooth scroll?
        # Let's try cursor movement or scrollbar

        self.editor.textCursor()
        self.editor.document().findBlockByNumber(max(0, min(line, self.editor.blockCount() - 1)))

        # We want to scroll so this block is visible, preferably centered
        # Using scrollbar setValue directly is cleaner if we know the ratio

        # But setting cursor is safer for valid range
        # self.editor.setTextCursor(...) scrolls to cursor.

        # Let's try direct scrollbar calculation
        # total_pixels in minimap vs scrollbar range

        # If using 1-to-1 mapping logic:
        # scroll_val = line_idx
        scrollbar.setValue(target_line)


================================================================================
FILE PATH: app\ui\output_panel.py
LINES: 270
================================================================================

"""
RetroAuto v2 - Output Panel

Win95-style output/log panel with tabs for:
- Output (execution logs)
- Problems (diagnostics)
- Console (future REPL)
"""

from __future__ import annotations

from datetime import datetime

from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QColor, QFont
from PySide6.QtWidgets import (
    QComboBox,
    QHBoxLayout,
    QPlainTextEdit,
    QPushButton,
    QTabWidget,
    QTreeWidget,
    QTreeWidgetItem,
    QVBoxLayout,
    QWidget,
)

from core.dsl.diagnostics import Diagnostic, Severity


class OutputPanel(QWidget):
    """
    Output panel with Win95 tab styling.

    Tabs:
    - Output: Execution logs with color-coded levels
    - Problems: DSL diagnostics (errors, warnings)

    Signals:
        diagnostic_clicked: Emitted when a problem is double-clicked
    """

    diagnostic_clicked = Signal(str, int, int)  # file, line, col

    def __init__(self, parent=None) -> None:  # type: ignore
        super().__init__(parent)
        self._init_ui()

    def _init_ui(self) -> None:
        """Initialize the UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Tab widget
        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # Output tab
        self.output_widget = self._create_output_tab()
        self.tabs.addTab(self.output_widget, "Output")

        # Problems tab
        self.problems_widget = self._create_problems_tab()
        self.tabs.addTab(self.problems_widget, "Problems")

        # Apply styling
        self._apply_style()

    def _create_output_tab(self) -> QWidget:
        """Create the output log tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(4)

        # Toolbar
        toolbar = QHBoxLayout()

        self.log_level_combo = QComboBox()
        self.log_level_combo.addItems(["All", "Info", "Warning", "Error"])
        self.log_level_combo.currentTextChanged.connect(self._filter_logs)
        toolbar.addWidget(self.log_level_combo)

        toolbar.addStretch()

        clear_btn = QPushButton("Clear")
        clear_btn.clicked.connect(self._clear_output)
        toolbar.addWidget(clear_btn)

        layout.addLayout(toolbar)

        # Log output
        self.log_output = QPlainTextEdit()
        self.log_output.setReadOnly(True)
        self.log_output.setFont(QFont("Courier New", 9))
        self.log_output.setStyleSheet(
            """
            QPlainTextEdit {
                background-color: #3c3c3c;
                color: #e0e0e0;
                border: 1px solid #555555;
            }
        """
        )
        layout.addWidget(self.log_output)

        return widget

    def _create_problems_tab(self) -> QWidget:
        """Create the problems/diagnostics tab."""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(4)

        # Problems tree
        self.problems_tree = QTreeWidget()
        self.problems_tree.setHeaderLabels(["", "Message", "Location"])
        self.problems_tree.setColumnWidth(0, 30)
        self.problems_tree.setColumnWidth(1, 400)
        self.problems_tree.itemDoubleClicked.connect(self._on_problem_clicked)
        self.problems_tree.setStyleSheet(
            """
            QTreeWidget {
                background-color: #3c3c3c;
                color: #e0e0e0;
                border: 1px solid #555555;
            }
            QTreeWidget::item:selected {
                background-color: #0078d4;
                color: #FFFFFF;
            }
            QHeaderView::section {
                background-color: #2d2d2d;
                color: #e0e0e0;
                border: 1px solid #555555;
                padding: 4px;
            }
        """
        )
        layout.addWidget(self.problems_tree)

        return widget

    def _apply_style(self) -> None:
        """Apply dark tab styling."""
        self.tabs.setStyleSheet(
            """
            QTabWidget::pane {
                border: 1px solid #555555;
                background-color: #2d2d2d;
            }
            QTabBar::tab {
                background-color: #2d2d2d;
                color: #e0e0e0;
                border: 1px solid #555555;
                border-bottom: none;
                padding: 6px 12px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #3c3c3c;
                border-bottom: 1px solid #3c3c3c;
            }
            QTabBar::tab:!selected {
                background-color: #252526;
            }
        """
        )

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Output Logging
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def log(self, message: str, level: str = "info") -> None:
        """Add a log message to output."""
        timestamp = datetime.now().strftime("%H:%M:%S")

        # Color based on level
        color_map = {
            "debug": "#808080",
            "info": "#000000",
            "warning": "#808000",
            "error": "#FF0000",
            "success": "#008000",
        }
        color = color_map.get(level.lower(), "#000000")

        # Add formatted message
        prefix = f"[{level.upper():7}]"
        html = f'<span style="color:{color}">{timestamp} {prefix} {message}</span>'
        self.log_output.appendHtml(html)

    def log_info(self, message: str) -> None:
        """Log info message."""
        self.log(message, "info")

    def log_warning(self, message: str) -> None:
        """Log warning message."""
        self.log(message, "warning")

    def log_error(self, message: str) -> None:
        """Log error message."""
        self.log(message, "error")

    def log_success(self, message: str) -> None:
        """Log success message."""
        self.log(message, "success")

    def _clear_output(self) -> None:
        """Clear the output log."""
        self.log_output.clear()

    def _filter_logs(self, level: str) -> None:
        """Filter logs by level (future implementation)."""
        # For now, just a placeholder
        pass

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Problems/Diagnostics
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def set_diagnostics(self, diagnostics: list[Diagnostic], file_path: str = "") -> None:
        """Update the problems list with diagnostics."""
        self.problems_tree.clear()

        for diag in diagnostics:
            icon = "‚ùå" if diag.severity == Severity.ERROR else "‚ö†Ô∏è"
            location = f"{file_path}:{diag.span.start_line}:{diag.span.start_col}"

            item = QTreeWidgetItem([icon, diag.message, location])
            item.setData(
                0,
                Qt.ItemDataRole.UserRole,
                {
                    "file": file_path,
                    "line": diag.span.start_line,
                    "col": diag.span.start_col,
                    "diagnostic": diag,
                },
            )

            # Color based on severity
            if diag.severity == Severity.ERROR:
                item.setForeground(1, QColor("#CC0000"))
            elif diag.severity == Severity.WARNING:
                item.setForeground(1, QColor("#806600"))

            self.problems_tree.addTopLevelItem(item)

        # Update tab title with count
        error_count = sum(1 for d in diagnostics if d.severity == Severity.ERROR)
        warning_count = sum(1 for d in diagnostics if d.severity == Severity.WARNING)

        if error_count or warning_count:
            self.tabs.setTabText(1, f"Problems ({error_count}E, {warning_count}W)")
        else:
            self.tabs.setTabText(1, "Problems")

    def clear_diagnostics(self) -> None:
        """Clear all diagnostics."""
        self.problems_tree.clear()
        self.tabs.setTabText(1, "Problems")

    def _on_problem_clicked(self, item: QTreeWidgetItem, column: int) -> None:
        """Handle double-click on a problem."""
        data = item.data(0, Qt.ItemDataRole.UserRole)
        if data:
            self.diagnostic_clicked.emit(data["file"], data["line"], data["col"])


================================================================================
FILE PATH: app\ui\perf_utils.py
LINES: 110
================================================================================

"""
RetroAuto v2 - Performance Utilities

Utilities for UI performance optimization.
Phase 2.2 Performance Optimization.
"""

from PySide6.QtCore import QTimer

from infra import get_logger

logger = get_logger("PerfUtils")


class DebouncedCallback:
    """
    Debounced callback to prevent rapid-fire UI updates.

    Usage:
        debounced = DebouncedCallback(self._update_ui, delay_ms=50)
        # Call debounced.trigger() instead of _update_ui()
        # Multiple rapid triggers will coalesce into one call
    """

    def __init__(self, callback, delay_ms: int = 50) -> None:
        self._callback = callback
        self._delay_ms = delay_ms
        self._timer = QTimer()
        self._timer.setSingleShot(True)
        self._timer.timeout.connect(self._execute)
        self._pending_args = None
        self._pending_kwargs = None

    def trigger(self, *args, **kwargs) -> None:
        """Trigger callback (debounced)."""
        self._pending_args = args
        self._pending_kwargs = kwargs
        if not self._timer.isActive():
            self._timer.start(self._delay_ms)

    def _execute(self) -> None:
        """Execute the callback with pending arguments."""
        try:
            self._callback(*self._pending_args, **self._pending_kwargs)
        except Exception as e:
            logger.warning("Debounced callback error: %s", e)

    def cancel(self) -> None:
        """Cancel pending callback."""
        self._timer.stop()
        self._pending_args = None
        self._pending_kwargs = None

    @property
    def is_pending(self) -> bool:
        """Check if callback is pending."""
        return self._timer.isActive()


class ThrottledCallback:
    """
    Throttled callback to limit update frequency.

    Unlike debounce, throttle executes at most once per interval.
    """

    def __init__(self, callback, interval_ms: int = 100) -> None:
        self._callback = callback
        self._interval_ms = interval_ms
        self._last_call = 0
        self._timer = QTimer()
        self._timer.setSingleShot(True)
        self._timer.timeout.connect(self._execute)
        self._pending_args = None
        self._pending_kwargs = None

    def trigger(self, *args, **kwargs) -> None:
        """Trigger callback (throttled)."""
        import time

        now = time.time() * 1000
        elapsed = now - self._last_call

        if elapsed >= self._interval_ms:
            # Execute immediately
            self._last_call = now
            try:
                self._callback(*args, **kwargs)
            except Exception as e:
                logger.warning("Throttled callback error: %s", e)
        else:
            # Schedule for later
            self._pending_args = args
            self._pending_kwargs = kwargs
            if not self._timer.isActive():
                remaining = self._interval_ms - elapsed
                self._timer.start(int(remaining))

    def _execute(self) -> None:
        """Execute pending callback."""
        import time

        self._last_call = time.time() * 1000
        if self._pending_args is not None:
            try:
                self._callback(*self._pending_args, **self._pending_kwargs)
            except Exception as e:
                logger.warning("Throttled callback error: %s", e)
            self._pending_args = None
            self._pending_kwargs = None


================================================================================
FILE PATH: app\ui\project_explorer.py
LINES: 261
================================================================================

"""
RetroAuto v2 - Project Explorer

Win95-style file/folder tree for project navigation.
Features:
- Folder-based project structure
- Asset/Script/Flow icons
- Double-click to open
- Context menu for operations
"""

from __future__ import annotations

from pathlib import Path

from PySide6.QtCore import Qt, Signal
from PySide6.QtWidgets import (
    QInputDialog,
    QLabel,
    QMenu,
    QMessageBox,
    QTreeWidget,
    QTreeWidgetItem,
    QVBoxLayout,
    QWidget,
)


class ProjectExplorer(QWidget):
    """
    Project explorer panel with Win95 tree view.

    Signals:
        file_opened: Emitted when a file is double-clicked (path, type)
        file_created: Emitted when a new file is created (path, type)
        file_deleted: Emitted when a file is deleted (path)
    """

    file_opened = Signal(str, str)  # path, type (script, asset, flow)
    file_created = Signal(str, str)
    file_deleted = Signal(str)

    def __init__(self, parent=None) -> None:  # type: ignore
        super().__init__(parent)
        self._init_ui()
        self._project_path: Path | None = None

    def _init_ui(self) -> None:
        """Initialize the UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Header - matching Inspector style
        self.header_label = QLabel("Explorer")
        self.header_label.setStyleSheet(
            """
            QLabel {
                font-weight: bold;
                padding: 4px;
                background-color: #0078d4;
                color: #FFFFFF;
            }
        """
        )
        layout.addWidget(self.header_label)

        # Tree widget
        self.tree = QTreeWidget()
        self.tree.setHeaderHidden(True)
        self.tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self._show_context_menu)
        self.tree.itemDoubleClicked.connect(self._on_item_double_clicked)

        layout.addWidget(self.tree)

        # Style - Dark theme matching Main Window's Actions panel
        self.tree.setStyleSheet(
            """
            QTreeWidget {
                background-color: #3c3c3c;
                color: #e0e0e0;
                border: 1px solid #555555;
            }
            QTreeWidget::item {
                padding: 2px;
                min-height: 18px;
            }
            QTreeWidget::item:selected {
                background-color: #0078d4;
                color: #FFFFFF;
            }
        """
        )

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Project Loading
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def load_project(self, project_path: Path) -> None:
        """Load a project folder into the explorer."""
        self._project_path = project_path
        self.tree.clear()

        if not project_path.exists():
            return

        # Root item (project folder)
        root = QTreeWidgetItem([project_path.name])
        root.setData(0, Qt.ItemDataRole.UserRole, {"path": str(project_path), "type": "folder"})
        self.tree.addTopLevelItem(root)

        # Standard folders
        self._add_folder_items(root, project_path)

        root.setExpanded(True)

    def _add_folder_items(self, parent: QTreeWidgetItem, folder_path: Path) -> None:
        """Recursively add folder contents."""
        try:
            items = sorted(folder_path.iterdir(), key=lambda p: (not p.is_dir(), p.name.lower()))
        except PermissionError:
            return

        for path in items:
            if path.name.startswith("."):
                continue  # Skip hidden files

            if path.is_dir():
                item = self._create_folder_item(path)
                parent.addChild(item)
                self._add_folder_items(item, path)
            else:
                item = self._create_file_item(path)
                if item:
                    parent.addChild(item)

    def _create_folder_item(self, path: Path) -> QTreeWidgetItem:
        """Create a tree item for a folder."""
        item = QTreeWidgetItem([path.name])
        item.setData(0, Qt.ItemDataRole.UserRole, {"path": str(path), "type": "folder"})

        # Folder type for styling
        folder_name = path.name.lower()
        if folder_name == "assets":
            item.setText(0, "üìÅ Assets")
        elif folder_name == "scripts":
            item.setText(0, "üìÅ Scripts")
        elif folder_name == "flows":
            item.setText(0, "üìÅ Flows")
        else:
            item.setText(0, f"üìÅ {path.name}")

        return item

    def _create_file_item(self, path: Path) -> QTreeWidgetItem | None:
        """Create a tree item for a file."""
        suffix = path.suffix.lower()

        if suffix == ".dsl":
            item = QTreeWidgetItem([f"üìÑ {path.name}"])
            item.setData(0, Qt.ItemDataRole.UserRole, {"path": str(path), "type": "script"})
        elif suffix in (".yaml", ".yml"):
            item = QTreeWidgetItem([f"üìã {path.name}"])
            item.setData(0, Qt.ItemDataRole.UserRole, {"path": str(path), "type": "yaml"})
        elif suffix in (".png", ".jpg", ".jpeg", ".bmp"):
            item = QTreeWidgetItem([f"üñºÔ∏è {path.name}"])
            item.setData(0, Qt.ItemDataRole.UserRole, {"path": str(path), "type": "asset"})
        else:
            item = QTreeWidgetItem([f"üìÑ {path.name}"])
            item.setData(0, Qt.ItemDataRole.UserRole, {"path": str(path), "type": "file"})

        return item

    def refresh(self) -> None:
        """Refresh the project tree."""
        if self._project_path:
            self.load_project(self._project_path)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Event Handlers
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _on_item_double_clicked(self, item: QTreeWidgetItem, column: int) -> None:
        """Handle double-click on item."""
        data = item.data(0, Qt.ItemDataRole.UserRole)
        if data and data["type"] != "folder":
            self.file_opened.emit(data["path"], data["type"])

    def _show_context_menu(self, pos) -> None:  # type: ignore
        """Show context menu for selected item."""
        item = self.tree.itemAt(pos)

        menu = QMenu(self)

        if item:
            data = item.data(0, Qt.ItemDataRole.UserRole)

            if data["type"] == "folder":
                new_script = menu.addAction("New Script (.dsl)")
                new_script.triggered.connect(lambda: self._create_new_file(data["path"], "script"))

                new_yaml = menu.addAction("New YAML (.yaml)")
                new_yaml.triggered.connect(lambda: self._create_new_file(data["path"], "yaml"))

                menu.addSeparator()

            if data["type"] != "folder":
                delete_action = menu.addAction("Delete")
                delete_action.triggered.connect(lambda: self._delete_file(data["path"]))

                menu.addSeparator()

        refresh_action = menu.addAction("Refresh")
        refresh_action.triggered.connect(self.refresh)

        menu.exec(self.tree.mapToGlobal(pos))

    def _create_new_file(self, folder_path: str, file_type: str) -> None:
        """Create a new file in the folder."""
        ext = ".dsl" if file_type == "script" else ".yaml"
        name, ok = QInputDialog.getText(
            self, f"New {file_type.title()}", f"File name (without {ext}):"
        )

        if ok and name:
            path = Path(folder_path) / f"{name}{ext}"
            if path.exists():
                QMessageBox.warning(self, "Error", f"File '{path.name}' already exists.")
                return

            # Create file with template
            if file_type == "script":
                content = (
                    f"// {name}.dsl\n\nflow main {{\n  // TODO: Add your automation here\n}}\n"
                )
            else:
                content = f"# {name}.yaml\n\nname: {name}\nflows: []\n"

            path.write_text(content, encoding="utf-8")
            self.refresh()
            self.file_created.emit(str(path), file_type)

    def _delete_file(self, file_path: str) -> None:
        """Delete a file after confirmation."""
        path = Path(file_path)

        reply = QMessageBox.question(
            self,
            "Confirm Delete",
            f"Delete '{path.name}'?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            try:
                path.unlink()
                self.refresh()
                self.file_deleted.emit(file_path)
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Could not delete file: {e}")


================================================================================
FILE PATH: app\ui\properties_panel.py
LINES: 541
================================================================================

"""
RetroAuto v2 - Properties Panel

Dynamic form for editing action properties.
"""

from PySide6.QtCore import Signal
from PySide6.QtWidgets import (
    QCheckBox,
    QComboBox,
    QDoubleSpinBox,
    QFormLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QPushButton,
    QSpinBox,
    QVBoxLayout,
    QWidget,
)

from core.models import (
    ROI,
    Click,
    ClickImage,
    ClickRandom,  # Add import
    ClickUntil,
    Delay,
    Goto,
    Hotkey,
    IfImage,
    IfText,
    InterruptRule,  # Add import
    Label,
    Loop,
    Notify,
    NotifyMethod,
    ReadText,
    RunFlow,
    TypeText,
    WaitImage,
    WhileImage,
)
from infra import get_logger

logger = get_logger("PropertiesPanel")


class PropertiesPanel(QWidget):
    """
    Panel for editing action properties.

    Dynamically generates form fields based on action type.
    """

    properties_changed = Signal(dict)  # Updated action data

    def __init__(self) -> None:
        super().__init__()
        self._current_data: dict | None = None
        self._fields: dict = {}
        self._init_ui()

    def _init_ui(self) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(4, 4, 4, 4)

        # Group box
        self.group = QGroupBox("Properties")
        self.form_layout = QFormLayout(self.group)

        # Placeholder
        self.placeholder = QLabel("Select an action to edit")
        self.form_layout.addRow(self.placeholder)

        layout.addWidget(self.group)
        layout.addStretch()

    def load_action(self, data: dict) -> None:
        """Load action data into form."""
        self._current_data = data.copy()
        self._rebuild_form()

    def _rebuild_form(self) -> None:
        """Rebuild form fields based on action type."""
        # Clear existing
        while self.form_layout.count():
            item = self.form_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self._fields.clear()

        if not self._current_data:
            self.placeholder = QLabel("Select an action to edit")
            self.form_layout.addRow(self.placeholder)
            return

        action = self._current_data.get("action")
        if not action:
            return

        action_type = type(action).__name__

        # Title
        self.form_layout.addRow(QLabel(f"<b>{action_type}</b>"))

        # Build fields based on type
        if isinstance(action, ClickImage):
            self._add_text_field("asset_id", action.asset_id)
            self._add_combo_field("button", action.button, ["left", "right", "middle"])
            self._add_spin_field("clicks", action.clicks, 1, 3)
            self._add_spin_field("interval_ms", action.interval_ms, 0, 1000)
            self._add_spin_field("timeout_ms", action.timeout_ms, 0, 60000)
            # Advanced options (collapsible)
            self._add_collapsible_section(
                "‚ñ∏ Advanced",
                [
                    ("offset_x", action.offset_x, -500, 500),
                    ("offset_y", action.offset_y, -500, 500),
                ],
            )

        elif isinstance(action, ClickUntil):
            self._add_text_field("click_asset_id", action.click_asset_id)
            self._add_text_field("until_asset_id", action.until_asset_id)
            self._add_bool_field("until_appear", action.until_appear)
            self._add_combo_field("button", action.button, ["left", "right", "middle"])
            self._add_spin_field("click_interval_ms", action.click_interval_ms, 100, 10000)
            self._add_spin_field("timeout_ms", action.timeout_ms, 0, 300000)
            self._add_spin_field("max_clicks", action.max_clicks, 1, 1000)

        elif isinstance(action, WaitImage):
            self._add_text_field("asset_id", action.asset_id)
            self._add_bool_field("appear", action.appear)
            self._add_spin_field("timeout_ms", action.timeout_ms, 0, 300000)
            self._add_spin_field("poll_ms", action.poll_ms, 10, 5000)

        elif isinstance(action, Click):
            self._add_spin_field("x", action.x or 0, 0, 9999)
            self._add_spin_field("y", action.y or 0, 0, 9999)
            self._add_combo_field("button", action.button, ["left", "right", "middle"])
            self._add_spin_field("clicks", action.clicks, 1, 3)
            self._add_spin_field("interval_ms", action.interval_ms, 0, 1000)
            self._add_bool_field("use_match", action.use_match)

        elif isinstance(action, IfImage):
            self._add_text_field("asset_id", action.asset_id)
            self._add_label("(then/else actions edited separately)")

        elif isinstance(action, IfText):
            self._add_text_field("variable_name", action.variable_name)
            self._add_combo_field(
                "operator",
                action.operator,
                ["contains", "equals", "starts_with", "ends_with", "numeric_lt", "numeric_gt"],
            )
            self._add_text_field("value", action.value)
            self._add_label("(then/else actions edited separately)")

        elif isinstance(action, Hotkey):
            keys_str = "+".join(action.keys) if action.keys else ""
            self._add_text_field("keys", keys_str)
            self._add_label("(e.g., CTRL+S, ALT+F4)")

        elif isinstance(action, TypeText):
            self._add_text_field("text", action.text)
            self._add_bool_field("paste_mode", action.paste_mode)
            self._add_bool_field("enter", action.enter)

        elif isinstance(action, Label):
            self._add_text_field("name", action.name)

        elif isinstance(action, Goto):
            self._add_text_field("label", action.label)

        elif isinstance(action, RunFlow):
            self._add_text_field("flow_name", action.flow_name)

        elif isinstance(action, ReadText):
            self._add_text_field("variable_name", action.variable_name)
            r = action.roi
            self._add_spin_field("roi_x", r.x, 0, 9999)
            self._add_spin_field("roi_y", r.y, 0, 9999)
            self._add_spin_field("roi_w", r.w, 1, 9999)
            self._add_spin_field("roi_h", r.h, 1, 9999)
            self._add_text_field("allowlist", action.allowlist)
            self._add_double_spin_field("scale", action.scale, 0.1, 10.0)
            self._add_bool_field("invert", action.invert)
            self._add_bool_field("binarize", action.binarize)

        elif isinstance(action, InterruptRule):
            # Trigger Type dropdown
            self._add_combo_field("trigger_type", action.trigger_type, ["image", "hotkey"])

            # Conditional fields based on trigger type
            if action.trigger_type == "hotkey":
                self._add_text_field("when_hotkey", action.when_hotkey or "")
                self._add_label("(e.g., f4, ctrl+f4, alt+a)")
            else:
                self._add_text_field("when_image", action.when_image or "")

            self._add_spin_field("priority", action.priority, 0, 100)
            self._add_text_field("run_flow", action.run_flow or "")

            # Add callback to rebuild on trigger type change
            trigger_combo = self._fields.get("trigger_type")
            if trigger_combo:
                trigger_combo.currentTextChanged.connect(self._on_trigger_type_changed)

        elif isinstance(action, ClickRandom):
            r = action.roi
            self._add_spin_field("roi_x", r.x, 0, 9999)
            self._add_spin_field("roi_y", r.y, 0, 9999)
            self._add_spin_field("roi_w", r.w, 1, 9999)
            self._add_spin_field("roi_h", r.h, 1, 9999)
            self._add_spin_field("clicks", action.clicks, 1, 10)
            self._add_spin_field("interval_ms", action.interval_ms, 0, 5000)
            self._add_combo_field("button", action.button, ["left", "right", "middle"])

        elif isinstance(action, Delay):
            self._add_spin_field("ms", action.ms, 0, 300000)

        elif isinstance(action, Notify):
            self._add_text_field("message", action.message)
            self._add_combo_field("method", action.method.value, [m.value for m in NotifyMethod])
            self._add_text_field("title", action.title)
            self._add_text_field("target", action.target)

        elif isinstance(action, Loop):
            # count: None = infinite, otherwise N times
            count_value = action.count if action.count is not None else 0
            self._add_spin_field("count", count_value, 0, 999999)
            self._add_label("(0 = infinite loop)")

        elif isinstance(action, WhileImage):
            self._add_text_field("asset_id", action.asset_id)
            self._add_bool_field("while_present", action.while_present)
            self._add_spin_field("max_iterations", action.max_iterations, 1, 100000)

        # Comment field (common to all)
        comment = getattr(action, "comment", "")
        self._add_text_field("comment", comment)

        # Apply button
        btn_apply = QPushButton("Apply")
        btn_apply.clicked.connect(self._on_apply)
        self.form_layout.addRow(btn_apply)

    def _add_text_field(self, name: str, value: str) -> None:
        field = QLineEdit(str(value))
        self._fields[name] = field
        self.form_layout.addRow(name.replace("_", " ").title() + ":", field)

    def _add_spin_field(self, name: str, value: int, min_val: int, max_val: int) -> None:
        field = QSpinBox()
        field.setRange(min_val, max_val)
        field.setValue(value)
        self._fields[name] = field
        self.form_layout.addRow(name.replace("_", " ").title() + ":", field)

    def _add_double_spin_field(
        self, name: str, value: float, min_val: float, max_val: float
    ) -> None:
        field = QDoubleSpinBox()
        field.setRange(min_val, max_val)
        field.setValue(value)
        field.setSingleStep(0.1)
        self._fields[name] = field
        self.form_layout.addRow(name.replace("_", " ").title() + ":", field)

    def _add_combo_field(self, name: str, value: str, options: list[str]) -> None:
        field = QComboBox()
        field.addItems(options)
        if value in options:
            field.setCurrentText(value)
        self._fields[name] = field
        self.form_layout.addRow(name.replace("_", " ").title() + ":", field)

    def _add_bool_field(self, name: str, value: bool) -> None:
        field = QCheckBox()
        field.setChecked(value)
        self._fields[name] = field
        self.form_layout.addRow(name.replace("_", " ").title() + ":", field)

    def _add_label(self, text: str) -> None:
        label = QLabel(text)
        label.setStyleSheet("color: gray; font-style: italic;")
        self.form_layout.addRow(label)

    def _add_collapsible_section(self, title: str, fields: list[tuple[str, int, int, int]]) -> None:
        """Add collapsible section with spin fields (hidden by default)."""
        # Toggle checkbox
        toggle = QCheckBox(title)
        toggle.setStyleSheet("color: #888; font-weight: bold;")
        self.form_layout.addRow(toggle)

        # Create hidden fields
        field_widgets = []
        for name, value, min_val, max_val in fields:
            field = QSpinBox()
            field.setRange(min_val, max_val)
            field.setValue(value)
            field.setVisible(False)
            self._fields[name] = field
            label = QLabel(name.replace("_", " ").title() + ":")
            label.setVisible(False)
            label.setStyleSheet("padding-left: 16px;")
            self.form_layout.addRow(label, field)
            field_widgets.append((label, field))

        # Toggle visibility
        def on_toggle(checked: bool) -> None:
            toggle.setText("‚ñæ Advanced" if checked else "‚ñ∏ Advanced")
            for label, field in field_widgets:
                label.setVisible(checked)
                field.setVisible(checked)

        toggle.toggled.connect(on_toggle)

    def _on_trigger_type_changed(self, new_type: str) -> None:
        """Handle trigger type change - rebuild form with new field."""
        if not self._current_data:
            return

        action = self._current_data.get("action")
        if not isinstance(action, InterruptRule):
            return

        # Update action with new trigger type and rebuild form
        updated = InterruptRule(
            trigger_type=new_type,
            when_image=action.when_image if new_type == "image" else None,
            when_hotkey=action.when_hotkey if new_type == "hotkey" else None,
            priority=action.priority,
            run_flow=action.run_flow,
            do_actions=action.do_actions,
        )
        self._current_data["action"] = updated
        self._rebuild_form()

    def _on_apply(self) -> None:
        """Apply changes to action."""
        if not self._current_data:
            return

        action = self._current_data.get("action")
        if not action:
            return

        # Build updated action based on type
        try:
            updated = self._build_updated_action(action)
            if updated:
                self._current_data["action"] = updated
                self.properties_changed.emit(self._current_data)
                logger.info("Applied changes to %s", type(action).__name__)
        except Exception as e:
            logger.error("Failed to apply: %s", e)

    def _build_updated_action(self, action):  # type: ignore
        """Build updated action from form fields."""
        if isinstance(action, ClickImage):
            return ClickImage(
                asset_id=self._fields["asset_id"].text(),
                button=self._fields["button"].currentText(),
                clicks=self._fields["clicks"].value(),
                timeout_ms=self._fields["timeout_ms"].value(),
                offset_x=self._fields["offset_x"].value(),
                offset_y=self._fields["offset_y"].value(),
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, ClickUntil):
            return ClickUntil(
                click_asset_id=self._fields["click_asset_id"].text(),
                until_asset_id=self._fields["until_asset_id"].text(),
                until_appear=self._fields["until_appear"].isChecked(),
                button=self._fields["button"].currentText(),
                click_interval_ms=self._fields["click_interval_ms"].value(),
                timeout_ms=self._fields["timeout_ms"].value(),
                max_clicks=self._fields["max_clicks"].value(),
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, WaitImage):
            return WaitImage(
                asset_id=self._fields["asset_id"].text(),
                appear=self._fields["appear"].isChecked(),
                timeout_ms=self._fields["timeout_ms"].value(),
                poll_ms=self._fields["poll_ms"].value(),
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, Click):
            return Click(
                x=self._fields["x"].value() or None,
                y=self._fields["y"].value() or None,
                button=self._fields["button"].currentText(),
                clicks=self._fields["clicks"].value(),
                use_match=self._fields["use_match"].isChecked(),
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, IfImage):
            return IfImage(
                asset_id=self._fields["asset_id"].text(),
                then_actions=action.then_actions,
                else_actions=action.else_actions,
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, IfText):
            return IfText(
                variable_name=self._fields["variable_name"].text(),
                operator=self._fields["operator"].currentText(),
                value=self._fields["value"].text(),
                then_actions=action.then_actions,
                else_actions=action.else_actions,
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, Hotkey):
            keys_str = self._fields["keys"].text()
            keys = [k.strip().upper() for k in keys_str.split("+") if k.strip()]
            return Hotkey(
                keys=keys,
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, TypeText):
            return TypeText(
                text=self._fields["text"].text(),
                paste_mode=self._fields["paste_mode"].isChecked(),
                enter=self._fields["enter"].isChecked(),
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, Label):
            return Label(
                name=self._fields["name"].text(),
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, Goto):
            return Goto(
                label=self._fields["label"].text(),
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, RunFlow):
            return RunFlow(
                flow_name=self._fields["flow_name"].text(),
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, ReadText):
            return ReadText(
                variable_name=self._fields["variable_name"].text(),
                roi=ROI(
                    x=self._fields["roi_x"].value(),
                    y=self._fields["roi_y"].value(),
                    w=self._fields["roi_w"].value(),
                    h=self._fields["roi_h"].value(),
                ),
                allowlist=self._fields["allowlist"].text(),
                scale=self._fields["scale"].value(),
                invert=self._fields["invert"].isChecked(),
                binarize=self._fields["binarize"].isChecked(),
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, InterruptRule):
            trigger_type = self._fields["trigger_type"].currentText()
            return InterruptRule(
                trigger_type=trigger_type,
                when_image=(
                    self._fields.get(
                        "when_image", lambda: type("", (), {"text": lambda self: None})()
                    ).text()
                    if "when_image" in self._fields
                    else None
                ),
                when_hotkey=(
                    self._fields.get(
                        "when_hotkey", lambda: type("", (), {"text": lambda self: None})()
                    ).text()
                    if "when_hotkey" in self._fields
                    else None
                ),
                priority=self._fields["priority"].value(),
                run_flow=self._fields["run_flow"].text() or None,
                do_actions=action.do_actions,  # Preserve existing
            )

        elif isinstance(action, ClickRandom):
            return ClickRandom(
                roi=ROI(
                    x=self._fields["roi_x"].value(),
                    y=self._fields["roi_y"].value(),
                    w=self._fields["roi_w"].value(),
                    h=self._fields["roi_h"].value(),
                ),
                clicks=self._fields["clicks"].value(),
                interval_ms=self._fields["interval_ms"].value(),
                button=self._fields["button"].currentText(),
                comment=self._fields["comment"].text(),
            )

            return Delay(
                ms=self._fields["ms"].value(),
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, Notify):
            return Notify(
                message=self._fields["message"].text(),
                method=NotifyMethod(self._fields["method"].currentText()),
                title=self._fields["title"].text(),
                target=self._fields["target"].text(),
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, Loop):
            count_val = self._fields["count"].value()
            return Loop(
                count=count_val if count_val > 0 else None,  # 0 = infinite
                actions=action.actions,  # Preserve existing nested actions
                comment=self._fields["comment"].text(),
            )

        elif isinstance(action, WhileImage):
            return WhileImage(
                asset_id=self._fields["asset_id"].text(),
                while_present=self._fields["while_present"].isChecked(),
                max_iterations=self._fields["max_iterations"].value(),
                actions=action.actions,  # Preserve existing nested actions
                comment=self._fields["comment"].text(),
            )

        return None


================================================================================
FILE PATH: app\ui\roi_editor.py
LINES: 260
================================================================================

"""
RetroAuto v2 - ROI Editor

Visual editor for adjusting Region of Interest on a screenshot.
"""

from PySide6.QtCore import QPoint, QRect, Qt, Signal
from PySide6.QtGui import QColor, QPainter, QPen, QPixmap
from PySide6.QtWidgets import (
    QDialog,
    QDialogButtonBox,
    QLabel,
    QVBoxLayout,
    QWidget,
)

from core.models import ROI
from infra import get_logger

logger = get_logger("ROIEditor")


class ROICanvas(QWidget):
    """
    Canvas for displaying image and editing ROI.

    Features:
    - Display screenshot/template
    - Draggable ROI rectangle
    - Resize handles on corners
    """

    roi_changed = Signal(QRect)

    HANDLE_SIZE = 8

    def __init__(self) -> None:
        super().__init__()
        self._pixmap: QPixmap | None = None
        self._roi: QRect = QRect(0, 0, 100, 100)
        self._dragging = False
        self._resizing = False
        self._resize_handle: str = ""
        self._drag_offset = QPoint()

        self.setMinimumSize(400, 300)
        self.setMouseTracking(True)

    def set_image(self, pixmap: QPixmap) -> None:
        """Set the background image."""
        self._pixmap = pixmap
        self.setFixedSize(pixmap.size())
        self.update()

    def set_roi(self, roi: ROI | None) -> None:
        """Set the ROI rectangle."""
        if roi:
            self._roi = QRect(roi.x, roi.y, roi.w, roi.h)
        else:
            # Default to center of image
            if self._pixmap:
                w, h = self._pixmap.width(), self._pixmap.height()
                self._roi = QRect(w // 4, h // 4, w // 2, h // 2)
        self.update()

    def get_roi(self) -> ROI:
        """Get current ROI."""
        return ROI(
            x=max(0, self._roi.x()),
            y=max(0, self._roi.y()),
            w=max(1, self._roi.width()),
            h=max(1, self._roi.height()),
        )

    def paintEvent(self, event) -> None:  # type: ignore
        """Draw image and ROI overlay."""
        painter = QPainter(self)

        # Draw image
        if self._pixmap:
            painter.drawPixmap(0, 0, self._pixmap)

        # Darken outside ROI
        dark = QColor(0, 0, 0, 100)
        roi = self._roi

        # Top
        painter.fillRect(0, 0, self.width(), roi.top(), dark)
        # Bottom
        painter.fillRect(0, roi.bottom(), self.width(), self.height() - roi.bottom(), dark)
        # Left
        painter.fillRect(0, roi.top(), roi.left(), roi.height(), dark)
        # Right
        painter.fillRect(roi.right(), roi.top(), self.width() - roi.right(), roi.height(), dark)

        # Draw ROI border
        pen = QPen(QColor(0, 200, 0), 2, Qt.PenStyle.SolidLine)
        painter.setPen(pen)
        painter.drawRect(roi)

        # Draw resize handles
        handles = self._get_handles()
        painter.setBrush(QColor(0, 200, 0))
        for _name, rect in handles.items():
            painter.drawRect(rect)

        # Size label
        painter.setPen(QPen(Qt.GlobalColor.white))
        painter.drawText(
            roi.bottomRight() + QPoint(-60, 15),
            f"{roi.width()} x {roi.height()}",
        )

    def _get_handles(self) -> dict[str, QRect]:
        """Get resize handle rectangles."""
        s = self.HANDLE_SIZE
        r = self._roi
        return {
            "tl": QRect(r.left() - s // 2, r.top() - s // 2, s, s),
            "tr": QRect(r.right() - s // 2, r.top() - s // 2, s, s),
            "bl": QRect(r.left() - s // 2, r.bottom() - s // 2, s, s),
            "br": QRect(r.right() - s // 2, r.bottom() - s // 2, s, s),
        }

    def _get_handle_at(self, pos: QPoint) -> str:
        """Check if position is on a handle."""
        for name, rect in self._get_handles().items():
            if rect.contains(pos):
                return name
        return ""

    def mousePressEvent(self, event) -> None:  # type: ignore
        """Handle mouse press."""
        if event.button() != Qt.MouseButton.LeftButton:
            return

        pos = event.pos()

        # Check handles first
        handle = self._get_handle_at(pos)
        if handle:
            self._resizing = True
            self._resize_handle = handle
            return

        # Check if inside ROI for dragging
        if self._roi.contains(pos):
            self._dragging = True
            self._drag_offset = pos - self._roi.topLeft()

    def mouseMoveEvent(self, event) -> None:  # type: ignore
        """Handle mouse move."""
        pos = event.pos()

        # Update cursor based on position
        handle = self._get_handle_at(pos)
        if handle in ("tl", "br"):
            self.setCursor(Qt.CursorShape.SizeFDiagCursor)
        elif handle in ("tr", "bl"):
            self.setCursor(Qt.CursorShape.SizeBDiagCursor)
        elif self._roi.contains(pos):
            self.setCursor(Qt.CursorShape.SizeAllCursor)
        else:
            self.setCursor(Qt.CursorShape.ArrowCursor)

        # Handle resize
        if self._resizing:
            self._do_resize(pos)
            self.update()
            return

        # Handle drag
        if self._dragging:
            new_pos = pos - self._drag_offset
            self._roi.moveTo(new_pos)
            self._clamp_roi()
            self.update()

    def mouseReleaseEvent(self, event) -> None:  # type: ignore
        """Handle mouse release."""
        if self._dragging or self._resizing:
            self._dragging = False
            self._resizing = False
            self._resize_handle = ""
            self.roi_changed.emit(self._roi)

    def _do_resize(self, pos: QPoint) -> None:
        """Resize ROI based on handle drag."""
        r = self._roi

        if self._resize_handle == "tl":
            r.setTopLeft(pos)
        elif self._resize_handle == "tr":
            r.setTopRight(pos)
        elif self._resize_handle == "bl":
            r.setBottomLeft(pos)
        elif self._resize_handle == "br":
            r.setBottomRight(pos)

        # Normalize and enforce minimum size
        self._roi = r.normalized()
        if self._roi.width() < 10:
            self._roi.setWidth(10)
        if self._roi.height() < 10:
            self._roi.setHeight(10)

        self._clamp_roi()

    def _clamp_roi(self) -> None:
        """Clamp ROI to image bounds."""
        if not self._pixmap:
            return

        # Clamp to image bounds
        if self._roi.left() < 0:
            self._roi.moveLeft(0)
        if self._roi.top() < 0:
            self._roi.moveTop(0)
        if self._roi.right() > self._pixmap.width():
            self._roi.moveRight(self._pixmap.width())
        if self._roi.bottom() > self._pixmap.height():
            self._roi.moveBottom(self._pixmap.height())


class ROIEditorDialog(QDialog):
    """
    Dialog for editing ROI on a screenshot.
    """

    def __init__(self, pixmap: QPixmap, roi: ROI | None = None, parent=None) -> None:  # type: ignore
        super().__init__(parent)
        self.setWindowTitle("Edit ROI")
        self.setModal(True)

        self._init_ui(pixmap, roi)

    def _init_ui(self, pixmap: QPixmap, roi: ROI | None) -> None:
        layout = QVBoxLayout(self)

        # Instructions
        label = QLabel("Drag to move, drag corners to resize")
        layout.addWidget(label)

        # Canvas
        self.canvas = ROICanvas()
        self.canvas.set_image(pixmap)
        self.canvas.set_roi(roi)
        layout.addWidget(self.canvas)

        # Buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def get_roi(self) -> ROI:
        """Get the edited ROI."""
        return self.canvas.get_roi()


================================================================================
FILE PATH: app\ui\roi_selector.py
LINES: 302
================================================================================

"""
RetroAuto v2 - ROI Selector

Screen region selector with overlay and drag selection.
Part of RetroScript Phase 14 - Visual Editor Components.
"""

from __future__ import annotations

from collections.abc import Callable
from dataclasses import dataclass

from PySide6.QtCore import QPoint, QRect, Qt, Signal
from PySide6.QtGui import QColor, QPainter, QPixmap
from PySide6.QtWidgets import QApplication, QLabel, QRubberBand, QWidget


@dataclass
class Region:
    """A selected screen region."""

    x: int
    y: int
    width: int
    height: int

    def to_tuple(self) -> tuple[int, int, int, int]:
        """Convert to (x, y, w, h) tuple."""
        return (self.x, self.y, self.width, self.height)

    def to_dict(self) -> dict[str, int]:
        """Convert to dictionary."""
        return {"x": self.x, "y": self.y, "width": self.width, "height": self.height}

    @property
    def center(self) -> tuple[int, int]:
        """Get center point."""
        return (self.x + self.width // 2, self.y + self.height // 2)


class ROISelector(QWidget):
    """Full-screen overlay for selecting a region of interest.

    Usage:
        def on_selected(region):
            print(f"Selected: {region.x}, {region.y}, {region.width}x{region.height}")

        selector = ROISelector()
        selector.region_selected.connect(on_selected)
        selector.start()
    """

    region_selected = Signal(Region)
    selection_cancelled = Signal()

    def __init__(self, parent: QWidget | None = None, parent_window: QWidget | None = None) -> None:
        super().__init__(parent)

        # Parent window to hide during capture
        self._parent_window = parent_window

        # Window setup
        self.setWindowFlags(
            Qt.WindowType.FramelessWindowHint
            | Qt.WindowType.WindowStaysOnTopHint
            | Qt.WindowType.Tool
        )
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setCursor(Qt.CursorShape.CrossCursor)

        # Selection state
        self._origin = QPoint()
        self._rubber_band: QRubberBand | None = None
        self._screenshot: QPixmap | None = None
        self._is_selecting = False

        # Style
        self._overlay_color = QColor(0, 0, 0, 100)
        self._border_color = QColor(0, 150, 255)
        self._info_bg = QColor(0, 0, 0, 180)
        self._info_fg = QColor(255, 255, 255)

    def start(self) -> None:
        """Start the region selection."""
        # Hide parent window before capturing screen
        if self._parent_window:
            self._parent_window.hide()
            QApplication.processEvents()  # Ensure window is fully hidden

        # Small delay to ensure window is hidden
        import time
        time.sleep(0.15)

        # Capture screen
        screen = QApplication.primaryScreen()
        if screen:
            self._screenshot = screen.grabWindow(0)
            self.setGeometry(screen.geometry())

        self.showFullScreen()
        self.activateWindow()
        self.raise_()

    def paintEvent(self, event) -> None:
        """Paint the overlay and selection."""
        painter = QPainter(self)

        # Draw screenshot as background
        if self._screenshot:
            painter.drawPixmap(0, 0, self._screenshot)

        # Draw semi-transparent overlay
        painter.fillRect(self.rect(), self._overlay_color)

        # Draw instructions
        painter.setPen(self._info_fg)
        painter.drawText(
            self.rect(),
            Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignHCenter,
            "\n\n Click and drag to select region | ESC to cancel",
        )

    def mousePressEvent(self, event) -> None:
        """Handle mouse press - start selection."""
        if event.button() == Qt.MouseButton.LeftButton:
            self._origin = event.position().toPoint()
            self._is_selecting = True

            if not self._rubber_band:
                self._rubber_band = QRubberBand(QRubberBand.Shape.Rectangle, self)

            self._rubber_band.setGeometry(QRect(self._origin, self._origin))
            self._rubber_band.show()

    def mouseMoveEvent(self, event) -> None:
        """Handle mouse move - update selection."""
        if self._is_selecting and self._rubber_band:
            rect = QRect(self._origin, event.position().toPoint()).normalized()
            self._rubber_band.setGeometry(rect)

    def mouseReleaseEvent(self, event) -> None:
        """Handle mouse release - finish selection."""
        if event.button() == Qt.MouseButton.LeftButton and self._is_selecting:
            self._is_selecting = False

            if self._rubber_band:
                rect = self._rubber_band.geometry()
                self._rubber_band.hide()

                # Only emit if selection is meaningful
                if rect.width() > 5 and rect.height() > 5:
                    region = Region(
                        x=rect.x(),
                        y=rect.y(),
                        width=rect.width(),
                        height=rect.height(),
                    )
                    self.region_selected.emit(region)

            # Restore parent window before closing
            self._restore_parent_window()
            self.close()

    def keyPressEvent(self, event) -> None:
        """Handle key press - ESC to cancel."""
        if event.key() == Qt.Key.Key_Escape:
            self.selection_cancelled.emit()
            # Restore parent window before closing
            self._restore_parent_window()
            self.close()

    def _restore_parent_window(self) -> None:
        """Restore the parent window after capture."""
        if self._parent_window:
            self._parent_window.show()
            self._parent_window.activateWindow()


class ROISelectorDialog:
    """Convenience wrapper for ROI selection with callback.

    Usage:
        def handle_region(region):
            print(f"Got region: {region}")

        ROISelectorDialog.select(handle_region)
    """

    _current_selector: ROISelector | None = None

    @classmethod
    def select(
        cls,
        callback: Callable[[Region], None] | None = None,
        on_cancel: Callable[[], None] | None = None,
    ) -> None:
        """Open ROI selector and call callback with result.

        Args:
            callback: Called with Region when selection is made
            on_cancel: Called when selection is cancelled
        """
        # Ensure Qt app exists
        app = QApplication.instance()
        if not app:
            app = QApplication([])

        cls._current_selector = ROISelector()

        if callback:
            cls._current_selector.region_selected.connect(callback)

        if on_cancel:
            cls._current_selector.selection_cancelled.connect(on_cancel)

        cls._current_selector.start()


class MiniROIPreview(QLabel):
    """Small preview widget showing a captured ROI.

    Usage:
        preview = MiniROIPreview()
        preview.set_region(Region(100, 100, 200, 150))
    """

    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.setMinimumSize(100, 75)
        self.setMaximumSize(300, 225)
        self.setStyleSheet(
            """
            QLabel {
                border: 2px solid #0096ff;
                border-radius: 4px;
                background: #1e1e1e;
            }
        """
        )
        self._region: Region | None = None

    def set_region(self, region: Region) -> None:
        """Set and display a region."""
        self._region = region
        self._capture_region()

    def _capture_region(self) -> None:
        """Capture and display the region."""
        if not self._region:
            return

        screen = QApplication.primaryScreen()
        if not screen:
            return

        pixmap = screen.grabWindow(
            0,
            self._region.x,
            self._region.y,
            self._region.width,
            self._region.height,
        )

        # Scale to fit
        scaled = pixmap.scaled(
            self.width() - 4,
            self.height() - 4,
            Qt.AspectRatioMode.KeepAspectRatio,
            Qt.TransformationMode.SmoothTransformation,
        )

        self.setPixmap(scaled)

    def get_region(self) -> Region | None:
        """Get the current region."""
        return self._region


def select_roi() -> Region | None:
    """Blocking function to select a ROI.

    Returns:
        Selected Region or None if cancelled
    """
    result: list[Region | None] = [None]

    def on_selected(region: Region) -> None:
        result[0] = region

    app = QApplication.instance()
    if not app:
        app = QApplication([])

    selector = ROISelector()
    selector.region_selected.connect(on_selected)
    selector.start()

    # Process events until closed
    while selector.isVisible():
        app.processEvents()

    return result[0]


================================================================================
FILE PATH: app\ui\structure_panel.py
LINES: 127
================================================================================

"""
RetroAuto v2 - Structure Panel (The Navigator)

Displays the outline of the script structure (Flows, Labels) for quick navigation.
"""

from __future__ import annotations

import re

from PySide6.QtCore import Qt, Signal
from PySide6.QtWidgets import (
    QAbstractItemView,
    QLineEdit,
    QTreeWidget,
    QTreeWidgetItem,
    QVBoxLayout,
    QWidget,
)


class StructurePanel(QWidget):
    """
    Panel showing script structure (Outline).
    """

    # Signal: Line number to scroll to (1-based)
    navigate_requested = Signal(int)

    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self._init_ui()

    def _init_ui(self) -> None:
        """Initialize UI components."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)

        # Search box
        self.search_box = QLineEdit()
        self.search_box.setPlaceholderText("Filter structure...")
        self.search_box.textChanged.connect(self._filter_items)
        layout.addWidget(self.search_box)

        # Tree Widget
        self.tree = QTreeWidget()
        self.tree.setHeaderHidden(True)
        self.tree.setIndentation(16)
        self.tree.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.tree.itemDoubleClicked.connect(self._on_item_double_clicked)

        # Style
        self.tree.setStyleSheet(
            """
            QTreeWidget {
                background-color: #1e1e1e;
                color: #d4d4d4;
                border: none;
            }
            QTreeWidget::item:hover {
                background-color: #2a2d2e;
            }
            QTreeWidget::item:selected {
                background-color: #094771;
            }
        """
        )

        layout.addWidget(self.tree)

    def refresh(self, code: str) -> None:
        """Parse code and update tree."""
        self.tree.clear()

        # Regex for structure items
        # @flow name:
        # #label

        lines = code.splitlines()

        root_flow = QTreeWidgetItem(self.tree)
        root_flow.setText(0, "Flows")
        root_flow.setExpanded(True)
        # Icon?

        current_flow_item = None

        for i, line in enumerate(lines):
            line = line.strip()
            line_num = i + 1

            if line.startswith("@"):
                # Flow definition: @flow_name:
                match = re.match(r"@(\w+):?", line)
                if match:
                    name = match.group(1)
                    item = QTreeWidgetItem(root_flow)
                    item.setText(0, f"@{name}")
                    item.setData(0, Qt.ItemDataRole.UserRole, line_num)
                    # item.setIcon(0, QIcon("...")) # TODO: Add icons
                    current_flow_item = item
                    root_flow.addChild(item)

            elif line.startswith("#"):
                # Label: #label_name
                # Attach to current flow or root if no flow
                parent = current_flow_item or root_flow
                item = QTreeWidgetItem(parent)
                item.setText(0, line)  # Keep the #
                item.setData(0, Qt.ItemDataRole.UserRole, line_num)
                # Indent labels visually strictly or just tree hierarchy?
                # Tree hierarchy is good.

        # If we have assets, maybe list them too?
        # For now, just flows and labels as requested.

    def _filter_items(self, text: str) -> None:
        """Filter tree items."""
        # TODO: Implement filtering logic
        pass

    def _on_item_double_clicked(self, item: QTreeWidgetItem, column: int) -> None:
        """Handle navigation."""
        line_num = item.data(0, Qt.ItemDataRole.UserRole)
        if line_num:
            self.navigate_requested.emit(line_num)


================================================================================
FILE PATH: app\ui\syntax_highlighter.py
LINES: 299
================================================================================

"""
RetroAuto v2 - DSL Syntax Highlighter

Syntax highlighting for the DSL code editor.
Uses QSyntaxHighlighter with Win95-compatible colors.
"""

from __future__ import annotations

from PySide6.QtGui import QColor, QFont, QSyntaxHighlighter, QTextCharFormat

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Syntax Colors (Win95-compatible, high-contrast)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class SyntaxColors:
    """Color definitions for syntax highlighting - DARK THEME."""

    KEYWORD = QColor("#569cd6")  # Light blue
    STRING = QColor("#ce9178")  # Orange/tan
    COMMENT = QColor("#6a9955")  # Green
    NUMBER = QColor("#b5cea8")  # Light green
    DURATION = QColor("#b5cea8")  # Light green (same as number)
    FUNCTION = QColor("#dcdcaa")  # Yellow
    BUILTIN = QColor("#4ec9b0")  # Cyan
    OPERATOR = QColor("#d4d4d4")  # Light gray
    ERROR = QColor("#f14c4c")  # Red
    # Phase 4: RetroScript specific
    VARIABLE = QColor("#9cdcfe")  # Light blue for $variables
    DECORATOR = QColor("#c586c0")  # Purple for @decorators


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Format Factory
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


def make_format(
    color: QColor,
    bold: bool = False,
    italic: bool = False,
) -> QTextCharFormat:
    """Create a QTextCharFormat with given style."""
    fmt = QTextCharFormat()
    fmt.setForeground(color)
    if bold:
        fmt.setFontWeight(QFont.Weight.Bold)
    if italic:
        fmt.setFontItalic(True)
    return fmt


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Keywords and Builtins
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

KEYWORDS = {
    # Core keywords
    "flow",
    "interrupt",
    "priority",
    "when",
    "image",
    "const",
    "let",
    "if",
    "elif",
    "else",
    "while",
    "for",
    "in",
    "label",
    "goto",
    "try",
    "catch",
    "break",
    "continue",
    "return",
    "hotkeys",
    "true",
    "false",
    "null",
    # Phase 1: RetroScript keywords
    "repeat",
    "retry",
    "times",
    "match",
    "and",
    "or",
    "not",
    "end",
    "def",
    # Phase 2: Testing & config
    "test",
    "mock",
    "assert",
    "permissions",
    "config",
    "meta",
    # Phase 3: Modules
    "import",
    "as",
}

BUILTINS = {
    # Core builtins
    "wait_image",
    "find_image",
    "image_exists",
    "wait_any",
    "move",
    "hotkey",
    "type_text",
    "run_flow",
    "log",
    "range",
    # Phase 1: RetroScript actions
    "find",
    "wait",
    "click",
    "type",
    "press",
    "sleep",
    "scroll",
    "drag",
    "run",
}


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Highlighter
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class DSLHighlighter(QSyntaxHighlighter):
    """
    Syntax highlighter for DSL code editor.

    Highlights:
    - Keywords (blue, bold)
    - Built-in functions (blue, italic)
    - Strings (dark red)
    - Comments (green)
    - Numbers and durations (purple)
    """

    def __init__(self, parent=None):  # type: ignore
        super().__init__(parent)
        self._init_formats()

    def _init_formats(self) -> None:
        """Initialize text formats for each syntax element."""
        self.formats = {
            "keyword": make_format(SyntaxColors.KEYWORD, bold=True),
            "builtin": make_format(SyntaxColors.BUILTIN, italic=True),
            "string": make_format(SyntaxColors.STRING),
            "comment": make_format(SyntaxColors.COMMENT, italic=True),
            "number": make_format(SyntaxColors.NUMBER),
            "duration": make_format(SyntaxColors.DURATION),
            "error": make_format(SyntaxColors.ERROR),
            # Phase 4: RetroScript specific
            "variable": make_format(SyntaxColors.VARIABLE, bold=True),
            "decorator": make_format(SyntaxColors.DECORATOR, bold=True),
        }

    def highlightBlock(self, text: str) -> None:
        """Highlight a single block of text."""
        # Handle multiline comments first
        self._highlight_multiline_comments(text)

        # Then do single-line highlighting
        self._highlight_line(text)

    def _highlight_line(self, text: str) -> None:
        """Highlight single line elements."""
        i = 0
        length = len(text)

        while i < length:
            char = text[i]

            # Skip if inside multiline comment
            if self.currentBlockState() == 1:
                if text[i : i + 2] == "*/":
                    self.setFormat(i, 2, self.formats["comment"])
                    self.setCurrentBlockState(0)
                    i += 2
                else:
                    self.setFormat(i, 1, self.formats["comment"])
                    i += 1
                continue

            # Line comment (// style)
            if text[i : i + 2] == "//":
                self.setFormat(i, length - i, self.formats["comment"])
                return

            # RetroScript: # line comment
            if char == "#":
                self.setFormat(i, length - i, self.formats["comment"])
                return

            # RetroScript: $variable highlighting
            if char == "$":
                start = i
                i += 1
                while i < length and (text[i].isalnum() or text[i] == "_"):
                    i += 1
                self.setFormat(start, i - start, self.formats["variable"])
                continue

            # RetroScript: @decorator highlighting
            if char == "@":
                start = i
                i += 1
                while i < length and (text[i].isalnum() or text[i] == "_"):
                    i += 1
                self.setFormat(start, i - start, self.formats["decorator"])
                continue

            # Block comment start
            if text[i : i + 2] == "/*":
                start = i
                i += 2
                while i < length and text[i : i + 2] != "*/":
                    i += 1
                if i < length:
                    self.setFormat(start, i - start + 2, self.formats["comment"])
                    i += 2
                else:
                    self.setFormat(start, length - start, self.formats["comment"])
                    self.setCurrentBlockState(1)
                continue

            # Strings
            if char in "\"'":
                quote = char
                start = i
                i += 1
                while i < length:
                    if text[i] == "\\":
                        i += 2  # Skip escape
                    elif text[i] == quote:
                        i += 1
                        break
                    else:
                        i += 1
                self.setFormat(start, i - start, self.formats["string"])
                continue

            # Numbers and durations
            if char.isdigit():
                start = i
                while i < length and (text[i].isdigit() or text[i] == "."):
                    i += 1
                # Check for duration suffix
                suffix_start = i
                while i < length and text[i].isalpha():
                    i += 1
                suffix = text[suffix_start:i].lower()
                if suffix in ("ms", "s", "m", "h"):
                    self.setFormat(start, i - start, self.formats["duration"])
                else:
                    i = suffix_start  # Rollback if not duration
                    self.setFormat(start, i - start, self.formats["number"])
                continue

            # Identifiers (keywords/builtins)
            if char.isalpha() or char == "_":
                start = i
                while i < length and (text[i].isalnum() or text[i] == "_"):
                    i += 1
                word = text[start:i].lower()

                if word in KEYWORDS:
                    self.setFormat(start, i - start, self.formats["keyword"])
                elif word in BUILTINS:
                    self.setFormat(start, i - start, self.formats["builtin"])
                continue

            i += 1

    def _highlight_multiline_comments(self, text: str) -> None:
        """Handle multiline comment state from previous block."""
        # Get state from previous block
        prev_state = self.previousBlockState()

        if prev_state == 1:  # Inside multiline comment
            # Look for end
            end_idx = text.find("*/")
            if end_idx >= 0:
                self.setFormat(0, end_idx + 2, self.formats["comment"])
                self.setCurrentBlockState(0)
            else:
                self.setFormat(0, len(text), self.formats["comment"])
                self.setCurrentBlockState(1)
        else:
            self.setCurrentBlockState(0)


================================================================================
FILE PATH: app\ui\variable_watch.py
LINES: 330
================================================================================

"""
RetroAuto v2 - Variable Watch

Live variable display and monitoring widget.
Part of RetroScript Phase 14 - Visual Editor Components.
"""

from __future__ import annotations

from collections.abc import Callable
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any

from PySide6.QtCore import Qt, QTimer, Signal
from PySide6.QtGui import QColor
from PySide6.QtWidgets import (
    QHBoxLayout,
    QHeaderView,
    QLabel,
    QLineEdit,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QVBoxLayout,
    QWidget,
)


@dataclass
class WatchedVariable:
    """A variable being watched."""

    name: str
    value: Any
    type_name: str
    last_updated: datetime = field(default_factory=datetime.now)
    history: list[tuple[datetime, Any]] = field(default_factory=list)


class VariableWatch(QWidget):
    """Live variable display widget.

    Usage:
        watch = VariableWatch()
        watch.set_variable("$count", 42)
        watch.set_variable("$name", "Player1")
    """

    variable_edited = Signal(str, object)  # name, new_value

    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self._variables: dict[str, WatchedVariable] = {}
        self._max_history = 50

        self._setup_ui()
        self._setup_timer()

    def _setup_ui(self) -> None:
        """Setup the UI components."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)

        # Header
        header = QLabel("üìä Variables")
        header.setStyleSheet("font-weight: bold; font-size: 14px; padding: 4px;")
        layout.addWidget(header)

        # Search bar
        search_layout = QHBoxLayout()
        self._search_input = QLineEdit()
        self._search_input.setPlaceholderText("Filter variables...")
        self._search_input.textChanged.connect(self._filter_variables)
        search_layout.addWidget(self._search_input)

        clear_btn = QPushButton("Clear")
        clear_btn.setMaximumWidth(60)
        clear_btn.clicked.connect(self.clear)
        search_layout.addWidget(clear_btn)

        layout.addLayout(search_layout)

        # Table
        self._table = QTableWidget()
        self._table.setColumnCount(3)
        self._table.setHorizontalHeaderLabels(["Name", "Value", "Type"])

        header = self._table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)

        self._table.setAlternatingRowColors(True)
        self._table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self._table.cellDoubleClicked.connect(self._on_cell_double_clicked)

        layout.addWidget(self._table)

        # Style
        self.setStyleSheet(
            """
            QTableWidget {
                border: 1px solid #3c3c3c;
                border-radius: 4px;
                background: #1e1e1e;
                gridline-color: #3c3c3c;
            }
            QTableWidget::item {
                padding: 4px 8px;
            }
            QTableWidget::item:selected {
                background: #264f78;
            }
            QHeaderView::section {
                background: #2d2d2d;
                border: none;
                padding: 6px;
            }
            QLineEdit {
                border: 1px solid #3c3c3c;
                border-radius: 4px;
                padding: 4px 8px;
                background: #2d2d2d;
            }
            QPushButton {
                border: 1px solid #3c3c3c;
                border-radius: 4px;
                padding: 4px 8px;
                background: #2d2d2d;
            }
            QPushButton:hover {
                background: #404040;
            }
        """
        )

    def _setup_timer(self) -> None:
        """Setup refresh timer."""
        self._timer = QTimer(self)
        self._timer.timeout.connect(self._refresh_display)
        self._timer.start(100)  # 10 FPS

    def set_variable(self, name: str, value: Any) -> None:
        """Set or update a variable."""
        type_name = type(value).__name__ if value is not None else "null"

        if name in self._variables:
            var = self._variables[name]
            # Record history
            var.history.append((var.last_updated, var.value))
            if len(var.history) > self._max_history:
                var.history.pop(0)
            # Update
            var.value = value
            var.type_name = type_name
            var.last_updated = datetime.now()
        else:
            self._variables[name] = WatchedVariable(
                name=name,
                value=value,
                type_name=type_name,
            )

        self._refresh_display()

    def set_variables(self, variables: dict[str, Any]) -> None:
        """Set multiple variables at once."""
        for name, value in variables.items():
            self.set_variable(name, value)

    def get_variable(self, name: str) -> Any:
        """Get a variable value."""
        if name in self._variables:
            return self._variables[name].value
        return None

    def remove_variable(self, name: str) -> None:
        """Remove a variable."""
        if name in self._variables:
            del self._variables[name]
            self._refresh_display()

    def clear(self) -> None:
        """Clear all variables."""
        self._variables.clear()
        self._refresh_display()

    def _refresh_display(self) -> None:
        """Refresh the table display."""
        filter_text = self._search_input.text().lower()

        # Filter variables
        filtered = [
            var
            for var in self._variables.values()
            if not filter_text or filter_text in var.name.lower()
        ]

        # Update table
        self._table.setRowCount(len(filtered))

        for row, var in enumerate(sorted(filtered, key=lambda v: v.name)):
            # Name
            name_item = QTableWidgetItem(var.name)
            name_item.setFlags(name_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
            name_item.setForeground(QColor("#9cdcfe"))  # Variable color
            self._table.setItem(row, 0, name_item)

            # Value
            value_str = self._format_value(var.value)
            value_item = QTableWidgetItem(value_str)
            value_item.setData(Qt.ItemDataRole.UserRole, var.name)

            # Color based on type
            if var.type_name == "str":
                value_item.setForeground(QColor("#ce9178"))
            elif var.type_name in ("int", "float"):
                value_item.setForeground(QColor("#b5cea8"))
            elif var.type_name == "bool":
                value_item.setForeground(QColor("#569cd6"))
            elif var.type_name == "null":
                value_item.setForeground(QColor("#808080"))

            self._table.setItem(row, 1, value_item)

            # Type
            type_item = QTableWidgetItem(var.type_name)
            type_item.setFlags(type_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
            type_item.setForeground(QColor("#4ec9b0"))
            self._table.setItem(row, 2, type_item)

    def _format_value(self, value: Any) -> str:
        """Format a value for display."""
        if value is None:
            return "null"
        if isinstance(value, str):
            if len(value) > 50:
                return f'"{value[:50]}..."'
            return f'"{value}"'
        if isinstance(value, bool):
            return str(value).lower()
        if isinstance(value, (list, tuple)):
            if len(value) > 5:
                return f"[{len(value)} items]"
            return str(value)
        if isinstance(value, dict):
            return f"{{{len(value)} keys}}"
        return str(value)

    def _filter_variables(self, text: str) -> None:
        """Filter displayed variables."""
        self._refresh_display()

    def _on_cell_double_clicked(self, row: int, col: int) -> None:
        """Handle double-click to edit value."""
        if col == 1:  # Value column
            item = self._table.item(row, col)
            if item:
                item.data(Qt.ItemDataRole.UserRole)
                # Enable editing
                item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)
                self._table.editItem(item)

    def get_history(self, name: str) -> list[tuple[datetime, Any]]:
        """Get value history for a variable."""
        if name in self._variables:
            return self._variables[name].history.copy()
        return []


class VariableWatchDock(QWidget):
    """Dockable variable watch widget with refresh controls.

    Usage:
        dock = VariableWatchDock()
        dock.watch.set_variable("$x", 100)
    """

    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(4, 4, 4, 4)

        # Controls
        controls = QHBoxLayout()

        self._auto_refresh = QPushButton("‚ü≥ Auto")
        self._auto_refresh.setCheckable(True)
        self._auto_refresh.setChecked(True)
        self._auto_refresh.clicked.connect(self._toggle_auto_refresh)
        controls.addWidget(self._auto_refresh)

        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self._on_refresh)
        controls.addWidget(refresh_btn)

        controls.addStretch()

        layout.addLayout(controls)

        # Watch widget
        self.watch = VariableWatch()
        layout.addWidget(self.watch)

        # External source
        self._source_callback: Callable[[], dict[str, Any]] | None = None

    def set_source(self, callback: Callable[[], dict[str, Any]]) -> None:
        """Set the source for variable data.

        Args:
            callback: Function that returns dict of variables
        """
        self._source_callback = callback

    def _toggle_auto_refresh(self) -> None:
        """Toggle auto-refresh."""
        if self._auto_refresh.isChecked():
            self.watch._timer.start(100)
        else:
            self.watch._timer.stop()

    def _on_refresh(self) -> None:
        """Manual refresh from source."""
        if self._source_callback:
            variables = self._source_callback()
            self.watch.set_variables(variables)


================================================================================
FILE PATH: app\ui\win95_style.py
LINES: 466
================================================================================

"""
RetroAuto v2 - Win95/98 Style

Qt stylesheet generator for classic Windows 95/98 appearance.

Colors and styling based on classic Windows:
- 3D raised/sunken borders
- Navy blue selection
- MS Sans Serif / Tahoma fonts
- No rounded corners, no transparency
"""

from __future__ import annotations

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Color Palette (Win95/98)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

COLORS = {
    # Background colors
    "window": "#C0C0C0",  # Window/ButtonFace/Menu background
    "window_dark": "#808080",  # Darker variant
    "window_text": "#000000",  # Text color
    # Selection
    "highlight": "#0078d4",  # Blue selection
    "highlight_text": "#FFFFFF",  # White text on selection
    # Borders (3D effect)
    "shadow_dark": "#3c3c3c",  # Dark border
    "shadow_light": "#555555",  # Light border
    "border": "#555555",  # Normal border
    # Disabled state
    "gray_text": "#808080",  # Disabled text
    # Editor - DARK THEME
    "editor_bg": "#1e1e1e",  # Dark editor background
    "gutter_bg": "#252526",  # Gutter background
    "line_number": "#858585",  # Line number color
    # Syntax highlighting - BRIGHT for dark background
    "keyword": "#569cd6",  # Light blue for keywords
    "string": "#ce9178",  # Orange/tan for strings
    "comment": "#6a9955",  # Green for comments
    "number": "#b5cea8",  # Light green for numbers
    "function": "#dcdcaa",  # Yellow for function names
}


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Font Settings
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

FONTS = {
    "ui": '"MS Sans Serif", "Tahoma", sans-serif',
    "ui_size": "8pt",
    "code": '"Courier New", "Consolas", monospace',
    "code_size": "10pt",
}


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Stylesheet Generator
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


def generate_stylesheet() -> str:
    """Generate complete Qt stylesheet for Win95/98 look."""

    return f"""
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   Win95/98 Classic Theme
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

/* Global */
* {{
    font-family: {FONTS["ui"]};
    font-size: {FONTS["ui_size"]};
}}

QWidget {{
    background-color: {COLORS["window"]};
    color: {COLORS["window_text"]};
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Main Window
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QMainWindow {{
    background-color: {COLORS["window"]};
}}

QMainWindow::separator {{
    background-color: {COLORS["window"]};
    width: 4px;
    height: 4px;
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Menu Bar
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QMenuBar {{
    background-color: {COLORS["window"]};
    border-bottom: 1px solid {COLORS["shadow_dark"]};
    padding: 2px;
}}

QMenuBar::item {{
    background-color: transparent;
    padding: 2px 8px;
}}

QMenuBar::item:selected {{
    background-color: {COLORS["highlight"]};
    color: {COLORS["highlight_text"]};
}}

QMenu {{
    background-color: {COLORS["window"]};
    border: 2px outset {COLORS["shadow_light"]};
}}

QMenu::item {{
    padding: 4px 20px;
}}

QMenu::item:selected {{
    background-color: {COLORS["highlight"]};
    color: {COLORS["highlight_text"]};
}}

QMenu::separator {{
    height: 1px;
    background-color: {COLORS["shadow_dark"]};
    margin: 4px 2px;
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Toolbar
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QToolBar {{
    background-color: {COLORS["window"]};
    border: none;
    padding: 2px;
    spacing: 2px;
}}

QToolBar::separator {{
    width: 8px;
    background-color: transparent;
}}

QToolButton {{
    background-color: {COLORS["window"]};
    border: 2px outset {COLORS["shadow_light"]};
    padding: 4px 8px;
    min-width: 20px;
}}

QToolButton:hover {{
    background-color: #D4D4D4;
}}

QToolButton:pressed {{
    border: 2px inset {COLORS["shadow_light"]};
    background-color: #B0B0B0;
}}

QToolButton:disabled {{
    color: {COLORS["gray_text"]};
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Buttons
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QPushButton {{
    background-color: {COLORS["window"]};
    border: 2px outset {COLORS["shadow_light"]};
    padding: 4px 12px;
    min-width: 60px;
}}

QPushButton:hover {{
    background-color: #D4D4D4;
}}

QPushButton:pressed {{
    border: 2px inset {COLORS["shadow_light"]};
    background-color: #B0B0B0;
}}

QPushButton:disabled {{
    color: {COLORS["gray_text"]};
}}

QPushButton:default {{
    border: 2px outset {COLORS["shadow_light"]};
    border-color: {COLORS["window_text"]};
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Group Box
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QGroupBox {{
    border: 2px groove {COLORS["shadow_light"]};
    margin-top: 8px;
    padding-top: 8px;
}}

QGroupBox::title {{
    subcontrol-origin: margin;
    subcontrol-position: top left;
    padding: 0 4px;
    background-color: {COLORS["window"]};
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Text Input
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QLineEdit, QTextEdit, QPlainTextEdit {{
    background-color: {COLORS["editor_bg"]};
    border: 2px inset {COLORS["shadow_dark"]};
    padding: 2px;
    selection-background-color: {COLORS["highlight"]};
    selection-color: {COLORS["highlight_text"]};
}}

QLineEdit:disabled, QTextEdit:disabled {{
    background-color: {COLORS["window"]};
    color: {COLORS["gray_text"]};
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Combo Box
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QComboBox {{
    background-color: {COLORS["editor_bg"]};
    border: 2px inset {COLORS["shadow_dark"]};
    padding: 2px 4px;
    min-height: 18px;
}}

QComboBox::drop-down {{
    border: none;
    width: 16px;
}}

QComboBox::down-arrow {{
    image: none;
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-top: 6px solid {COLORS["window_text"]};
}}

QComboBox QAbstractItemView {{
    background-color: {COLORS["editor_bg"]};
    border: 1px solid {COLORS["shadow_dark"]};
    selection-background-color: {COLORS["highlight"]};
    selection-color: {COLORS["highlight_text"]};
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Spin Box
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QSpinBox {{
    background-color: {COLORS["editor_bg"]};
    border: 2px inset {COLORS["shadow_dark"]};
    padding: 2px;
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Check Box
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QCheckBox {{
    spacing: 4px;
}}

QCheckBox::indicator {{
    width: 13px;
    height: 13px;
    border: 2px inset {COLORS["shadow_dark"]};
    background-color: {COLORS["editor_bg"]};
}}

QCheckBox::indicator:checked {{
    background-color: {COLORS["editor_bg"]};
    image: none;
}}

QCheckBox::indicator:checked::after {{
    content: "‚úì";
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   List Widget / Tree Widget
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QListWidget, QTreeWidget, QListView, QTreeView {{
    background-color: {COLORS["editor_bg"]};
    border: 2px inset {COLORS["shadow_dark"]};
    selection-background-color: {COLORS["highlight"]};
    selection-color: {COLORS["highlight_text"]};
}}

QListWidget::item, QTreeWidget::item {{
    padding: 2px;
    min-height: 18px;
}}

QListWidget::item:selected, QTreeWidget::item:selected {{
    background-color: {COLORS["highlight"]};
    color: {COLORS["highlight_text"]};
}}

QHeaderView::section {{
    background-color: {COLORS["window"]};
    border: 1px solid {COLORS["shadow_dark"]};
    border-bottom: 1px solid {COLORS["shadow_dark"]};
    padding: 2px 4px;
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Tab Widget
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QTabWidget::pane {{
    border: 2px inset {COLORS["shadow_dark"]};
    background-color: {COLORS["window"]};
}}

QTabBar::tab {{
    background-color: {COLORS["window"]};
    border: 2px outset {COLORS["shadow_light"]};
    border-bottom: none;
    padding: 4px 12px;
    margin-right: 2px;
}}

QTabBar::tab:selected {{
    background-color: {COLORS["window"]};
    border-bottom: 2px solid {COLORS["window"]};
    margin-bottom: -2px;
}}

QTabBar::tab:!selected {{
    background-color: {COLORS["window_dark"]};
    margin-top: 2px;
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Scroll Bar
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QScrollBar:vertical {{
    background-color: {COLORS["window"]};
    width: 16px;
    border: 1px solid {COLORS["shadow_dark"]};
}}

QScrollBar::handle:vertical {{
    background-color: {COLORS["window"]};
    border: 2px outset {COLORS["shadow_light"]};
    min-height: 20px;
}}

QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
    background-color: {COLORS["window"]};
    border: 2px outset {COLORS["shadow_light"]};
    height: 16px;
}}

QScrollBar:horizontal {{
    background-color: {COLORS["window"]};
    height: 16px;
    border: 1px solid {COLORS["shadow_dark"]};
}}

QScrollBar::handle:horizontal {{
    background-color: {COLORS["window"]};
    border: 2px outset {COLORS["shadow_light"]};
    min-width: 20px;
}}

QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{
    background-color: {COLORS["window"]};
    border: 2px outset {COLORS["shadow_light"]};
    width: 16px;
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Splitter
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QSplitter::handle {{
    background-color: {COLORS["window"]};
}}

QSplitter::handle:horizontal {{
    width: 4px;
}}

QSplitter::handle:vertical {{
    height: 4px;
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Status Bar
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QStatusBar {{
    background-color: {COLORS["window"]};
    border-top: 1px solid {COLORS["shadow_dark"]};
}}

QStatusBar::item {{
    border: none;
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Dialog
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QDialog {{
    background-color: {COLORS["window"]};
}}

QDialogButtonBox {{
    button-layout: 0;
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Progress Bar
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QProgressBar {{
    background-color: {COLORS["editor_bg"]};
    border: 2px inset {COLORS["shadow_dark"]};
    text-align: center;
}}

QProgressBar::chunk {{
    background-color: {COLORS["highlight"]};
}}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   Tooltip
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

QToolTip {{
    background-color: #FFFFE1;
    color: {COLORS["window_text"]};
    border: 1px solid {COLORS["window_text"]};
    padding: 2px;
}}
"""


def apply_win95_style(app) -> None:  # type: ignore
    """Apply Win95/98 style to a QApplication."""
    stylesheet = generate_stylesheet()
    app.setStyleSheet(stylesheet)


================================================================================
FILE PATH: core\__init__.py
LINES: 1
================================================================================

"""RetroAuto v2 - Core package."""


================================================================================
FILE PATH: core\models.py
LINES: 556
================================================================================

"""
RetroAuto v2 - Core Data Models

Pydantic v2 models with discriminated unions for type-safe actions.
"""

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Annotated, Literal

from pydantic import BaseModel, Field, field_validator

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Basic Types
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class ROI(BaseModel):
    """Region of Interest for image matching."""

    x: int = Field(ge=0, description="X coordinate")
    y: int = Field(ge=0, description="Y coordinate")
    w: int = Field(gt=0, description="Width")
    h: int = Field(gt=0, description="Height")

    @property
    def center(self) -> tuple[int, int]:
        """Return center point of ROI."""
        return (self.x + self.w // 2, self.y + self.h // 2)

    def contains(self, x: int, y: int) -> bool:
        """Check if point is inside ROI."""
        return self.x <= x < self.x + self.w and self.y <= y < self.y + self.h


class MatchMethod(str, Enum):
    """OpenCV template matching methods."""

    TM_CCOEFF_NORMED = "TM_CCOEFF_NORMED"
    TM_CCORR_NORMED = "TM_CCORR_NORMED"
    TM_SQDIFF_NORMED = "TM_SQDIFF_NORMED"


class AssetImage(BaseModel):
    """Image template for matching."""

    id: str = Field(description="Unique asset identifier")
    path: str = Field(description="Relative path to image file")
    threshold: float = Field(default=0.8, ge=0.0, le=1.0)
    method: MatchMethod = Field(default=MatchMethod.TM_CCOEFF_NORMED)
    grayscale: bool = Field(default=True, description="Use grayscale matching")
    roi: ROI | None = Field(default=None, description="Default search region")

    @field_validator("path")
    @classmethod
    def validate_path(cls, v: str) -> str:
        """Ensure path uses forward slashes."""
        return v.replace("\\", "/")


class Match(BaseModel):
    """Result of a successful template match."""

    x: int
    y: int
    w: int
    h: int
    confidence: float = Field(ge=0.0, le=1.0)
    timestamp: datetime = Field(default_factory=datetime.now)

    @property
    def center(self) -> tuple[int, int]:
        """Return center point of match."""
        return (self.x + self.w // 2, self.y + self.h // 2)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Actions (Discriminated Union)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class ActionBase(BaseModel):
    """Base class for all actions."""

    comment: str = Field(default="", description="Optional comment")


class WaitImage(ActionBase):
    """Wait for image to appear or vanish."""

    action: Literal["WaitImage"] = "WaitImage"
    asset_id: str = Field(description="Asset to wait for")
    appear: bool = Field(default=True, description="True=appear, False=vanish")
    timeout_ms: int = Field(default=10000, ge=0, le=300000, description="Timeout in ms (max 5 min)")
    poll_ms: int = Field(default=100, ge=10)
    smart_wait: bool = Field(default=True, description="Enable adaptive thresholding")
    roi_override: ROI | None = Field(default=None)


class Click(ActionBase):
    """Click at coordinates or last found image."""

    action: Literal["Click"] = "Click"
    x: int | None = Field(default=None, description="X coordinate (None = use last match)")
    y: int | None = Field(default=None, description="Y coordinate (None = use last match)")
    button: Literal["left", "right", "middle"] = Field(default="left")
    clicks: int = Field(
        default=1, ge=1, le=3, description="Number of clicks (1=single, 2=double, 3=triple)"
    )
    interval_ms: int = Field(default=100, ge=0, description="Interval between clicks in ms")
    use_match: bool = Field(default=False, description="Click at last match center")


class ClickImage(ActionBase):
    """Wait for image then click."""

    action: Literal["ClickImage"] = "ClickImage"
    asset_id: str = Field(description="Asset to click")
    button: Literal["left", "right", "middle"] = Field(default="left")
    clicks: int = Field(
        default=1, ge=1, le=3, description="Number of clicks (1=single, 2=double, 3=triple)"
    )
    timeout_ms: int = Field(default=10000, ge=0, le=300000)
    offset_x: int = Field(default=0)
    offset_y: int = Field(default=0)
    smart_wait: bool = Field(default=True, description="Enable adaptive thresholding")
    interval_ms: int = Field(default=100, ge=0, description="Interval between clicks in ms")


class ClickUntil(ActionBase):
    """Click repeatedly until target image appears/vanishes (farming loop)."""

    action: Literal["ClickUntil"] = "ClickUntil"
    click_asset_id: str = Field(description="Asset to click")
    until_asset_id: str = Field(description="Target asset to check")
    until_appear: bool = Field(default=True, description="True=until appears, False=until vanishes")
    button: Literal["left", "right", "middle"] = Field(default="left")
    click_interval_ms: int = Field(default=1000, ge=100)
    timeout_ms: int = Field(default=30000, ge=0)
    max_clicks: int = Field(default=50, ge=1, description="Safety limit")


class ClickRandom(ActionBase):
    """Click randomly within a region (Anti-ban)."""

    action: Literal["ClickRandom"] = "ClickRandom"
    roi: ROI = Field(description="Region to click in")
    clicks: int = Field(default=1, ge=1, le=10)
    interval_ms: int = Field(default=100, ge=0)
    button: Literal["left", "right", "middle"] = Field(default="left")


class ReadText(ActionBase):
    """Read text from screen region using OCR."""

    action: Literal["ReadText"] = "ReadText"
    variable_name: str = Field(description="Variable to store the result")
    roi: ROI = Field(description="Region to read")
    allowlist: str = Field(default="", description="Whitelist of characters (e.g. '0123456789')")
    scale: float = Field(default=1.0, description="Image scale factor", ge=0.1, le=10.0)
    invert: bool = Field(default=False, description="Invert colors")
    binarize: bool = Field(default=False, description="Apply thresholding")


class IfText(ActionBase):
    """Conditional branch based on text variable value."""

    action: Literal["IfText"] = "IfText"
    variable_name: str = Field(description="Variable to check (e.g. $hp)")
    operator: Literal[
        "contains", "equals", "starts_with", "ends_with", "numeric_lt", "numeric_gt"
    ] = "contains"
    value: str = Field(description="Value to compare against")
    then_actions: list[Action] = Field(default_factory=list)
    else_actions: list[Action] = Field(default_factory=list)


class IfImage(ActionBase):
    """Conditional branch based on image presence."""

    action: Literal["IfImage"] = "IfImage"
    asset_id: str = Field(description="Asset to check")
    then_actions: list[Action] = Field(default_factory=list)
    else_actions: list[Action] = Field(default_factory=list)
    roi_override: ROI | None = Field(default=None)


class Else(ActionBase):
    """Marks start of else block in IfImage (for GUI flat list)."""

    action: Literal["Else"] = "Else"


class EndIf(ActionBase):
    """Marks end of IfImage block (for GUI flat list)."""

    action: Literal["EndIf"] = "EndIf"


class IfNotImage(ActionBase):
    """Conditional branch when image is NOT present.

    Use case: If image is NOT found in ROI, execute actions.
    Inverse of IfImage - useful for "else" logic without nesting.
    """

    action: Literal["IfNotImage"] = "IfNotImage"
    asset_id: str = Field(description="Asset to check (action runs if NOT found)")
    then_actions: list[Action] = Field(default_factory=list)
    roi_override: ROI | None = Field(default=None)


class IfAllImages(ActionBase):
    """AND logic - all images must be present.

    Use case: Execute actions only when ALL specified images are found.
    Supports else_actions for when any image is missing.
    """

    action: Literal["IfAllImages"] = "IfAllImages"
    asset_ids: list[str] = Field(default_factory=list, description="All must be found")
    then_actions: list[Action] = Field(default_factory=list)
    else_actions: list[Action] = Field(default_factory=list)


class IfAnyImage(ActionBase):
    """OR logic - at least one image must be present.

    Use case: Execute actions when ANY of the specified images is found.
    Supports else_actions for when no images are found.
    """

    action: Literal["IfAnyImage"] = "IfAnyImage"
    asset_ids: list[str] = Field(default_factory=list, description="At least one must be found")
    then_actions: list[Action] = Field(default_factory=list)
    else_actions: list[Action] = Field(default_factory=list)


class Hotkey(ActionBase):
    """Press hotkey combination."""

    action: Literal["Hotkey"] = "Hotkey"
    keys: list[str] = Field(description="Keys to press, e.g. ['CTRL', 'S']")


class TypeText(ActionBase):
    """Type text using keyboard."""

    action: Literal["TypeText"] = "TypeText"
    text: str = Field(description="Text to type")
    paste_mode: bool = Field(default=True, description="Use clipboard paste")
    enter: bool = Field(default=False, description="Press Enter after text")


class Label(ActionBase):
    """Mark a position for Goto."""

    action: Literal["Label"] = "Label"
    name: str = Field(description="Label name")


class Goto(ActionBase):
    """Jump to a label."""

    action: Literal["Goto"] = "Goto"
    label: str = Field(description="Target label name")


class RunFlow(ActionBase):
    """Execute another flow."""

    action: Literal["RunFlow"] = "RunFlow"
    flow_name: str = Field(description="Name of flow to run")


class Delay(ActionBase):
    """Wait for specified duration."""

    action: Literal["Delay"] = "Delay"
    ms: int = Field(default=1000, ge=0, description="Delay in milliseconds")


class DelayRandom(ActionBase):
    """Wait for random duration between min and max."""

    action: Literal["DelayRandom"] = "DelayRandom"
    min_ms: int = Field(default=500, ge=0, description="Minimum delay")
    max_ms: int = Field(default=1500, ge=0, description="Maximum delay")


class Drag(ActionBase):
    """Drag from one position to another."""

    action: Literal["Drag"] = "Drag"
    from_x: int = Field(description="Start X coordinate")
    from_y: int = Field(description="Start Y coordinate")
    to_x: int = Field(description="End X coordinate")
    to_y: int = Field(description="End Y coordinate")
    duration_ms: int = Field(default=500, ge=0, description="Drag duration")
    button: Literal["left", "right", "middle"] = Field(default="left")


class Scroll(ActionBase):
    """Scroll mouse wheel."""

    action: Literal["Scroll"] = "Scroll"
    x: int | None = Field(default=None, description="X position (None=current)")
    y: int | None = Field(default=None, description="Y position (None=current)")
    amount: int = Field(default=3, description="Scroll amount (positive=up, negative=down)")


class Loop(ActionBase):
    """Repeat actions N times or infinitely."""

    action: Literal["Loop"] = "Loop"
    count: int | None = Field(default=None, description="Times to repeat (None=infinite)")
    actions: list[Action] = Field(default_factory=list)


class WhileImage(ActionBase):
    """Repeat actions while image is present/absent."""

    action: Literal["WhileImage"] = "WhileImage"
    asset_id: str = Field(description="Asset to check")
    while_present: bool = Field(default=True, description="True=while exists")
    actions: list[Action] = Field(default_factory=list)
    max_iterations: int = Field(default=100, description="Safety limit")
    roi_override: ROI | None = Field(default=None)


class EndLoop(ActionBase):
    """Marks end of Loop block (for GUI flat list)."""

    action: Literal["EndLoop"] = "EndLoop"


class EndWhile(ActionBase):
    """Marks end of WhileImage block (for GUI flat list)."""

    action: Literal["EndWhile"] = "EndWhile"


class PixelColor(BaseModel):
    """RGB color for pixel checking."""

    r: int = Field(ge=0, le=255)
    g: int = Field(ge=0, le=255)
    b: int = Field(ge=0, le=255)
    tolerance: int = Field(default=10, ge=0, le=255, description="Color tolerance")

    def matches(self, other_r: int, other_g: int, other_b: int) -> bool:
        """Check if another color matches within tolerance."""
        return (
            abs(self.r - other_r) <= self.tolerance
            and abs(self.g - other_g) <= self.tolerance
            and abs(self.b - other_b) <= self.tolerance
        )


class WaitPixel(ActionBase):
    """Wait for pixel color at position."""

    action: Literal["WaitPixel"] = "WaitPixel"
    x: int = Field(description="X coordinate")
    y: int = Field(description="Y coordinate")
    color: PixelColor = Field(description="Expected color")
    appear: bool = Field(default=True, description="True=wait for color, False=wait until gone")
    timeout_ms: int = Field(default=10000, ge=0)
    poll_ms: int = Field(default=100, ge=10)


class IfPixel(ActionBase):
    """Conditional branch based on pixel color."""

    action: Literal["IfPixel"] = "IfPixel"
    x: int = Field(description="X coordinate")
    y: int = Field(description="Y coordinate")
    color: PixelColor = Field(description="Color to check")
    then_actions: list[Action] = Field(default_factory=list)
    else_actions: list[Action] = Field(default_factory=list)


class NotifyMethod(str, Enum):
    """Notification methods."""

    POPUP = "popup"
    TELEGRAM = "telegram"
    DISCORD = "discord"


class Notify(ActionBase):
    """Send a notification."""

    action: Literal["Notify"] = "Notify"
    message: str = Field(description="Message to send")
    method: NotifyMethod = Field(default=NotifyMethod.POPUP)
    title: str = Field(default="Notification", description="Title (for popup/email)")
    target: str = Field(default="", description="Webhook URL or User ID")


# Discriminated union type
Action = Annotated[
    WaitImage
    | Click
    | ClickImage
    | IfImage
    | IfNotImage
    | IfAllImages
    | IfAnyImage
    | Hotkey
    | TypeText
    | Label
    | Goto
    | RunFlow
    | Delay
    | DelayRandom
    | Drag
    | Scroll
    | Loop
    | WhileImage
    | WaitPixel
    | IfPixel
    | ClickRandom
    | ReadText
    | IfText
    | Notify,
    Field(discriminator="action"),
]


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Flow & Script
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class GraphNode(BaseModel):
    """Node in visual graph editor."""

    id: str = Field(description="Unique node ID (UUID)")
    action: Action = Field(description="The action this node executes")
    x: float = Field(default=0, description="X position on canvas")
    y: float = Field(default=0, description="Y position on canvas")


class GraphConnection(BaseModel):
    """Connection between two nodes in the graph."""

    from_node: str = Field(description="Source node ID")
    from_socket: str = Field(description="Source socket name (e.g., 'exec_out')")
    to_node: str = Field(description="Target node ID")
    to_socket: str = Field(description="Target socket name (e.g., 'exec_in')")


class FlowGraph(BaseModel):
    """Visual graph representation of a flow."""

    nodes: list[GraphNode] = Field(default_factory=list)
    connections: list[GraphConnection] = Field(default_factory=list)


class Flow(BaseModel):
    """A named sequence of actions."""

    name: str = Field(description="Flow name")
    actions: list[Action] = Field(default_factory=list)
    graph: FlowGraph | None = Field(default=None, description="Visual graph representation")


class InterruptRule(BaseModel):
    """Global interrupt that triggers on image detection OR hotkey press."""

    priority: int = Field(default=0, description="Higher = checked first")

    # Trigger type: 'image' (default) or 'hotkey'
    trigger_type: Literal["image", "hotkey"] = Field(default="image")

    # Image trigger (used when trigger_type == 'image')
    when_image: str | None = Field(default=None, description="Asset ID to watch for")
    roi_override: ROI | None = Field(default=None)

    # Hotkey trigger (used when trigger_type == 'hotkey')
    when_hotkey: str | None = Field(default=None, description="Hotkey combo, e.g. 'f4', 'ctrl+f4'")

    # Actions to perform
    do_actions: list[Action] = Field(default_factory=list)
    run_flow: str | None = Field(default=None, description="Or run this flow")


class ScriptHotkeys(BaseModel):
    """Hotkey bindings for script control."""

    start: str = Field(default="F5")
    stop: str = Field(default="F6")
    pause: str = Field(default="F7")


class Script(BaseModel):
    """Complete automation script."""

    name: str = Field(default="Untitled")
    version: str = Field(default="1.0")
    author: str = Field(default="")
    description: str = Field(default="")

    hotkeys: ScriptHotkeys = Field(default_factory=ScriptHotkeys)
    assets: list[AssetImage] = Field(default_factory=list)
    flows: list[Flow] = Field(default_factory=list)
    interrupts: list[InterruptRule] = Field(default_factory=list)

    # Main flow to run
    main_flow: str = Field(default="main")

    def get_asset(self, asset_id: str) -> AssetImage | None:
        """Get asset by ID."""
        return next((a for a in self.assets if a.id == asset_id), None)

    def get_flow(self, name: str) -> Flow | None:
        """Get flow by name."""
        return next((f for f in self.flows if f.name == name), None)

    def validate_references(self) -> list[str]:
        """Validate all asset/flow references. Returns list of errors."""
        errors: list[str] = []
        asset_ids = {a.id for a in self.assets}
        flow_names = {f.name for f in self.flows}

        def check_actions(actions: list[Action], context: str) -> None:
            for i, action in enumerate(actions):
                loc = f"{context}[{i}]"
                if isinstance(action, (WaitImage, IfImage)) and action.asset_id not in asset_ids:
                    errors.append(f"{loc}: Unknown asset '{action.asset_id}'")
                if isinstance(action, IfImage):
                    check_actions(action.then_actions, f"{loc}.then")
                    check_actions(action.else_actions, f"{loc}.else")
                if isinstance(action, RunFlow) and action.flow_name not in flow_names:
                    errors.append(f"{loc}: Unknown flow '{action.flow_name}'")
                if isinstance(action, Goto):
                    # Label validation would need full flow context
                    pass

        for flow in self.flows:
            check_actions(flow.actions, f"flow[{flow.name}]")

        for i, interrupt in enumerate(self.interrupts):
            if interrupt.when_image not in asset_ids:
                errors.append(f"interrupt[{i}]: Unknown asset '{interrupt.when_image}'")
            if interrupt.run_flow and interrupt.run_flow not in flow_names:
                errors.append(f"interrupt[{i}]: Unknown flow '{interrupt.run_flow}'")
            check_actions(interrupt.do_actions, f"interrupt[{i}].do")

        if self.main_flow not in flow_names and self.flows:
            errors.append(f"main_flow '{self.main_flow}' not found")

        return errors


================================================================================
FILE PATH: core\profile_manager.py
LINES: 289
================================================================================

"""
RetroAuto v2 - Game Profile Manager

Manage profiles with preset settings for different games/applications.
"""

from __future__ import annotations

import json
from dataclasses import asdict, dataclass, field
from pathlib import Path
from typing import Any

from infra import get_logger

logger = get_logger("ProfileManager")


@dataclass
class GameProfile:
    """
    Profile preset for a specific game/application.

    Contains default settings like:
    - Window title pattern
    - Default ROI
    - Threshold adjustments
    - Hotkey mappings
    - Custom variables
    """

    name: str
    description: str = ""

    # Target application
    window_title: str = ""
    process_name: str = ""

    # Vision settings
    default_threshold: float = 0.8
    grayscale: bool = True
    default_roi: dict[str, int] | None = None  # x, y, w, h

    # Timing settings
    default_delay_ms: int = 100
    click_delay_ms: int = 50

    # Hotkey overrides
    hotkey_start: str = "F5"
    hotkey_stop: str = "F6"
    hotkey_pause: str = "F7"

    # Screen resolution (for coordinate scaling)
    target_width: int = 1920
    target_height: int = 1080

    # Custom variables for scripts
    variables: dict[str, Any] = field(default_factory=dict)

    # Script-specific settings
    scripts: list[str] = field(default_factory=list)  # Associated script paths


class ProfileManager:
    """
    Manage game profiles.

    Profiles are stored as JSON files in profiles directory.

    Usage:
        manager = ProfileManager(Path("./profiles"))

        # Create profile
        profile = manager.create("MU Online", window_title="MU Legend")
        profile.default_threshold = 0.85
        manager.save(profile)

        # Load profile
        profile = manager.load("MU Online")

        # Apply to script
        manager.apply_to_script(profile, script)
    """

    def __init__(self, profiles_dir: Path) -> None:
        """
        Initialize profile manager.

        Args:
            profiles_dir: Directory to store profile files
        """
        self._dir = profiles_dir
        self._dir.mkdir(parents=True, exist_ok=True)
        self._profiles: dict[str, GameProfile] = {}
        self._load_all()

    def _profile_path(self, name: str) -> Path:
        """Get path for profile file."""
        safe_name = "".join(c if c.isalnum() or c in "_ -" else "_" for c in name)
        return self._dir / f"{safe_name}.json"

    def _load_all(self) -> None:
        """Load all profiles from directory."""
        for path in self._dir.glob("*.json"):
            try:
                with open(path, encoding="utf-8") as f:
                    data = json.load(f)
                    profile = GameProfile(**data)
                    self._profiles[profile.name] = profile
            except Exception as e:
                logger.warning("Failed to load profile %s: %s", path, e)

    @property
    def profiles(self) -> list[GameProfile]:
        """Get all profiles."""
        return list(self._profiles.values())

    def get(self, name: str) -> GameProfile | None:
        """Get profile by name."""
        return self._profiles.get(name)

    def create(
        self,
        name: str,
        description: str = "",
        window_title: str = "",
        **kwargs: Any,
    ) -> GameProfile:
        """
        Create new profile.

        Args:
            name: Profile name
            description: Profile description
            window_title: Target window title pattern
            **kwargs: Additional profile settings

        Returns:
            New GameProfile
        """
        profile = GameProfile(
            name=name,
            description=description,
            window_title=window_title,
            **kwargs,
        )
        self._profiles[name] = profile
        self.save(profile)
        return profile

    def save(self, profile: GameProfile) -> bool:
        """
        Save profile to disk.

        Args:
            profile: Profile to save

        Returns:
            True if saved successfully
        """
        try:
            path = self._profile_path(profile.name)
            with open(path, "w", encoding="utf-8") as f:
                json.dump(asdict(profile), f, indent=2, ensure_ascii=False)
            self._profiles[profile.name] = profile
            logger.info("Saved profile: %s", profile.name)
            return True
        except Exception as e:
            logger.error("Failed to save profile %s: %s", profile.name, e)
            return False

    def delete(self, name: str) -> bool:
        """
        Delete profile.

        Args:
            name: Profile name

        Returns:
            True if deleted
        """
        if name not in self._profiles:
            return False

        try:
            path = self._profile_path(name)
            if path.exists():
                path.unlink()
            del self._profiles[name]
            logger.info("Deleted profile: %s", name)
            return True
        except Exception as e:
            logger.error("Failed to delete profile %s: %s", name, e)
            return False

    def duplicate(self, name: str, new_name: str) -> GameProfile | None:
        """
        Duplicate existing profile.

        Args:
            name: Source profile name
            new_name: New profile name

        Returns:
            New profile or None if source not found
        """
        source = self.get(name)
        if source is None:
            return None

        data = asdict(source)
        data["name"] = new_name
        profile = GameProfile(**data)
        self._profiles[new_name] = profile
        self.save(profile)
        return profile

    def apply_to_script(self, profile: GameProfile, script: Any) -> None:
        """
        Apply profile settings to a script.

        Args:
            profile: Profile to apply
            script: Script to modify
        """
        # Apply hotkeys
        if hasattr(script, "hotkeys"):
            script.hotkeys.start = profile.hotkey_start
            script.hotkeys.stop = profile.hotkey_stop
            script.hotkeys.pause = profile.hotkey_pause

        # Apply default threshold to assets
        if hasattr(script, "assets"):
            for asset in script.assets:
                if asset.threshold == 0.8:  # Only if using default
                    asset.threshold = profile.default_threshold
                if profile.grayscale != asset.grayscale:
                    asset.grayscale = profile.grayscale

        logger.info("Applied profile '%s' to script", profile.name)

    def list_profiles(self) -> list[str]:
        """Get list of profile names."""
        return list(self._profiles.keys())


# Preset profiles for common games
PRESET_PROFILES: list[dict[str, Any]] = [
    {
        "name": "MU Online",
        "description": "Settings for MU Online games",
        "window_title": "MU",
        "default_threshold": 0.85,
        "grayscale": True,
        "default_delay_ms": 150,
    },
    {
        "name": "Lineage 2",
        "description": "Settings for Lineage 2",
        "window_title": "Lineage",
        "default_threshold": 0.80,
        "grayscale": False,  # Color important for HP/MP bars
        "default_delay_ms": 100,
    },
    {
        "name": "Web Browser",
        "description": "Settings for web automation",
        "window_title": "Chrome",
        "default_threshold": 0.90,
        "grayscale": False,
        "default_delay_ms": 200,
    },
    {
        "name": "Mobile Emulator",
        "description": "Settings for Android emulators",
        "window_title": "BlueStacks",
        "default_threshold": 0.85,
        "grayscale": True,
        "target_width": 1280,
        "target_height": 720,
    },
]


def create_preset_profiles(manager: ProfileManager) -> None:
    """Create preset profiles if they don't exist."""
    for preset in PRESET_PROFILES:
        if manager.get(preset["name"]) is None:
            manager.create(**preset)


================================================================================
FILE PATH: core\recorder.py
LINES: 360
================================================================================

"""
RetroAuto v2 - Script Recorder

Record mouse and keyboard actions to create automation scripts.
"""

from __future__ import annotations

import threading
import time
from collections.abc import Callable
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import TYPE_CHECKING, Any

from infra import get_logger

if TYPE_CHECKING:
    from core.models import Action

logger = get_logger("Recorder")


class RecordState(Enum):
    """Recorder state."""

    IDLE = auto()
    RECORDING = auto()
    PAUSED = auto()


@dataclass
class RecordedEvent:
    """A recorded mouse/keyboard event."""

    event_type: str  # click, double_click, right_click, key, hotkey, type
    timestamp: float

    # Mouse data
    x: int | None = None
    y: int | None = None
    button: str | None = None

    # Keyboard data
    key: str | None = None
    keys: list[str] = field(default_factory=list)
    text: str | None = None

    # Computed delay from previous event
    delay_ms: int = 0


class ActionRecorder:
    """
    Record user actions and convert to script actions.

    Features:
    - Record mouse clicks (left, right, double)
    - Record keyboard input (keys, hotkeys, text)
    - Calculate delays between actions
    - Convert to script actions
    - Filter noise (accidental clicks, etc.)

    Usage:
        recorder = ActionRecorder()
        recorder.on_event(callback)  # Receive events

        recorder.start()
        # ... user performs actions ...
        recorder.stop()

        actions = recorder.to_actions()
    """

    def __init__(
        self,
        min_delay_ms: int = 50,
        max_delay_ms: int = 5000,
        merge_clicks: bool = True,
    ) -> None:
        """
        Initialize recorder.

        Args:
            min_delay_ms: Minimum delay to record (filter fast clicks)
            max_delay_ms: Cap delays at this value
            merge_clicks: Merge sequential clicks at same position
        """
        self._min_delay = min_delay_ms
        self._max_delay = max_delay_ms
        self._merge_clicks = merge_clicks

        self._state = RecordState.IDLE
        self._events: list[RecordedEvent] = []
        self._start_time: float = 0
        self._last_event_time: float = 0

        self._callbacks: list[Callable[[RecordedEvent], None]] = []

        # pynput listeners (lazy import)
        self._mouse_listener = None
        self._keyboard_listener = None

        # For text accumulation
        self._text_buffer: list[str] = []
        self._text_start_time: float = 0

        # Lock for thread safety
        self._lock = threading.Lock()

    @property
    def state(self) -> RecordState:
        """Get current state."""
        return self._state

    @property
    def events(self) -> list[RecordedEvent]:
        """Get recorded events."""
        return self._events.copy()

    def on_event(self, callback: Callable[[RecordedEvent], None]) -> None:
        """Register callback for recorded events."""
        self._callbacks.append(callback)

    def start(self) -> None:
        """Start recording."""
        if self._state == RecordState.RECORDING:
            logger.warning("Already recording")
            return

        self._events.clear()
        self._start_time = time.time()
        self._last_event_time = self._start_time
        self._state = RecordState.RECORDING

        self._start_listeners()
        logger.info("Recording started")

    def stop(self) -> list[RecordedEvent]:
        """Stop recording and return events."""
        self._stop_listeners()
        self._flush_text_buffer()
        self._state = RecordState.IDLE
        logger.info("Recording stopped, %d events captured", len(self._events))
        return self._events.copy()

    def pause(self) -> None:
        """Pause recording."""
        if self._state == RecordState.RECORDING:
            self._state = RecordState.PAUSED
            logger.info("Recording paused")

    def resume(self) -> None:
        """Resume recording."""
        if self._state == RecordState.PAUSED:
            self._state = RecordState.RECORDING
            self._last_event_time = time.time()
            logger.info("Recording resumed")

    def clear(self) -> None:
        """Clear recorded events."""
        with self._lock:
            self._events.clear()

    def _start_listeners(self) -> None:
        """Start mouse and keyboard listeners."""
        try:
            from pynput import keyboard, mouse

            self._mouse_listener = mouse.Listener(
                on_click=self._on_mouse_click,
            )
            self._mouse_listener.start()

            self._keyboard_listener = keyboard.Listener(
                on_press=self._on_key_press,
                on_release=self._on_key_release,
            )
            self._keyboard_listener.start()

        except ImportError:
            logger.error("pynput not installed. Run: pip install pynput")
            raise

    def _stop_listeners(self) -> None:
        """Stop listeners."""
        if self._mouse_listener:
            self._mouse_listener.stop()
            self._mouse_listener = None

        if self._keyboard_listener:
            self._keyboard_listener.stop()
            self._keyboard_listener = None

    def _record_event(self, event: RecordedEvent) -> None:
        """Record an event."""
        if self._state != RecordState.RECORDING:
            return

        with self._lock:
            # Calculate delay from last event
            now = time.time()
            delay_ms = int((now - self._last_event_time) * 1000)

            # Apply delay limits
            if delay_ms < self._min_delay:
                delay_ms = 0
            elif delay_ms > self._max_delay:
                delay_ms = self._max_delay

            event.delay_ms = delay_ms
            event.timestamp = now

            self._events.append(event)
            self._last_event_time = now

        # Notify callbacks
        for callback in self._callbacks:
            try:
                callback(event)
            except Exception as e:
                logger.error("Callback error: %s", e)

    def _on_mouse_click(self, x: int, y: int, button: Any, pressed: bool) -> None:
        """Handle mouse click."""
        if not pressed:  # Only record press, not release
            return

        # Flush any pending text
        self._flush_text_buffer()

        button_name = str(button).split(".")[-1]  # 'Button.left' -> 'left'

        event = RecordedEvent(
            event_type="click",
            timestamp=time.time(),
            x=x,
            y=y,
            button=button_name,
        )

        self._record_event(event)

    def _on_key_press(self, key: Any) -> None:
        """Handle key press."""
        try:
            # Check if it's a character key
            if hasattr(key, "char") and key.char:
                # Accumulate text
                self._text_buffer.append(key.char)
                if not self._text_start_time:
                    self._text_start_time = time.time()
            else:
                # Special key - flush text buffer first
                self._flush_text_buffer()

                key_name = str(key).replace("Key.", "").upper()

                # Check for hotkey (Ctrl/Alt/Shift + key)
                # This is simplified - full implementation would track modifiers
                event = RecordedEvent(
                    event_type="key",
                    timestamp=time.time(),
                    key=key_name,
                )
                self._record_event(event)

        except Exception as e:
            logger.debug("Key event error: %s", e)

    def _on_key_release(self, key: Any) -> None:
        """Handle key release (for detecting typing end)."""
        pass  # Text is flushed on special keys or after timeout

    def _flush_text_buffer(self) -> None:
        """Flush accumulated text to an event."""
        if not self._text_buffer:
            return

        text = "".join(self._text_buffer)
        self._text_buffer.clear()

        if len(text) >= 2:  # Only record if meaningful text
            event = RecordedEvent(
                event_type="type",
                timestamp=self._text_start_time or time.time(),
                text=text,
            )
            self._record_event(event)

        self._text_start_time = 0

    def to_actions(self) -> list[Action]:
        """
        Convert recorded events to script actions.

        Returns:
            List of Action objects
        """
        from core.models import Click, Delay, Hotkey, TypeText

        actions: list[Action] = []

        for event in self._events:
            # Add delay if significant
            if event.delay_ms >= 100:
                actions.append(Delay(ms=event.delay_ms))

            if event.event_type == "click":
                clicks = 1
                button = event.button or "left"

                # Check for double-click (next event same position)
                # This is simplified - production would check timing

                actions.append(
                    Click(
                        x=event.x,
                        y=event.y,
                        button=button,
                        clicks=clicks,
                    )
                )

            elif event.event_type == "key":
                actions.append(Hotkey(keys=[event.key or ""]))

            elif event.event_type == "type":
                actions.append(TypeText(text=event.text or ""))

        return actions

    def export_to_dsl(self) -> str:
        """
        Export recorded events as DSL code.

        Returns:
            DSL code string
        """
        lines = ["flow recorded {"]

        for event in self._events:
            if event.delay_ms >= 100:
                lines.append(f"    delay({event.delay_ms});")

            if event.event_type == "click":
                button = event.button or "left"
                if button == "left":
                    lines.append(f"    click({event.x}, {event.y});")
                elif button == "right":
                    lines.append(f"    right_click({event.x}, {event.y});")

            elif event.event_type == "key":
                lines.append(f'    hotkey("{event.key}");')

            elif event.event_type == "type":
                lines.append(f'    type_text("{event.text}");')

        lines.append("}")
        return "\n".join(lines)


================================================================================
FILE PATH: core\templates.py
LINES: 116
================================================================================

"""
RetroAuto v2 - Template Store

Manages preloaded templates for fast matching.
"""

from pathlib import Path
from typing import Any

import cv2
import numpy as np

from core.models import AssetImage
from infra import get_logger

logger = get_logger("TemplateStore")


class TemplateStore:
    """
    Stores preloaded and cached templates for fast matching.

    Features:
    - Preload all templates on script load
    - Cache grayscale converted versions
    - Memory management
    """

    def __init__(self, base_path: Path | None = None) -> None:
        self._base_path = base_path or Path(".")
        self._templates: dict[str, dict[str, Any]] = {}

    def set_base_path(self, path: Path) -> None:
        """Set base path for relative asset paths."""
        self._base_path = path

    def preload(self, assets: list[AssetImage]) -> list[str]:
        """
        Preload all assets into memory.

        Returns:
            List of errors (empty if all loaded successfully)
        """
        errors: list[str] = []
        self._templates.clear()

        for asset in assets:
            try:
                self._load_asset(asset)
            except Exception as e:
                errors.append(f"{asset.id}: {e}")

        logger.info("Preloaded %d templates (%d errors)", len(self._templates), len(errors))
        return errors

    def _load_asset(self, asset: AssetImage) -> None:
        """Load single asset into cache."""
        asset_path = Path(asset.path)

        # Support both absolute and relative paths
        if asset_path.is_absolute():
            path = asset_path
        else:
            path = self._base_path / asset.path

        if not path.exists():
            raise FileNotFoundError(f"Template not found: {path}")

        # Load image
        img = cv2.imread(str(path), cv2.IMREAD_UNCHANGED)
        if img is None:
            raise ValueError(f"Failed to read image: {path}")

        # Convert to grayscale if needed
        if asset.grayscale and len(img.shape) == 3:
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        else:
            gray = img

        # Memory optimization: only store color if explicitly needed (not grayscale)
        # This saves ~40% memory for grayscale templates
        self._templates[asset.id] = {
            "asset": asset,
            "color": None if asset.grayscale else img,  # Don't duplicate color for grayscale
            "gray": gray,
            "shape": img.shape[:2],  # (h, w)
        }

        logger.debug("Loaded template: %s (%dx%d, grayscale=%s)", asset.id, img.shape[1], img.shape[0], asset.grayscale)

    def get(self, asset_id: str) -> dict[str, Any] | None:
        """Get preloaded template."""
        return self._templates.get(asset_id)

    def get_template_image(self, asset_id: str, grayscale: bool = True) -> np.ndarray | None:
        """Get template image array."""
        data = self._templates.get(asset_id)
        if data is None:
            return None
        return data["gray"] if grayscale else data["color"]

    def get_asset(self, asset_id: str) -> AssetImage | None:
        """Get asset metadata."""
        data = self._templates.get(asset_id)
        return data["asset"] if data else None

    def clear(self) -> None:
        """Clear all cached templates."""
        self._templates.clear()
        logger.debug("Template cache cleared")

    def __contains__(self, asset_id: str) -> bool:
        return asset_id in self._templates

    def __len__(self) -> int:
        return len(self._templates)


================================================================================
FILE PATH: core\watchdog.py
LINES: 119
================================================================================

"""
System Watchdog Module
Pillar 1 of "Titan Light" Robustness Strategy.

This module provides the vital signs monitoring for the automation engine.
It checks:
1. Internet Connectivity
2. Game Process Existence
3. Game Window Visibility & Resolution
"""

import ctypes
import socket
import subprocess
import time

from infra import get_logger

logger = get_logger("SystemWatchdog")


class SystemWatchdog:
    def __init__(self):
        self.last_check = 0
        self.check_interval = 5.0  # Check every 5 seconds
        self._user32 = ctypes.windll.user32
        self._shcore = ctypes.windll.shcore
        self._shcore.SetProcessDpiAwareness(
            1
        )  # Enable DPI awareness for accurate resolution checks

    def check_health(self, config: dict) -> tuple[bool, str]:
        """
        Run all configured health checks.
        Returns: (is_healthy, error_message)
        """
        current_time = time.time()
        if current_time - self.last_check < self.check_interval:
            return True, ""

        self.last_check = current_time

        # 1. Check Internet
        if config.get("check_internet", False) and not self._check_internet():
            return False, "‚ö†Ô∏è No Internet Connection"

        # 2. Check Process
        process_name = config.get("process_name")
        if process_name and not self._check_process(process_name):
            return False, f"‚ö†Ô∏è Process '{process_name}' not found"

        # 3. Check Window
        window_title = config.get("window_title")
        if window_title:
            is_found, msg = self._check_window(window_title)
            if not is_found:
                return False, msg

        return True, "OK"

    def _check_internet(self, host="8.8.8.8", port=53, timeout=3) -> bool:
        """
        Check internet connectivity by trying to connect to Google DNS.
        Better than ping because it doesn't require ICMP.
        """
        try:
            socket.setdefaulttimeout(timeout)
            socket.socket(socket.AF_INET, socket.SOCK_STREAM).connect((host, port))
            return True
        except OSError:
            return False

    def _check_process(self, process_name: str) -> bool:
        """
        Check if a process is running using tasklist.
        Robust fallback if psutil is not available.
        """
        try:
            # Usage of tasklist is fast enough for 5s interval
            output = subprocess.check_output(
                f'tasklist /FI "IMAGENAME eq {process_name}"', shell=True
            ).decode(errors="ignore")
            # If process is found, it appears in the list.
            # If not, tasklist usually says "INFO: No tasks are running..."
            return process_name.lower() in output.lower()
        except Exception as e:
            logger.error(f"Error checking process: {e}")
            return True  # Assume true on error to prevent blocking execution due to watchdog bug

    def _check_window(self, partial_title: str) -> tuple[bool, str]:
        """
        Check if a window with partial_title exists and is not minimized.
        """
        found_window = []

        def enum_window_callback(hwnd, _):
            length = self._user32.GetWindowTextLengthW(hwnd)
            buff = ctypes.create_unicode_buffer(length + 1)
            self._user32.GetWindowTextW(hwnd, buff, length + 1)
            title = buff.value

            if partial_title.lower() in title.lower() and self._user32.IsWindowVisible(hwnd):
                found_window.append(hwnd)
                return False  # Stop enumeration
            return True

        CMPFUNC = ctypes.WINFUNCTYPE(ctypes.c_bool, ctypes.c_int, ctypes.c_int)
        self._user32.EnumWindows(CMPFUNC(enum_window_callback), 0)

        if not found_window:
            return False, f"‚ö†Ô∏è Window containing '{partial_title}' not found"

        hwnd = found_window[0]

        # Check if minimized
        if self._user32.IsIconic(hwnd):
            return False, f"‚ö†Ô∏è Window '{partial_title}' is minimized"

        return True, ""


================================================================================
FILE PATH: core\analytics\metrics.py
LINES: 559
================================================================================

"""
RetroAuto v2 - Analytics & Metrics

Metrics collection, logging, and monitoring for RetroScript.
Part of RetroScript Phase 17 - Analytics & Monitoring.
"""

from __future__ import annotations

import json
import statistics
import time
from collections.abc import Callable
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum, auto
from pathlib import Path
from threading import Lock
from typing import Any

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Metric Types
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class MetricType(Enum):
    """Types of metrics."""

    COUNTER = auto()
    GAUGE = auto()
    TIMER = auto()
    HISTOGRAM = auto()


@dataclass
class Counter:
    """A counter metric (always increases)."""

    name: str
    value: int = 0
    labels: dict[str, str] = field(default_factory=dict)
    _lock: Lock = field(default_factory=Lock, repr=False)

    def inc(self, amount: int = 1) -> None:
        """Increment counter."""
        with self._lock:
            self.value += amount

    def get(self) -> int:
        """Get current value."""
        return self.value

    def reset(self) -> None:
        """Reset counter."""
        with self._lock:
            self.value = 0


@dataclass
class Gauge:
    """A gauge metric (can go up or down)."""

    name: str
    value: float = 0.0
    labels: dict[str, str] = field(default_factory=dict)
    _lock: Lock = field(default_factory=Lock, repr=False)

    def set(self, value: float) -> None:
        """Set gauge value."""
        with self._lock:
            self.value = value

    def inc(self, amount: float = 1.0) -> None:
        """Increment gauge."""
        with self._lock:
            self.value += amount

    def dec(self, amount: float = 1.0) -> None:
        """Decrement gauge."""
        with self._lock:
            self.value -= amount

    def get(self) -> float:
        """Get current value."""
        return self.value


@dataclass
class Timer:
    """A timer metric for measuring durations."""

    name: str
    values: list[float] = field(default_factory=list)
    labels: dict[str, str] = field(default_factory=dict)
    _lock: Lock = field(default_factory=Lock, repr=False)
    _start_time: float | None = field(default=None, repr=False)

    def start(self) -> None:
        """Start the timer."""
        self._start_time = time.perf_counter()

    def stop(self) -> float:
        """Stop timer and record duration."""
        if self._start_time is None:
            return 0.0

        duration = time.perf_counter() - self._start_time
        with self._lock:
            self.values.append(duration)
        self._start_time = None
        return duration

    def record(self, duration: float) -> None:
        """Record a duration directly."""
        with self._lock:
            self.values.append(duration)

    def get_stats(self) -> dict[str, float]:
        """Get timer statistics."""
        if not self.values:
            return {"count": 0, "mean": 0, "min": 0, "max": 0, "p50": 0, "p95": 0}

        sorted_values = sorted(self.values)
        return {
            "count": len(self.values),
            "mean": statistics.mean(self.values),
            "min": min(self.values),
            "max": max(self.values),
            "p50": sorted_values[len(sorted_values) // 2],
            "p95": (
                sorted_values[int(len(sorted_values) * 0.95)]
                if len(sorted_values) >= 20
                else sorted_values[-1]
            ),
        }


class TimerContext:
    """Context manager for timing."""

    def __init__(self, timer: Timer) -> None:
        self._timer = timer

    def __enter__(self) -> TimerContext:
        self._timer.start()
        return self

    def __exit__(self, *args: Any) -> None:
        self._timer.stop()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Metrics Registry
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class MetricsRegistry:
    """Registry for all metrics.

    Usage:
        metrics = MetricsRegistry()

        # Counter
        metrics.counter("requests_total").inc()

        # Gauge
        metrics.gauge("active_scripts").set(5)

        # Timer
        with metrics.timer("request_duration").time():
            do_something()
    """

    def __init__(self) -> None:
        self._counters: dict[str, Counter] = {}
        self._gauges: dict[str, Gauge] = {}
        self._timers: dict[str, Timer] = {}
        self._lock = Lock()

    def counter(self, name: str, **labels: str) -> Counter:
        """Get or create a counter."""
        key = self._make_key(name, labels)
        if key not in self._counters:
            with self._lock:
                if key not in self._counters:
                    self._counters[key] = Counter(name=name, labels=labels)
        return self._counters[key]

    def gauge(self, name: str, **labels: str) -> Gauge:
        """Get or create a gauge."""
        key = self._make_key(name, labels)
        if key not in self._gauges:
            with self._lock:
                if key not in self._gauges:
                    self._gauges[key] = Gauge(name=name, labels=labels)
        return self._gauges[key]

    def timer(self, name: str, **labels: str) -> Timer:
        """Get or create a timer."""
        key = self._make_key(name, labels)
        if key not in self._timers:
            with self._lock:
                if key not in self._timers:
                    self._timers[key] = Timer(name=name, labels=labels)
        return self._timers[key]

    def time(self, name: str, **labels: str) -> TimerContext:
        """Context manager for timing."""
        return TimerContext(self.timer(name, **labels))

    def _make_key(self, name: str, labels: dict[str, str]) -> str:
        """Create a unique key for a metric."""
        if not labels:
            return name
        label_str = ",".join(f"{k}={v}" for k, v in sorted(labels.items()))
        return f"{name}{{{label_str}}}"

    def get_all(self) -> dict[str, Any]:
        """Get all metrics as dictionary."""
        result: dict[str, Any] = {}

        for key, counter in self._counters.items():
            result[key] = {"type": "counter", "value": counter.get()}

        for key, gauge in self._gauges.items():
            result[key] = {"type": "gauge", "value": gauge.get()}

        for key, timer in self._timers.items():
            result[key] = {"type": "timer", **timer.get_stats()}

        return result

    def reset_all(self) -> None:
        """Reset all metrics."""
        for counter in self._counters.values():
            counter.reset()
        for gauge in self._gauges.values():
            gauge.set(0.0)
        for timer in self._timers.values():
            timer.values.clear()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Script Metrics
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class ScriptMetrics:
    """Pre-defined metrics for script execution.

    Usage:
        sm = ScriptMetrics()
        sm.script_started("my_script")
        # ... execute ...
        sm.script_completed("my_script", success=True, duration=1.5)
    """

    def __init__(self, registry: MetricsRegistry | None = None) -> None:
        self.registry = registry or MetricsRegistry()

        # Pre-defined counters
        self._scripts_started = self.registry.counter("scripts_started_total")
        self._scripts_completed = self.registry.counter("scripts_completed_total")
        self._scripts_failed = self.registry.counter("scripts_failed_total")
        self._actions_executed = self.registry.counter("actions_executed_total")
        self._finds_total = self.registry.counter("finds_total")
        self._finds_success = self.registry.counter("finds_success_total")
        self._clicks_total = self.registry.counter("clicks_total")

        # Gauges
        self._active_scripts = self.registry.gauge("active_scripts")

        # Timers
        self._script_duration = self.registry.timer("script_duration_seconds")
        self._action_duration = self.registry.timer("action_duration_seconds")
        self._find_duration = self.registry.timer("find_duration_seconds")

    def script_started(self, name: str) -> None:
        """Record script start."""
        self._scripts_started.inc()
        self._active_scripts.inc()

    def script_completed(self, name: str, success: bool, duration: float) -> None:
        """Record script completion."""
        self._scripts_completed.inc()
        self._active_scripts.dec()
        self._script_duration.record(duration)

        if not success:
            self._scripts_failed.inc()

    def action_executed(self, action: str, duration: float) -> None:
        """Record action execution."""
        self._actions_executed.inc()
        self._action_duration.record(duration)

    def find_executed(self, success: bool, duration: float) -> None:
        """Record find operation."""
        self._finds_total.inc()
        self._find_duration.record(duration)
        if success:
            self._finds_success.inc()

    def click_executed(self) -> None:
        """Record click action."""
        self._clicks_total.inc()

    def get_success_rate(self) -> float:
        """Get overall script success rate."""
        total = self._scripts_completed.get()
        if total == 0:
            return 1.0
        failed = self._scripts_failed.get()
        return (total - failed) / total

    def get_find_success_rate(self) -> float:
        """Get find success rate."""
        total = self._finds_total.get()
        if total == 0:
            return 1.0
        return self._finds_success.get() / total

    def get_summary(self) -> dict[str, Any]:
        """Get metrics summary."""
        return {
            "scripts": {
                "started": self._scripts_started.get(),
                "completed": self._scripts_completed.get(),
                "failed": self._scripts_failed.get(),
                "active": int(self._active_scripts.get()),
                "success_rate": self.get_success_rate(),
            },
            "actions": {
                "total": self._actions_executed.get(),
                "clicks": self._clicks_total.get(),
            },
            "finds": {
                "total": self._finds_total.get(),
                "success": self._finds_success.get(),
                "success_rate": self.get_find_success_rate(),
            },
            "timing": {
                "script": self._script_duration.get_stats(),
                "action": self._action_duration.get_stats(),
                "find": self._find_duration.get_stats(),
            },
        }


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Structured Logger
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class LogLevel(Enum):
    """Log levels."""

    DEBUG = 10
    INFO = 20
    WARNING = 30
    ERROR = 40
    CRITICAL = 50


@dataclass
class LogEntry:
    """A structured log entry."""

    timestamp: str
    level: str
    message: str
    data: dict[str, Any] = field(default_factory=dict)
    source: str = ""
    script: str = ""

    def to_json(self) -> str:
        """Convert to JSON string."""
        return json.dumps(
            {
                "timestamp": self.timestamp,
                "level": self.level,
                "message": self.message,
                "data": self.data,
                "source": self.source,
                "script": self.script,
            }
        )


class StructuredLogger:
    """JSON-structured logger for RetroScript.

    Usage:
        logger = StructuredLogger()
        logger.info("Script started", script="my_script")
        logger.error("Failed to find image", target="button.png")
    """

    def __init__(
        self,
        name: str = "retroscript",
        level: LogLevel = LogLevel.INFO,
        log_file: str | Path | None = None,
    ) -> None:
        self.name = name
        self.level = level
        self.log_file = Path(log_file) if log_file else None
        self._entries: list[LogEntry] = []
        self._max_entries = 1000
        self._lock = Lock()

        # Callbacks
        self.on_log: Callable[[LogEntry], None] | None = None

    def _log(self, level: LogLevel, message: str, **data: Any) -> LogEntry:
        """Internal log method."""
        if level.value < self.level.value:
            return LogEntry("", "", "")

        entry = LogEntry(
            timestamp=datetime.now().isoformat(),
            level=level.name,
            message=message,
            data=data,
            source=self.name,
        )

        with self._lock:
            self._entries.append(entry)
            if len(self._entries) > self._max_entries:
                self._entries.pop(0)

        # Write to file
        if self.log_file:
            with open(self.log_file, "a", encoding="utf-8") as f:
                f.write(entry.to_json() + "\n")

        # Callback
        if self.on_log:
            self.on_log(entry)

        return entry

    def debug(self, message: str, **data: Any) -> LogEntry:
        """Log debug message."""
        return self._log(LogLevel.DEBUG, message, **data)

    def info(self, message: str, **data: Any) -> LogEntry:
        """Log info message."""
        return self._log(LogLevel.INFO, message, **data)

    def warning(self, message: str, **data: Any) -> LogEntry:
        """Log warning message."""
        return self._log(LogLevel.WARNING, message, **data)

    def error(self, message: str, **data: Any) -> LogEntry:
        """Log error message."""
        return self._log(LogLevel.ERROR, message, **data)

    def critical(self, message: str, **data: Any) -> LogEntry:
        """Log critical message."""
        return self._log(LogLevel.CRITICAL, message, **data)

    def get_entries(
        self,
        level: LogLevel | None = None,
        limit: int = 100,
    ) -> list[LogEntry]:
        """Get log entries."""
        entries = self._entries[-limit:]
        if level:
            entries = [e for e in entries if e.level == level.name]
        return entries

    def clear(self) -> None:
        """Clear log entries."""
        with self._lock:
            self._entries.clear()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Dashboard Stats
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class DashboardStats:
    """Aggregated statistics for dashboard display.

    Usage:
        stats = DashboardStats(metrics, logger)
        summary = stats.get_summary()
    """

    def __init__(
        self,
        metrics: ScriptMetrics | None = None,
        logger: StructuredLogger | None = None,
    ) -> None:
        self.metrics = metrics or ScriptMetrics()
        self.logger = logger or StructuredLogger()
        self._start_time = time.time()

    def get_summary(self) -> dict[str, Any]:
        """Get complete dashboard summary."""
        return {
            "uptime": time.time() - self._start_time,
            "metrics": self.metrics.get_summary(),
            "recent_logs": [
                {"level": e.level, "message": e.message, "time": e.timestamp}
                for e in self.logger.get_entries(limit=10)
            ],
            "errors": [
                {"message": e.message, "data": e.data, "time": e.timestamp}
                for e in self.logger.get_entries(level=LogLevel.ERROR, limit=5)
            ],
        }

    def get_health(self) -> dict[str, Any]:
        """Get health status."""
        success_rate = self.metrics.get_success_rate()
        return {
            "status": (
                "healthy"
                if success_rate >= 0.9
                else "degraded" if success_rate >= 0.7 else "unhealthy"
            ),
            "success_rate": success_rate,
            "uptime": time.time() - self._start_time,
        }


# Global instances
_metrics: MetricsRegistry | None = None
_script_metrics: ScriptMetrics | None = None
_logger: StructuredLogger | None = None


def get_metrics() -> MetricsRegistry:
    """Get the default metrics registry."""
    global _metrics
    if _metrics is None:
        _metrics = MetricsRegistry()
    return _metrics


def get_script_metrics() -> ScriptMetrics:
    """Get the default script metrics."""
    global _script_metrics
    if _script_metrics is None:
        _script_metrics = ScriptMetrics(get_metrics())
    return _script_metrics


def get_logger() -> StructuredLogger:
    """Get the default structured logger."""
    global _logger
    if _logger is None:
        _logger = StructuredLogger()
    return _logger


================================================================================
FILE PATH: core\dsl\__init__.py
LINES: 96
================================================================================

"""
RetroAuto v2 - DSL Package

Custom Domain Specific Language for automation scripts.
Supports:
- Lexer: Tokenization with comments, strings, durations
- Parser: Recursive descent with error recovery
- AST: Node classes with span tracking
- Formatter: Pretty printing with K&R style
- Semantic: Validation with quick-fix hints
"""

from core.dsl.ast import (
    ArrayExpr,
    AssignStmt,
    ASTNode,
    BinaryExpr,
    BlockStmt,
    BreakStmt,
    CallExpr,
    ConstStmt,
    ContinueStmt,
    ExprStmt,
    FlowDecl,
    ForStmt,
    GotoStmt,
    HotkeysDecl,
    Identifier,
    IfStmt,
    InterruptDecl,
    LabelStmt,
    LetStmt,
    Literal,
    Program,
    ReturnStmt,
    Span,
    TryStmt,
    UnaryExpr,
    WhileStmt,
)
from core.dsl.diagnostics import Diagnostic, QuickFix, Severity
from core.dsl.formatter import Formatter, format_code
from core.dsl.lexer import Lexer, LexerError
from core.dsl.parser import ParseError, Parser
from core.dsl.semantic import SemanticAnalyzer, analyze
from core.dsl.tokens import KEYWORDS, Token, TokenType

__all__ = [
    # Tokens
    "Token",
    "TokenType",
    "KEYWORDS",
    # Lexer
    "Lexer",
    "LexerError",
    # Parser
    "Parser",
    "ParseError",
    # AST
    "ASTNode",
    "Span",
    "Program",
    "FlowDecl",
    "InterruptDecl",
    "HotkeysDecl",
    "LabelStmt",
    "GotoStmt",
    "IfStmt",
    "WhileStmt",
    "ForStmt",
    "TryStmt",
    "CallExpr",
    "Literal",
    "Identifier",
    "BinaryExpr",
    "UnaryExpr",
    "ArrayExpr",
    "BlockStmt",
    "ExprStmt",
    "LetStmt",
    "ConstStmt",
    "AssignStmt",
    "ReturnStmt",
    "BreakStmt",
    "ContinueStmt",
    # Formatter
    "Formatter",
    "format_code",
    # Semantic
    "SemanticAnalyzer",
    "analyze",
    # Diagnostics
    "Diagnostic",
    "Severity",
    "QuickFix",
]


================================================================================
FILE PATH: core\dsl\adapter.py
LINES: 608
================================================================================

"""
RetroAuto v2 - DSL Runner Adapter

Adapts DSL IR to the existing YAML-based runner.
Converts ActionIR to Action models for execution.
Also provides bidirectional Action ‚Üî ActionIR conversion for GUI sync.
"""

from __future__ import annotations

from core.dsl.ir import ActionIR, FlowIR, InterruptIR, ScriptIR
from core.models import (
    Action,
    AssetImage,
    Click,
    ClickImage,
    ClickRandom,
    ClickUntil,
    Delay,
    DelayRandom,
    Drag,
    Else,
    EndIf,
    EndLoop,
    EndWhile,
    Flow,
    Goto,
    Hotkey,
    IfImage,
    IfNotImage,
    IfAllImages,
    IfAnyImage,
    IfPixel,
    IfText,
    InterruptRule,
    Label,
    Loop,
    Notify,
    NotifyMethod,
    PixelColor,
    ReadText,
    RunFlow,
    Script,
    ScriptHotkeys,
    Scroll,
    TypeText,
    WaitImage,
    WaitPixel,
    WhileImage,
)


class DSLToYAMLAdapter:
    """
    Converts DSL IR to YAML Script model.

    This allows using the existing Runner with DSL-based scripts.
    """

    @staticmethod
    def convert(ir: ScriptIR) -> Script:
        """Convert ScriptIR to Script model."""
        # Hotkeys
        hotkeys = ScriptHotkeys(
            start=ir.hotkeys.start,
            stop=ir.hotkeys.stop,
            pause=ir.hotkeys.pause,
        )

        # Assets
        assets = [
            AssetImage(
                id=a.id,
                path=a.path,
                threshold=a.threshold,
            )
            for a in ir.assets
        ]

        # Flows
        flows = [DSLToYAMLAdapter._convert_flow(f) for f in ir.flows]

        # Interrupts
        interrupts = [DSLToYAMLAdapter._convert_interrupt(i) for i in ir.interrupts]

        return Script(
            name=ir.name,
            version=ir.version,
            author=ir.author,
            hotkeys=hotkeys,
            assets=assets,
            flows=flows,
            interrupts=interrupts,
            main_flow=(
                "main"
                if any(f.name == "main" for f in flows)
                else (flows[0].name if flows else "main")
            ),
        )

    @staticmethod
    def _convert_flow(flow_ir: FlowIR) -> Flow:
        """Convert FlowIR to Flow model."""
        actions = [
            DSLToYAMLAdapter._convert_action(a)
            for a in flow_ir.actions
            if DSLToYAMLAdapter._convert_action(a) is not None
        ]

        return Flow(name=flow_ir.name, actions=actions)

    @staticmethod
    def _convert_interrupt(interrupt: InterruptIR) -> InterruptRule:
        """Convert InterruptIR to InterruptRule model."""
        actions = [
            DSLToYAMLAdapter._convert_action(a)
            for a in interrupt.actions
            if DSLToYAMLAdapter._convert_action(a) is not None
        ]

        return InterruptRule(
            priority=interrupt.priority,
            when_image=interrupt.when_asset,
            do_actions=actions,
        )

    @staticmethod
    def _convert_action(action: ActionIR) -> Action | None:
        """Convert ActionIR to Action model."""
        params = action.params
        action_type = action.action_type

        if action_type == "wait_image":
            return WaitImage(
                asset_id=params.get("arg0", ""),
                timeout_ms=params.get("timeout", 5000),
                appear=params.get("appear", True),
            )

        if action_type == "click":
            x = params.get("arg0", params.get("x", 0))
            y = params.get("arg1", params.get("y", 0))
            return Click(x=x, y=y, button=params.get("button", "left"))

        if action_type == "sleep":
            # Handle duration (could be int ms or "5s" style)
            duration = params.get("arg0", params.get("duration", 1000))
            if isinstance(duration, str):
                duration = DSLToYAMLAdapter._parse_duration(duration)
            return Delay(ms=duration)

        if action_type == "hotkey":
            keys_arg = params.get("arg0", "")
            if isinstance(keys_arg, str):
                keys = keys_arg.split("+")
            else:
                keys = list(keys_arg) if keys_arg else []
            return Hotkey(keys=keys)

        if action_type == "type_text":
            return TypeText(
                text=params.get("arg0", params.get("text", "")),
                paste_mode=params.get("paste", False),
                enter=params.get("enter", False),
            )

        if action_type == "label":
            return Label(name=params.get("name", ""))

        if action_type == "goto":
            return Goto(label=params.get("target", ""))

        if action_type == "run_flow":
            return RunFlow(flow_name=params.get("arg0", params.get("flow_name", "")))

        if action_type == "log":
            # Log is not an action in YAML - ignore or convert to delay
            return None

        # Unknown action types
        return None

    @staticmethod
    def _parse_duration(duration_str: str) -> int:
        """Parse duration string like '5s' or '100ms' to milliseconds."""
        duration_str = duration_str.lower().strip()

        if duration_str.endswith("ms"):
            return int(duration_str[:-2])
        elif duration_str.endswith("s"):
            return int(float(duration_str[:-1]) * 1000)
        elif duration_str.endswith("m"):
            return int(float(duration_str[:-1]) * 60 * 1000)
        elif duration_str.endswith("h"):
            return int(float(duration_str[:-1]) * 60 * 60 * 1000)
        else:
            # Assume milliseconds
            return int(duration_str)


def ir_to_script(ir: ScriptIR) -> Script:
    """Convert DSL IR to YAML Script model."""
    return DSLToYAMLAdapter.convert(ir)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Bidirectional Action ‚Üî ActionIR Converters for GUI Sync
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


def action_to_ir(action: Action) -> ActionIR:
    """
    Convert Action model to ActionIR for GUI ‚Üí IR sync.

    This enables the Actions Panel to update the IR when
    the user modifies actions via the GUI.
    """
    action_type = action.action.lower()  # WaitImage -> wait_image

    # Convert action_type to snake_case
    type_mapping = {
        "WaitImage": "wait_image",
        "WaitPixel": "wait_pixel",
        "Click": "click",
        "ClickImage": "click_image",
        "ClickRandom": "click_random",
        "ClickUntil": "click_until",
        "IfImage": "if_image",
        "IfNotImage": "if_not_image",
        "IfAllImages": "if_all_images",
        "IfAnyImage": "if_any_image",
        "IfPixel": "if_pixel",
        "IfText": "if_text",
        "Hotkey": "hotkey",
        "TypeText": "type_text",
        "Label": "label",
        "Goto": "goto",
        "RunFlow": "run_flow",
        "Delay": "sleep",
        "DelayRandom": "delay_random",
        "Drag": "drag",
        "Scroll": "scroll",
        "Loop": "loop",
        "WhileImage": "while_image",
        "ReadText": "read_text",
        "Notify": "notify",
        "EndIf": "end_if",
        "EndLoop": "end_loop",
        "EndWhile": "end_while",
        "Else": "else",
    }

    action_type = type_mapping.get(action.action, action.action.lower())

    # Build params dict from action fields
    params: dict = {}

    if isinstance(action, WaitImage):
        params["arg0"] = action.asset_id
        params["timeout"] = action.timeout_ms
        params["appear"] = action.appear

    elif isinstance(action, WaitPixel):
        params["x"] = action.x
        params["y"] = action.y
        params["r"] = action.color.r
        params["g"] = action.color.g
        params["b"] = action.color.b
        params["tolerance"] = action.color.tolerance
        params["appear"] = action.appear

    elif isinstance(action, Click):
        params["x"] = action.x
        params["y"] = action.y
        params["button"] = action.button
        params["clicks"] = action.clicks
        params["use_match"] = action.use_match

    elif isinstance(action, IfImage):
        params["arg0"] = action.asset_id
        # Nested actions would need recursive conversion

    elif isinstance(action, IfNotImage):
        params["arg0"] = action.asset_id

    elif isinstance(action, IfAllImages):
        params["asset_ids"] = action.asset_ids

    elif isinstance(action, IfAnyImage):
        params["asset_ids"] = action.asset_ids

    elif isinstance(action, ClickUntil):
        params["click_asset_id"] = action.click_asset_id
        params["until_asset_id"] = action.until_asset_id
        params["timeout_ms"] = action.timeout_ms
        params["interval_ms"] = action.interval_ms

    elif isinstance(action, IfPixel):
        params["x"] = action.x
        params["y"] = action.y
        params["r"] = action.color.r
        params["g"] = action.color.g
        params["b"] = action.color.b

    elif isinstance(action, Hotkey):
        params["arg0"] = "+".join(action.keys)

    elif isinstance(action, TypeText):
        params["arg0"] = action.text
        params["paste"] = action.paste_mode
        params["enter"] = action.enter

    elif isinstance(action, Label):
        params["name"] = action.name

    elif isinstance(action, Goto):
        params["target"] = action.label

    elif isinstance(action, RunFlow):
        params["arg0"] = action.flow_name

    elif isinstance(action, Delay):
        params["arg0"] = action.ms

    elif isinstance(action, DelayRandom):
        params["min_ms"] = action.min_ms
        params["max_ms"] = action.max_ms

    elif isinstance(action, Drag):
        params["from_x"] = action.from_x
        params["from_y"] = action.from_y
        params["to_x"] = action.to_x
        params["to_y"] = action.to_y
        params["duration_ms"] = action.duration_ms

    elif isinstance(action, Scroll):
        params["x"] = action.x
        params["y"] = action.y
        params["amount"] = action.amount

    elif isinstance(action, Loop):
        params["count"] = action.count
        # Nested actions would need recursive conversion

    elif isinstance(action, WhileImage):
        params["arg0"] = action.asset_id
        params["while_present"] = action.while_present

    elif isinstance(action, ClickImage):
        params["asset_id"] = action.asset_id
        params["button"] = action.button
        params["clicks"] = action.clicks
        params["timeout_ms"] = action.timeout_ms

    elif isinstance(action, ClickRandom):
        params["x1"] = action.x1
        params["y1"] = action.y1
        params["x2"] = action.x2
        params["y2"] = action.y2

    elif isinstance(action, ReadText):
        params["variable_name"] = action.variable_name
        params["roi"] = action.roi
        params["allowlist"] = action.allowlist
        params["scale"] = action.scale
        params["invert"] = action.invert
        params["binarize"] = action.binarize

    elif isinstance(action, IfText):
        params["variable_name"] = action.variable_name
        params["operator"] = action.operator
        params["value"] = action.value

    elif isinstance(action, Notify):
        params["message"] = action.message
        params["method"] = (
            action.method.value if hasattr(action.method, "value") else str(action.method)
        )
        params["title"] = action.title
        params["target"] = action.target

    # Block markers (no params needed)
    elif isinstance(action, (Else, EndIf, EndLoop, EndWhile)):
        pass  # No params

    return ActionIR(
        action_type=action_type,
        params=params,
        span_line=None,
    )


def ir_to_action(ir: ActionIR) -> Action | None:
    """
    Convert ActionIR to Action model for IR ‚Üí GUI sync.

    This enables the Actions Panel to refresh when
    the IR is updated from code changes.
    """
    params = ir.params
    action_type = ir.action_type.lower()

    try:
        if action_type == "wait_image":
            return WaitImage(
                asset_id=params.get("arg0", ""),
                timeout_ms=params.get("timeout", 10000),
                appear=params.get("appear", True),
            )

        if action_type == "wait_pixel":
            return WaitPixel(
                x=params.get("x", 0),
                y=params.get("y", 0),
                color=PixelColor(
                    r=params.get("r", 255),
                    g=params.get("g", 0),
                    b=params.get("b", 0),
                    tolerance=params.get("tolerance", 10),
                ),
                appear=params.get("appear", True),
            )

        if action_type == "click":
            return Click(
                x=params.get("arg0", params.get("x", 0)),
                y=params.get("arg1", params.get("y", 0)),
                button=params.get("button", "left"),
                clicks=params.get("clicks", 1),
                use_match=params.get("use_match", False),
            )

        if action_type == "if_image":
            return IfImage(
                asset_id=params.get("arg0", ""),
            )

        if action_type == "if_not_image":
            return IfNotImage(
                asset_id=params.get("arg0", ""),
            )

        if action_type == "if_all_images":
            return IfAllImages(
                asset_ids=params.get("asset_ids", []),
            )

        if action_type == "if_any_image":
            return IfAnyImage(
                asset_ids=params.get("asset_ids", []),
            )

        if action_type == "click_until":
            return ClickUntil(
                click_asset_id=params.get("click_asset_id", ""),
                until_asset_id=params.get("until_asset_id", ""),
                timeout_ms=params.get("timeout_ms", 10000),
                interval_ms=params.get("interval_ms", 1000),
            )

        if action_type == "if_pixel":
            return IfPixel(
                x=params.get("x", 0),
                y=params.get("y", 0),
                color=PixelColor(
                    r=params.get("r", 255),
                    g=params.get("g", 0),
                    b=params.get("b", 0),
                ),
            )

        if action_type == "hotkey":
            keys_str = params.get("arg0", "")
            keys = keys_str.split("+") if keys_str else []
            return Hotkey(keys=keys)

        if action_type in ("type_text", "typetext"):
            return TypeText(
                text=params.get("arg0", params.get("text", "")),
                paste_mode=params.get("paste", True),
                enter=params.get("enter", False),
            )

        if action_type == "label":
            return Label(name=params.get("name", ""))

        if action_type == "goto":
            return Goto(label=params.get("target", ""))

        if action_type in ("run_flow", "runflow"):
            return RunFlow(flow_name=params.get("arg0", ""))

        if action_type in ("sleep", "delay"):
            ms = params.get("arg0", params.get("ms", 1000))
            if isinstance(ms, str):
                ms = DSLToYAMLAdapter._parse_duration(ms)
            return Delay(ms=ms)

        if action_type == "delay_random":
            return DelayRandom(
                min_ms=params.get("min_ms", 500),
                max_ms=params.get("max_ms", 1500),
            )

        if action_type == "drag":
            return Drag(
                from_x=params.get("from_x", 0),
                from_y=params.get("from_y", 0),
                to_x=params.get("to_x", 100),
                to_y=params.get("to_y", 100),
                duration_ms=params.get("duration_ms", 500),
            )

        if action_type == "scroll":
            return Scroll(
                x=params.get("x"),
                y=params.get("y"),
                amount=params.get("amount", 3),
            )

        if action_type == "loop":
            return Loop(
                count=params.get("count"),
            )

        if action_type == "while_image":
            return WhileImage(
                asset_id=params.get("arg0", ""),
                while_present=params.get("while_present", True),
            )

        if action_type == "click_image":
            return ClickImage(
                asset_id=params.get("asset_id", params.get("arg0", "")),
                button=params.get("button", "left"),
                clicks=params.get("clicks", 1),
                timeout_ms=params.get("timeout_ms", 10000),
            )

        if action_type == "click_random":
            return ClickRandom(
                x1=params.get("x1", 0),
                y1=params.get("y1", 0),
                x2=params.get("x2", 100),
                y2=params.get("y2", 100),
            )

        if action_type == "read_text":
            return ReadText(
                variable_name=params.get("variable_name", "text"),
                roi=params.get("roi"),
                allowlist=params.get("allowlist", ""),
                scale=params.get("scale", 1.0),
                invert=params.get("invert", False),
                binarize=params.get("binarize", False),
            )

        if action_type == "if_text":
            return IfText(
                variable_name=params.get("variable_name", ""),
                operator=params.get("operator", "contains"),
                value=params.get("value", ""),
            )

        if action_type == "notify":
            method_str = params.get("method", "popup")
            method = NotifyMethod.POPUP
            if method_str == "telegram":
                method = NotifyMethod.TELEGRAM
            elif method_str == "discord":
                method = NotifyMethod.DISCORD
            return Notify(
                message=params.get("message", params.get("arg0", "")),
                method=method,
                title=params.get("title", "Notification"),
                target=params.get("target", ""),
            )

        # Block markers
        if action_type == "else":
            return Else()
        if action_type in ("end_if", "endif"):
            return EndIf()
        if action_type in ("end_loop", "endloop"):
            return EndLoop()
        if action_type in ("end_while", "endwhile"):
            return EndWhile()

    except Exception:
        pass

    return None


def ir_to_actions(actions_ir: list[ActionIR]) -> list[Action]:
    """
    Convert a list of ActionIR to Action models.

    Note: Does NOT auto-add EndIf markers. DSL uses nested structure
    for sequential guards (semicolon syntax), so auto-EndIf would break
    the semantic. Users add EndIf in GUI mode when needed.
    """
    actions: list[Action] = []
    for ir in actions_ir:
        action = ir_to_action(ir)
        if action:
            actions.append(action)
    return actions


================================================================================
FILE PATH: core\dsl\ast.py
LINES: 331
================================================================================

"""
RetroAuto v2 - DSL Abstract Syntax Tree

AST node classes with span tracking for:
- Error reporting
- Debugger integration
- Round-trip code generation
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any
from uuid import uuid4


@dataclass
class Span:
    """Source location span for AST nodes."""

    start_line: int
    start_col: int
    end_line: int
    end_col: int

    def __str__(self) -> str:
        if self.start_line == self.end_line:
            return f"{self.start_line}:{self.start_col}-{self.end_col}"
        return f"{self.start_line}:{self.start_col}-{self.end_line}:{self.end_col}"

    @classmethod
    def from_token(cls, token: Any) -> Span:
        """Create span from a token."""
        return cls(token.line, token.column, token.end_line, token.end_column)

    def merge(self, other: Span) -> Span:
        """Merge two spans to cover both ranges."""
        return Span(
            min(self.start_line, other.start_line),
            (
                min(self.start_col, other.start_col)
                if self.start_line == other.start_line
                else (self.start_col if self.start_line < other.start_line else other.start_col)
            ),
            max(self.end_line, other.end_line),
            (
                max(self.end_col, other.end_col)
                if self.end_line == other.end_line
                else (self.end_col if self.end_line > other.end_line else other.end_col)
            ),
        )


def _gen_id() -> str:
    """Generate unique node ID."""
    return str(uuid4())[:8]


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Base class uses kw_only=True to allow subclass fields without defaults
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


@dataclass(kw_only=True)
class ASTNode:
    """Base class for all AST nodes."""

    span: Span
    id: str = field(default_factory=_gen_id)
    leading_comments: list[str] = field(default_factory=list)
    trailing_comment: str | None = None


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Expressions
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


@dataclass(kw_only=True)
class Literal(ASTNode):
    """Literal value: string, number, duration, bool, null."""

    value: Any
    literal_type: str  # "string", "int", "float", "duration", "bool", "null"


@dataclass(kw_only=True)
class Identifier(ASTNode):
    """Variable or function name."""

    name: str


@dataclass(kw_only=True)
class BinaryExpr(ASTNode):
    """Binary operation: a + b, a == b, etc."""

    left: ASTNode
    operator: str  # "+", "-", "==", "!=", "&&", "||", etc.
    right: ASTNode


@dataclass(kw_only=True)
class UnaryExpr(ASTNode):
    """Unary operation: !a, -b."""

    operator: str  # "!", "-"
    operand: ASTNode


@dataclass(kw_only=True)
class CallExpr(ASTNode):
    """Function call: wait_image("btn", timeout=5s)."""

    callee: str
    args: list[ASTNode] = field(default_factory=list)
    kwargs: dict[str, ASTNode] = field(default_factory=dict)


@dataclass(kw_only=True)
class ArrayExpr(ASTNode):
    """Array literal: [a, b, c]."""

    elements: list[ASTNode] = field(default_factory=list)


@dataclass(kw_only=True)
class MemberExpr(ASTNode):
    """Member access: obj.property."""

    object: ASTNode
    property: str


@dataclass(kw_only=True)
class IndexExpr(ASTNode):
    """Index access: arr[0]."""

    object: ASTNode
    index: ASTNode


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Statements
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


@dataclass(kw_only=True)
class ExprStmt(ASTNode):
    """Expression statement: func();."""

    expr: ASTNode


@dataclass(kw_only=True)
class BlockStmt(ASTNode):
    """Block of statements: { ... }."""

    statements: list[ASTNode] = field(default_factory=list)


@dataclass(kw_only=True)
class LetStmt(ASTNode):
    """Variable declaration: let x = 5;."""

    name: str
    initializer: ASTNode | None = None


@dataclass(kw_only=True)
class ConstStmt(ASTNode):
    """Constant declaration: const X = 5;."""

    name: str
    initializer: ASTNode


@dataclass(kw_only=True)
class ImportStmt(ASTNode):
    """Import statement: import "path/module" as alias.

    Example:
        import "lib/combat" as combat
        import "antiban-pro@2.0" as ab
    """

    path: str  # Module path (string)
    alias: str | None = None  # Optional alias name


@dataclass(kw_only=True)
class AssignStmt(ASTNode):
    """Assignment: x = 5;."""

    target: ASTNode  # Identifier or MemberExpr or IndexExpr
    value: ASTNode


@dataclass(kw_only=True)
class IfStmt(ASTNode):
    """If statement with optional elif/else."""

    condition: ASTNode
    then_branch: BlockStmt
    elif_branches: list[tuple[ASTNode, BlockStmt]] = field(default_factory=list)
    else_branch: BlockStmt | None = None


@dataclass(kw_only=True)
class WhileStmt(ASTNode):
    """While loop."""

    condition: ASTNode
    body: BlockStmt


@dataclass(kw_only=True)
class ForStmt(ASTNode):
    """For loop: for i in range(10) { }."""

    variable: str
    iterable: ASTNode
    body: BlockStmt


@dataclass(kw_only=True)
class LabelStmt(ASTNode):
    """Label for goto: label start:."""

    name: str


@dataclass(kw_only=True)
class GotoStmt(ASTNode):
    """Goto statement: goto start;."""

    target: str


@dataclass(kw_only=True)
class BreakStmt(ASTNode):
    """Break statement."""

    pass


@dataclass(kw_only=True)
class ContinueStmt(ASTNode):
    """Continue statement."""

    pass


@dataclass(kw_only=True)
class ReturnStmt(ASTNode):
    """Return statement: return value;."""

    value: ASTNode | None = None


@dataclass(kw_only=True)
class TryStmt(ASTNode):
    """Try-catch statement."""

    try_block: BlockStmt
    catch_var: str | None = None
    catch_block: BlockStmt | None = None


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Top-level Declarations
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


@dataclass(kw_only=True)
class FlowDecl(ASTNode):
    """Flow declaration: flow main { ... }."""

    name: str
    body: BlockStmt


@dataclass(kw_only=True)
class InterruptDecl(ASTNode):
    """Interrupt declaration.

    interrupt {
        priority 10
        when image "error_popup"
        { ... }
    }
    """

    priority: int
    when_asset: str
    body: BlockStmt
    roi: ASTNode | None = None


@dataclass(kw_only=True)
class HotkeysDecl(ASTNode):
    """Hotkeys configuration.

    hotkeys {
        start = "F5"
        stop = "F6"
        pause = "F7"
    }
    """

    bindings: dict[str, str] = field(default_factory=dict)


@dataclass(kw_only=True)
class Program(ASTNode):
    """Root AST node containing all declarations."""

    permissions: list[str] = field(default_factory=list)  # Phase 15
    imports: list[ImportStmt] = field(default_factory=list)  # Phase 3
    hotkeys: HotkeysDecl | None = None
    flows: list[FlowDecl] = field(default_factory=list)
    interrupts: list[InterruptDecl] = field(default_factory=list)
    constants: list[ConstStmt] = field(default_factory=list)

    @property
    def main_flow(self) -> FlowDecl | None:
        """Get the main flow if it exists."""
        for flow in self.flows:
            if flow.name == "main":
                return flow
        return self.flows[0] if self.flows else None


================================================================================
FILE PATH: core\dsl\autocomplete.py
LINES: 343
================================================================================

"""
RetroAuto v2 - DSL Autocomplete Provider

Provides intelligent autocompletion for the DSL:
- Built-in functions
- Keywords
- Asset references
- Flow references
- Variables in scope
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum, auto


class CompletionKind(Enum):
    """Type of completion item."""

    KEYWORD = auto()
    FUNCTION = auto()
    ASSET = auto()
    FLOW = auto()
    VARIABLE = auto()
    SNIPPET = auto()


@dataclass
class CompletionItem:
    """A completion suggestion."""

    label: str
    kind: CompletionKind
    detail: str = ""
    insert_text: str = ""
    documentation: str = ""

    def __post_init__(self) -> None:
        if not self.insert_text:
            self.insert_text = self.label


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Built-in Completions
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

KEYWORDS = [
    CompletionItem("flow", CompletionKind.KEYWORD, "Flow definition"),
    CompletionItem("if", CompletionKind.KEYWORD, "Conditional statement"),
    CompletionItem("elif", CompletionKind.KEYWORD, "Else if clause"),
    CompletionItem("else", CompletionKind.KEYWORD, "Else clause"),
    CompletionItem("while", CompletionKind.KEYWORD, "While loop"),
    CompletionItem("for", CompletionKind.KEYWORD, "For loop"),
    CompletionItem("in", CompletionKind.KEYWORD, "In keyword"),
    CompletionItem("label", CompletionKind.KEYWORD, "Label definition"),
    CompletionItem("goto", CompletionKind.KEYWORD, "Jump to label"),
    CompletionItem("break", CompletionKind.KEYWORD, "Break loop"),
    CompletionItem("continue", CompletionKind.KEYWORD, "Continue loop"),
    CompletionItem("return", CompletionKind.KEYWORD, "Return statement"),
    CompletionItem("hotkeys", CompletionKind.KEYWORD, "Hotkey configuration"),
    CompletionItem("interrupt", CompletionKind.KEYWORD, "Interrupt handler"),
    CompletionItem("true", CompletionKind.KEYWORD, "Boolean true"),
    CompletionItem("false", CompletionKind.KEYWORD, "Boolean false"),
    CompletionItem("null", CompletionKind.KEYWORD, "Null value"),
]

BUILTIN_FUNCTIONS = [
    CompletionItem(
        "wait_image",
        CompletionKind.FUNCTION,
        "Wait for image to appear/disappear",
        'wait_image("$1", timeout=$2)',
        "Wait for an image asset to appear or disappear on screen.",
    ),
    CompletionItem(
        "click",
        CompletionKind.FUNCTION,
        "Click at position",
        "click($1, $2)",
        "Perform a mouse click at (x, y) coordinates.",
    ),
    CompletionItem(
        "click_image",
        CompletionKind.FUNCTION,
        "Click on image match",
        'click_image("$1")',
        "Find an image and click on its center.",
    ),
    CompletionItem(
        "double_click",
        CompletionKind.FUNCTION,
        "Double click at position",
        "double_click($1, $2)",
        "Perform a double click at (x, y) coordinates.",
    ),
    CompletionItem(
        "right_click",
        CompletionKind.FUNCTION,
        "Right click at position",
        "right_click($1, $2)",
        "Perform a right click at (x, y) coordinates.",
    ),
    CompletionItem(
        "drag",
        CompletionKind.FUNCTION,
        "Drag from one point to another",
        "drag($1, $2, $3, $4)",
        "Drag from (x1, y1) to (x2, y2).",
    ),
    CompletionItem(
        "scroll",
        CompletionKind.FUNCTION,
        "Scroll mouse wheel",
        "scroll($1)",
        "Scroll the mouse wheel. Positive = up, negative = down.",
    ),
    CompletionItem(
        "hotkey",
        CompletionKind.FUNCTION,
        "Press keyboard shortcut",
        'hotkey("$1")',
        "Press a keyboard shortcut like 'ctrl+c'.",
    ),
    CompletionItem(
        "type_text",
        CompletionKind.FUNCTION,
        "Type text",
        'type_text("$1")',
        "Type text character by character.",
    ),
    CompletionItem(
        "paste",
        CompletionKind.FUNCTION,
        "Paste text via clipboard",
        'paste("$1")',
        "Paste text using the clipboard (faster for long text).",
    ),
    CompletionItem(
        "sleep",
        CompletionKind.FUNCTION,
        "Wait for duration",
        "sleep($1)",
        "Wait for the specified duration (e.g., 1s, 500ms).",
    ),
    CompletionItem(
        "log",
        CompletionKind.FUNCTION,
        "Log a message",
        'log("$1")',
        "Print a message to the log output.",
    ),
    CompletionItem(
        "run_flow",
        CompletionKind.FUNCTION,
        "Run another flow",
        'run_flow("$1")',
        "Execute another flow by name.",
    ),
    CompletionItem(
        "if_image",
        CompletionKind.FUNCTION,
        "Check if image exists",
        'if_image("$1")',
        "Returns true if the image is currently on screen.",
    ),
    CompletionItem(
        "capture",
        CompletionKind.FUNCTION,
        "Capture screen region",
        'capture($1, $2, $3, $4, "$5")',
        "Capture a screen region and save to file.",
    ),
    CompletionItem(
        "random",
        CompletionKind.FUNCTION,
        "Random number",
        "random($1, $2)",
        "Generate a random integer between min and max.",
    ),
    CompletionItem(
        "range",
        CompletionKind.FUNCTION,
        "Number range",
        "range($1, $2)",
        "Generate a range of numbers for iteration.",
    ),
]

SNIPPETS = [
    CompletionItem(
        "flow_new",
        CompletionKind.SNIPPET,
        "New flow definition",
        "flow $1 {\n  $0\n}",
        "Create a new flow.",
    ),
    CompletionItem(
        "if_block",
        CompletionKind.SNIPPET,
        "If block",
        "if ($1) {\n  $0\n}",
        "Create an if statement.",
    ),
    CompletionItem(
        "if_else",
        CompletionKind.SNIPPET,
        "If-else block",
        "if ($1) {\n  $2\n} else {\n  $0\n}",
        "Create an if-else statement.",
    ),
    CompletionItem(
        "while_loop",
        CompletionKind.SNIPPET,
        "While loop",
        "while ($1) {\n  $0\n}",
        "Create a while loop.",
    ),
    CompletionItem(
        "for_loop",
        CompletionKind.SNIPPET,
        "For loop",
        "for $1 in range($2, $3) {\n  $0\n}",
        "Create a for loop with range.",
    ),
    CompletionItem(
        "label_goto",
        CompletionKind.SNIPPET,
        "Label and goto",
        "label $1:\n$0\ngoto $1;",
        "Create a label with goto jump.",
    ),
    CompletionItem(
        "wait_click",
        CompletionKind.SNIPPET,
        "Wait and click image",
        'wait_image("$1");\nclick_image("$1");',
        "Wait for image to appear then click it.",
    ),
    CompletionItem(
        "interrupt_block",
        CompletionKind.SNIPPET,
        "Interrupt handler",
        'interrupt {\n  priority $1\n  when image "$2"\n  {\n    $0\n  }\n}',
        "Create an interrupt handler.",
    ),
]


class AutocompleteProvider:
    """
    Provides autocompletion suggestions for DSL.

    Usage:
        provider = AutocompleteProvider()
        provider.set_context(assets=["btn_ok", "img_error"], flows=["main", "login"])
        items = provider.complete("wait_")
    """

    def __init__(self) -> None:
        self._assets: list[str] = []
        self._flows: list[str] = []
        self._variables: list[str] = []

    def set_context(
        self,
        assets: list[str] | None = None,
        flows: list[str] | None = None,
        variables: list[str] | None = None,
    ) -> None:
        """Set the context for completions."""
        if assets is not None:
            self._assets = assets
        if flows is not None:
            self._flows = flows
        if variables is not None:
            self._variables = variables

    def complete(self, prefix: str, in_string: bool = False) -> list[CompletionItem]:
        """
        Get completions for a prefix.

        Args:
            prefix: The text to complete
            in_string: If true, only return asset/flow completions

        Returns:
            List of matching completion items
        """
        prefix_lower = prefix.lower()
        results: list[CompletionItem] = []

        if in_string:
            # Inside string - suggest assets and flows
            for asset in self._assets:
                if asset.lower().startswith(prefix_lower):
                    results.append(CompletionItem(asset, CompletionKind.ASSET, "Image asset"))
            for flow in self._flows:
                if flow.lower().startswith(prefix_lower):
                    results.append(CompletionItem(flow, CompletionKind.FLOW, "Flow"))
        else:
            # Normal code context
            # Keywords
            for kw in KEYWORDS:
                if kw.label.lower().startswith(prefix_lower):
                    results.append(kw)

            # Functions
            for fn in BUILTIN_FUNCTIONS:
                if fn.label.lower().startswith(prefix_lower):
                    results.append(fn)

            # Variables
            for var in self._variables:
                if var.lower().startswith(prefix_lower):
                    results.append(CompletionItem(var, CompletionKind.VARIABLE, "Variable"))

            # Snippets (only if prefix is short)
            if len(prefix) <= 3:
                for snippet in SNIPPETS:
                    if snippet.label.lower().startswith(prefix_lower):
                        results.append(snippet)

        return results

    def get_function_signature(self, name: str) -> str | None:
        """Get signature help for a function."""
        for fn in BUILTIN_FUNCTIONS:
            if fn.label == name:
                return fn.insert_text
        return None

    def get_all_functions(self) -> list[CompletionItem]:
        """Get all built-in functions."""
        return BUILTIN_FUNCTIONS.copy()

    def get_all_keywords(self) -> list[CompletionItem]:
        """Get all keywords."""
        return KEYWORDS.copy()

    def get_all_snippets(self) -> list[CompletionItem]:
        """Get all snippets."""
        return SNIPPETS.copy()


================================================================================
FILE PATH: core\dsl\debugger.py
LINES: 370
================================================================================

"""
RetroAuto v2 - Debugger Protocol

Debug adapter for DSL scripts:
- Breakpoint management
- Step execution (step over, step into, step out)
- Variable inspection
- Call stack tracking
"""

from __future__ import annotations

from collections.abc import Callable
from dataclasses import dataclass, field
from enum import Enum, auto
from threading import Lock
from typing import Any


class DebugState(Enum):
    """Debugger state."""

    IDLE = auto()  # Not debugging
    RUNNING = auto()  # Running normally
    PAUSED = auto()  # Paused at breakpoint
    STEPPING = auto()  # Single-stepping


class StepMode(Enum):
    """Step execution mode."""

    OVER = auto()  # Step over (next line)
    INTO = auto()  # Step into function call
    OUT = auto()  # Step out of current function


@dataclass
class Breakpoint:
    """A breakpoint in the script."""

    id: int
    file: str
    line: int
    enabled: bool = True
    condition: str | None = None  # Optional conditional expression
    hit_count: int = 0


@dataclass
class StackFrame:
    """A frame in the call stack."""

    id: int
    name: str  # Flow name or "main"
    file: str
    line: int
    column: int = 1
    locals: dict[str, Any] = field(default_factory=dict)


@dataclass
class Variable:
    """A variable for inspection."""

    name: str
    value: Any
    type: str
    expandable: bool = False
    children: list[Variable] = field(default_factory=list)


class BreakpointManager:
    """
    Manages breakpoints for the debugger.

    Thread-safe breakpoint storage and lookup.
    """

    def __init__(self) -> None:
        self._breakpoints: dict[int, Breakpoint] = {}
        self._next_id = 1
        self._lock = Lock()
        self._by_location: dict[tuple[str, int], int] = {}  # (file, line) -> id

    def add(self, file: str, line: int, condition: str | None = None) -> Breakpoint:
        """Add a new breakpoint."""
        with self._lock:
            # Check if already exists
            key = (file, line)
            if key in self._by_location:
                return self._breakpoints[self._by_location[key]]

            bp = Breakpoint(
                id=self._next_id,
                file=file,
                line=line,
                condition=condition,
            )
            self._breakpoints[self._next_id] = bp
            self._by_location[key] = self._next_id
            self._next_id += 1
            return bp

    def remove(self, bp_id: int) -> bool:
        """Remove a breakpoint by ID."""
        with self._lock:
            if bp_id not in self._breakpoints:
                return False
            bp = self._breakpoints[bp_id]
            del self._by_location[(bp.file, bp.line)]
            del self._breakpoints[bp_id]
            return True

    def toggle(self, bp_id: int) -> bool:
        """Toggle breakpoint enabled state."""
        with self._lock:
            if bp_id in self._breakpoints:
                self._breakpoints[bp_id].enabled = not self._breakpoints[bp_id].enabled
                return True
            return False

    def get(self, bp_id: int) -> Breakpoint | None:
        """Get breakpoint by ID."""
        return self._breakpoints.get(bp_id)

    def get_at(self, file: str, line: int) -> Breakpoint | None:
        """Get breakpoint at file:line."""
        key = (file, line)
        if key in self._by_location:
            return self._breakpoints[self._by_location[key]]
        return None

    def get_all(self) -> list[Breakpoint]:
        """Get all breakpoints."""
        return list(self._breakpoints.values())

    def clear(self) -> None:
        """Remove all breakpoints."""
        with self._lock:
            self._breakpoints.clear()
            self._by_location.clear()

    def has_breakpoint(self, file: str, line: int) -> bool:
        """Check if there's an enabled breakpoint at location."""
        bp = self.get_at(file, line)
        return bp is not None and bp.enabled


class Debugger:
    """
    DSL Script Debugger.

    Provides:
    - Breakpoint-based pausing
    - Step over/into/out execution
    - Variable inspection
    - Call stack tracking

    Signals (via callbacks):
        on_paused: Called when execution pauses (reason, line)
        on_resumed: Called when execution resumes
        on_step: Called for each step (flow, line, action)
        on_stopped: Called when debugging ends
    """

    def __init__(self) -> None:
        self.breakpoints = BreakpointManager()
        self._state = DebugState.IDLE
        self._step_mode: StepMode | None = None
        self._call_stack: list[StackFrame] = []
        self._variables: dict[str, Any] = {}
        self._lock = Lock()
        self._frame_id = 0

        # Callbacks
        self._on_paused: Callable[[str, int], None] | None = None
        self._on_resumed: Callable[[], None] | None = None
        self._on_step: Callable[[str, int, str], None] | None = None
        self._on_stopped: Callable[[], None] | None = None

    @property
    def state(self) -> DebugState:
        """Get current debug state."""
        return self._state

    @property
    def is_paused(self) -> bool:
        """Check if debugger is paused."""
        return self._state == DebugState.PAUSED

    @property
    def call_stack(self) -> list[StackFrame]:
        """Get current call stack."""
        return list(self._call_stack)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Callback Registration
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def on_paused(self, callback: Callable[[str, int], None]) -> None:
        """Register callback for pause events."""
        self._on_paused = callback

    def on_resumed(self, callback: Callable[[], None]) -> None:
        """Register callback for resume events."""
        self._on_resumed = callback

    def on_step(self, callback: Callable[[str, int, str], None]) -> None:
        """Register callback for step events."""
        self._on_step = callback

    def on_stopped(self, callback: Callable[[], None]) -> None:
        """Register callback for stop events."""
        self._on_stopped = callback

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Execution Control
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def start(self) -> None:
        """Start debugging session."""
        self._state = DebugState.RUNNING
        self._call_stack.clear()
        self._variables.clear()
        self._frame_id = 0

    def stop(self) -> None:
        """Stop debugging session."""
        self._state = DebugState.IDLE
        self._call_stack.clear()
        if self._on_stopped:
            self._on_stopped()

    def continue_execution(self) -> None:
        """Continue execution after pause."""
        if self._state == DebugState.PAUSED:
            self._state = DebugState.RUNNING
            self._step_mode = None
            if self._on_resumed:
                self._on_resumed()

    def pause(self) -> None:
        """Pause execution."""
        if self._state == DebugState.RUNNING:
            self._state = DebugState.PAUSED
            if self._on_paused:
                line = self._call_stack[-1].line if self._call_stack else 0
                self._on_paused("user", line)

    def step_over(self) -> None:
        """Step over to next line."""
        self._step_mode = StepMode.OVER
        self._state = DebugState.STEPPING
        if self._on_resumed:
            self._on_resumed()

    def step_into(self) -> None:
        """Step into function call."""
        self._step_mode = StepMode.INTO
        self._state = DebugState.STEPPING
        if self._on_resumed:
            self._on_resumed()

    def step_out(self) -> None:
        """Step out of current function."""
        self._step_mode = StepMode.OUT
        self._state = DebugState.STEPPING
        if self._on_resumed:
            self._on_resumed()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Execution Hooks (called by runner)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def enter_flow(self, flow_name: str, file: str, line: int) -> None:
        """Called when entering a flow."""
        self._frame_id += 1
        frame = StackFrame(
            id=self._frame_id,
            name=flow_name,
            file=file,
            line=line,
        )
        self._call_stack.append(frame)

    def exit_flow(self) -> None:
        """Called when exiting a flow."""
        if self._call_stack:
            self._call_stack.pop()

    def before_step(self, file: str, line: int, action_type: str) -> bool:
        """
        Called before executing a step.

        Returns True if execution should continue, False to pause.
        """
        if self._state == DebugState.IDLE:
            return True

        # Update current frame
        if self._call_stack:
            self._call_stack[-1].line = line

        # Callback
        if self._on_step:
            flow_name = self._call_stack[-1].name if self._call_stack else "main"
            self._on_step(flow_name, line, action_type)

        # Check breakpoint
        if self.breakpoints.has_breakpoint(file, line):
            bp = self.breakpoints.get_at(file, line)
            if bp:
                bp.hit_count += 1
                self._state = DebugState.PAUSED
                if self._on_paused:
                    self._on_paused("breakpoint", line)
                return False

        # Check step mode
        if self._state == DebugState.STEPPING and self._step_mode == StepMode.OVER:
            self._state = DebugState.PAUSED
            if self._on_paused:
                self._on_paused("step", line)
            return False

        return True

    def set_variable(self, name: str, value: Any) -> None:
        """Set a variable value (for inspection)."""
        self._variables[name] = value
        if self._call_stack:
            self._call_stack[-1].locals[name] = value

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Inspection
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def get_variables(self, frame_id: int | None = None) -> list[Variable]:
        """Get variables for a stack frame."""
        frame: StackFrame | None = None
        if frame_id is None and self._call_stack:
            frame = self._call_stack[-1]
        elif frame_id:
            frame = next((f for f in self._call_stack if f.id == frame_id), None)

        if not frame:
            return []

        return [
            Variable(
                name=name,
                value=value,
                type=type(value).__name__,
                expandable=isinstance(value, (dict, list)),
            )
            for name, value in frame.locals.items()
        ]

    def evaluate(self, expression: str) -> tuple[Any, str | None]:
        """
        Evaluate an expression in the current context.

        Returns (value, error_message).
        """
        try:
            # Simple evaluation with current variables
            result = eval(expression, {"__builtins__": {}}, self._variables)
            return result, None
        except Exception as e:
            return None, str(e)


================================================================================
FILE PATH: core\dsl\diagnostics.py
LINES: 204
================================================================================

"""
RetroAuto v2 - DSL Diagnostics

Error types and diagnostic messages for the DSL.
Follows error code convention:
- E100x: Parse errors
- E110x: Semantic errors
- R200x: Runtime errors
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum

from core.dsl.ast import Span


class Severity(Enum):
    """Diagnostic severity level."""

    ERROR = "error"
    WARNING = "warning"
    INFO = "info"
    HINT = "hint"


@dataclass
class QuickFix:
    """Quick fix suggestion for a diagnostic."""

    title: str
    replacement: str | None = None  # Text to insert/replace
    insert_at: Span | None = None  # Where to insert
    action: str | None = None  # Special action like "capture_asset"


@dataclass
class Diagnostic:
    """A diagnostic message (error, warning, etc.)."""

    code: str
    severity: Severity
    message: str
    span: Span
    hint: str | None = None
    quick_fixes: list[QuickFix] | None = None

    def __str__(self) -> str:
        prefix = f"[{self.code}]" if self.code else ""
        location = f"at {self.span}"
        hint_str = f"\n  Hint: {self.hint}" if self.hint else ""
        return f"{prefix} {self.severity.value}: {self.message} {location}{hint_str}"


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Error Code Constants
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# Parse Errors (E100x)
E1001_UNEXPECTED_TOKEN = "E1001"
E1002_EXPECTED_TOKEN = "E1002"
E1003_UNTERMINATED_STRING = "E1003"
E1004_UNTERMINATED_COMMENT = "E1004"
E1005_INVALID_NUMBER = "E1005"
E1006_EXPECTED_EXPRESSION = "E1006"
E1007_EXPECTED_STATEMENT = "E1007"
E1008_EXPECTED_BLOCK = "E1008"
E1009_INVALID_ASSIGNMENT = "E1009"

# Semantic Errors (E110x)
E1101_UNKNOWN_ASSET = "E1101"
E1102_UNKNOWN_FLOW = "E1102"
E1103_UNKNOWN_LABEL = "E1103"
E1104_DUPLICATE_LABEL = "E1104"
E1105_DUPLICATE_FLOW = "E1105"
E1106_UNKNOWN_VARIABLE = "E1106"
E1107_TYPE_MISMATCH = "E1107"
E1108_INVALID_ARGUMENT = "E1108"
E1109_MISSING_ARGUMENT = "E1109"

# Runtime Errors (R200x)
R2001_TIMEOUT = "R2001"
R2002_IMAGE_NOT_FOUND = "R2002"
R2003_FLOW_NOT_FOUND = "R2003"
R2004_INTERRUPT_ERROR = "R2004"
R2005_ASSERTION_FAILED = "R2005"


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Diagnostic Builders
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


def unexpected_token(token_value: str, span: Span) -> Diagnostic:
    """Create unexpected token error."""
    return Diagnostic(
        code=E1001_UNEXPECTED_TOKEN,
        severity=Severity.ERROR,
        message=f"Unexpected token '{token_value}'",
        span=span,
        hint="Check for typos or missing semicolons",
    )


def expected_token(expected: str, got: str, span: Span) -> Diagnostic:
    """Create expected token error."""
    return Diagnostic(
        code=E1002_EXPECTED_TOKEN,
        severity=Severity.ERROR,
        message=f"Expected '{expected}', got '{got}'",
        span=span,
    )


def unknown_asset(asset_id: str, span: Span) -> Diagnostic:
    """Create unknown asset error with quick fix."""
    return Diagnostic(
        code=E1101_UNKNOWN_ASSET,
        severity=Severity.ERROR,
        message=f"Unknown asset '{asset_id}'",
        span=span,
        hint=f"Asset '{asset_id}' is not defined. Capture it first.",
        quick_fixes=[
            QuickFix(
                title=f"Capture new asset '{asset_id}'",
                action="capture_asset",
            ),
        ],
    )


def unknown_flow(flow_name: str, span: Span) -> Diagnostic:
    """Create unknown flow error."""
    return Diagnostic(
        code=E1102_UNKNOWN_FLOW,
        severity=Severity.ERROR,
        message=f"Unknown flow '{flow_name}'",
        span=span,
        hint="Define the flow or check the name spelling",
    )


def unknown_label(label_name: str, span: Span) -> Diagnostic:
    """Create unknown label error."""
    return Diagnostic(
        code=E1103_UNKNOWN_LABEL,
        severity=Severity.ERROR,
        message=f"Unknown label '{label_name}'",
        span=span,
        hint="Define the label before using goto",
    )


def duplicate_label(label_name: str, span: Span, original_span: Span) -> Diagnostic:
    """Create duplicate label error."""
    return Diagnostic(
        code=E1104_DUPLICATE_LABEL,
        severity=Severity.ERROR,
        message=f"Duplicate label '{label_name}'",
        span=span,
        hint=f"Label was first defined at line {original_span.start_line}",
    )


def duplicate_flow(flow_name: str, span: Span, original_span: Span) -> Diagnostic:
    """Create duplicate flow error."""
    return Diagnostic(
        code=E1105_DUPLICATE_FLOW,
        severity=Severity.ERROR,
        message=f"Duplicate flow '{flow_name}'",
        span=span,
        hint=f"Flow was first defined at line {original_span.start_line}",
    )


def type_mismatch(expected: str, got: str, span: Span) -> Diagnostic:
    """Create type mismatch error."""
    return Diagnostic(
        code=E1107_TYPE_MISMATCH,
        severity=Severity.ERROR,
        message=f"Type mismatch: expected {expected}, got {got}",
        span=span,
    )


def invalid_argument(func_name: str, arg_name: str, reason: str, span: Span) -> Diagnostic:
    """Create invalid argument error."""
    return Diagnostic(
        code=E1108_INVALID_ARGUMENT,
        severity=Severity.ERROR,
        message=f"Invalid argument '{arg_name}' for {func_name}: {reason}",
        span=span,
    )


def missing_argument(func_name: str, arg_name: str, span: Span) -> Diagnostic:
    """Create missing argument error."""
    return Diagnostic(
        code=E1109_MISSING_ARGUMENT,
        severity=Severity.ERROR,
        message=f"Missing required argument '{arg_name}' for {func_name}",
        span=span,
    )


================================================================================
FILE PATH: core\dsl\document.py
LINES: 542
================================================================================

"""
RetroAuto v2 - Script Document

Manages the document state for a script:
- Holds the IR (source of truth)
- Syncs code ‚Üî IR ‚Üî GUI
- Handles dirty state and undo/redo
- Graceful error handling with recovery hints
"""

from __future__ import annotations

import re
from collections.abc import Callable
from dataclasses import dataclass
from enum import Enum, auto
from pathlib import Path
from typing import Any

from core.dsl.ir import (
    ActionIR,
    AssetIR,
    FlowIR,
    ScriptIR,
    ir_to_code,
    parse_to_ir,
)
from core.dsl.parser import Parser
from core.dsl.semantic import analyze


class DocumentState(Enum):
    """Document validation state."""

    VALID = auto()  # Code parsed successfully
    ERROR = auto()  # Parse failed, showing errors
    PARTIAL = auto()  # User is typing, incomplete code
    RECOVERING = auto()  # Attempting auto-fix


@dataclass
class ParseError:
    """Enriched parse error with recovery hints."""

    message: str
    line: int = 0
    column: int = 0
    severity: str = "error"  # error, warning, hint
    recovery_hint: str = ""
    quick_fix: str | None = None  # Suggested fix


# Common error recovery patterns
ERROR_RECOVERY_PATTERNS = {
    r"Expected ';'": ("Th√™m ';' ·ªü cu·ªëi d√≤ng", ";"),
    r"Expected '\}'": ("Thi·∫øu '}' ƒë√≥ng block", "}"),
    r"Expected '\)'": ("Thi·∫øu ')' ƒë√≥ng ngo·∫∑c", ")"),
    r"Unknown asset '(\w+)'": ("Asset kh√¥ng t·ªìn t·∫°i. T·∫°o m·ªõi?", None),
    r"Unknown label '(\w+)'": ("Label kh√¥ng t√¨m th·∫•y trong flow", None),
}


class ScriptDocument:
    """
    Document model for a script file.

    Coordinates sync between:
    - Code (DSL text)
    - IR (intermediate representation)
    - GUI (panels and inspectors)

    Features:
    - Graceful degradation on errors
    - Typing detection to avoid error spam
    - Recovery hints and quick fixes

    Usage:
        doc = ScriptDocument()
        doc.load_from_file(path)
        doc.update_from_code(new_code)
        doc.update_from_gui("flows[0].actions[0].params.x", 100)
    """

    def __init__(self) -> None:
        self._ir = ScriptIR()
        self._code = ""
        self._file_path: Path | None = None
        self._is_dirty = False

        # Error handling state
        self._state = DocumentState.VALID
        self._last_valid_ir: ScriptIR | None = None
        self._parse_errors: list[ParseError] = []
        self._last_code_length = 0
        self._typing_direction = 0  # +1 = adding, -1 = deleting

        # Callbacks
        self._on_ir_changed: list[Callable[[str], None]] = []
        self._on_code_changed: list[Callable[[str], None]] = []
        self._on_error: list[Callable[[list[str]], None]] = []
        self._on_state_changed: list[Callable[[DocumentState], None]] = []

        # Sync mode
        self._sync_enabled = True

    @property
    def ir(self) -> ScriptIR:
        """Get the current IR."""
        return self._ir

    @property
    def code(self) -> str:
        """Get the current code."""
        return self._code

    @property
    def file_path(self) -> Path | None:
        """Get the file path."""
        return self._file_path

    @property
    def is_dirty(self) -> bool:
        """Check if document has unsaved changes."""
        return self._is_dirty

    @property
    def is_valid(self) -> bool:
        """Check if the code is valid (parseable)."""
        return self._ir.is_valid

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Callbacks
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def on_ir_changed(self, callback: Callable[[str], None]) -> None:
        """Register callback for IR changes."""
        self._on_ir_changed.append(callback)

    def on_code_changed(self, callback: Callable[[str], None]) -> None:
        """Register callback for code changes."""
        self._on_code_changed.append(callback)

    def on_error(self, callback: Callable[[list[str]], None]) -> None:
        """Register callback for parse errors."""
        self._on_error.append(callback)

    def _notify_ir_changed(self, change_type: str) -> None:
        """Notify IR change listeners."""
        for cb in self._on_ir_changed:
            cb(change_type)

    def _notify_code_changed(self, source: str) -> None:
        """Notify code change listeners."""
        for cb in self._on_code_changed:
            cb(source)

    def _notify_errors(self, errors: list[str]) -> None:
        """Notify error listeners."""
        for cb in self._on_error:
            cb(errors)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # File Operations
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def new(self) -> None:
        """Create a new empty document."""
        self._ir = ScriptIR()
        self._ir.flows.append(FlowIR(name="main"))
        self._code = ir_to_code(self._ir)
        self._file_path = None
        self._is_dirty = False
        self._notify_ir_changed("new")
        self._notify_code_changed("new")

    def load_from_file(self, path: Path) -> bool:
        """
        Load document from file.

        Returns True if successful.
        """
        try:
            content = path.read_text(encoding="utf-8")
            self._file_path = path
            self.update_from_code(content, source="file")
            self._is_dirty = False
            return True
        except Exception as e:
            self._notify_errors([f"Failed to load file: {e}"])
            return False

    def save(self) -> bool:
        """
        Save document to file.

        Returns True if successful.
        """
        if not self._file_path:
            return False

        try:
            self._file_path.write_text(self._code, encoding="utf-8")
            self._is_dirty = False
            return True
        except Exception as e:
            self._notify_errors([f"Failed to save file: {e}"])
            return False

    def save_as(self, path: Path) -> bool:
        """Save document to a new file."""
        self._file_path = path
        return self.save()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Code ‚Üí IR Sync
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def update_from_code(self, new_code: str, source: str = "editor") -> None:
        """
        Update IR from new code.

        Called when the user edits code in the editor.
        Implements graceful degradation on errors.
        """
        if not self._sync_enabled:
            return

        # Track typing direction for partial detection
        code_len_diff = len(new_code) - self._last_code_length
        self._typing_direction = 1 if code_len_diff > 0 else -1 if code_len_diff < 0 else 0
        self._last_code_length = len(new_code)

        self._code = new_code
        self._is_dirty = True

        # Check if user is actively typing (partial code)
        if self._is_typing_in_progress(new_code):
            self._state = DocumentState.PARTIAL
            # Don't parse incomplete code - avoid error spam
            return

        # Parse to IR
        ir, errors = parse_to_ir(new_code)

        if errors:
            # Enrich errors with recovery hints
            enriched_errors = self._enrich_errors(errors)
            self._parse_errors = enriched_errors

            # Keep last valid IR for graceful degradation
            if self._ir.is_valid and self._last_valid_ir is None:
                self._last_valid_ir = self._ir

            # Mark current IR as invalid but don't replace
            self._ir.is_valid = False
            self._ir.parse_errors = [e.message for e in enriched_errors]
            self._state = DocumentState.ERROR

            # Notify with enriched error messages
            self._notify_errors(
                [
                    f"Line {e.line}: {e.message}"
                    + (f" (Hint: {e.recovery_hint})" if e.recovery_hint else "")
                    for e in enriched_errors
                ]
            )
            self._notify_state_changed()
        else:
            # Parse successful - run semantic analysis
            semantic_errors = self._run_semantic_analysis(ir)

            if semantic_errors:
                # Semantic errors are warnings - still update IR
                self._parse_errors = semantic_errors
                for e in semantic_errors:
                    e.severity = "warning"
                self._notify_errors([e.message for e in semantic_errors])

            # Update IR
            self._last_valid_ir = ir  # Save as last valid
            self._ir = ir
            self._ir.is_valid = True
            self._ir.parse_errors = []
            self._parse_errors = []
            self._state = DocumentState.VALID

            self._notify_state_changed()
            self._notify_ir_changed(f"code_{source}")

    def _is_typing_in_progress(self, code: str) -> bool:
        """
        Detect if user is in the middle of typing.

        Returns True if code appears incomplete.
        """
        code = code.rstrip()
        if not code:
            return False

        # Indicators of incomplete code
        incomplete_patterns = [
            code.endswith("("),  # click(
            code.endswith(","),  # click(100,
            code.endswith("{"),  # flow main {
            code.endswith("="),  # asset x =
            code.endswith('"') and code.count('"') % 2 == 1,  # Unclosed string
        ]

        # Also check for recently added text (user is typing)
        if self._typing_direction > 0:  # noqa: SIM102
            # Adding text - check last char is identifier char
            if code and code[-1].isalnum():
                # Might be typing a word
                return True

        return any(incomplete_patterns)

    def _enrich_errors(self, errors: list[str]) -> list[ParseError]:
        """
        Enrich raw error messages with recovery hints and quick fixes.
        """
        enriched = []

        for error in errors:
            # Extract line number if present
            line = 0
            match = re.search(r"line\s*(\d+)", error, re.IGNORECASE)
            if match:
                line = int(match.group(1))

            # Find matching recovery pattern
            hint = ""
            quick_fix = None

            for pattern, (recovery_hint, fix) in ERROR_RECOVERY_PATTERNS.items():
                if re.search(pattern, error, re.IGNORECASE):
                    hint = recovery_hint
                    quick_fix = fix
                    break

            enriched.append(
                ParseError(
                    message=error,
                    line=line,
                    recovery_hint=hint,
                    quick_fix=quick_fix,
                )
            )

        return enriched

    def _run_semantic_analysis(self, ir: ScriptIR) -> list[ParseError]:
        """Run semantic analysis and return errors as ParseError list."""
        errors = []

        # Check asset references
        asset_ids = {a.id for a in ir.assets}
        flow_names = {f.name for f in ir.flows}

        for flow in ir.flows:
            for _i, action in enumerate(flow.actions):
                # Check wait_image/if_image asset references
                if action.action_type in ("wait_image", "if_image", "while_image"):
                    asset_ref = action.params.get("arg0", "")
                    if asset_ref and asset_ref not in asset_ids:
                        errors.append(
                            ParseError(
                                message=f"Unknown asset '{asset_ref}' in {flow.name}",
                                line=action.span_line or 0,
                                severity="warning",
                                recovery_hint=f"Asset '{asset_ref}' kh√¥ng t·ªìn t·∫°i. T·∫°o m·ªõi?",
                            )
                        )

                # Check run_flow references
                if action.action_type == "run_flow":
                    flow_ref = action.params.get("arg0", "")
                    if flow_ref and flow_ref not in flow_names:
                        errors.append(
                            ParseError(
                                message=f"Unknown flow '{flow_ref}'",
                                line=action.span_line or 0,
                                severity="warning",
                                recovery_hint=f"Flow '{flow_ref}' kh√¥ng t√¨m th·∫•y",
                            )
                        )

        return errors

    def _notify_state_changed(self) -> None:
        """Notify state change listeners."""
        for cb in self._on_state_changed:
            cb(self._state)

    def on_state_changed(self, callback: Callable[[DocumentState], None]) -> None:
        """Register callback for state changes."""
        self._on_state_changed.append(callback)

    @property
    def state(self) -> DocumentState:
        """Get current document state."""
        return self._state

    @property
    def parse_errors(self) -> list[ParseError]:
        """Get current parse errors."""
        return self._parse_errors

    @property
    def last_valid_ir(self) -> ScriptIR | None:
        """Get the last successfully parsed IR."""
        return self._last_valid_ir

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # GUI ‚Üí IR ‚Üí Code Sync
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def update_from_gui(self, path: str, value: Any) -> None:
        """
        Update IR from GUI change, then regenerate code.

        Path format: "flows[0].name" or "assets[0].threshold"
        """
        if not self._sync_enabled:
            return

        # Parse path and update IR
        self._update_ir_field(path, value)
        self._is_dirty = True

        # Regenerate code from IR
        self._regenerate_code()

    def _update_ir_field(self, path: str, value: Any) -> None:
        """Update a field in the IR by path."""
        parts = self._parse_path(path)
        obj: Any = self._ir

        for _i, part in enumerate(parts[:-1]):
            obj = obj[part] if isinstance(part, int) else getattr(obj, part)

        final_part = parts[-1]
        if isinstance(final_part, int):
            obj[final_part] = value
        else:
            setattr(obj, final_part, value)

    def _parse_path(self, path: str) -> list[str | int]:
        """Parse a path like 'flows[0].name' into parts."""
        import re

        parts: list[str | int] = []

        for segment in re.split(r"\.", path):
            match = re.match(r"(\w+)\[(\d+)\]", segment)
            if match:
                parts.append(match.group(1))
                parts.append(int(match.group(2)))
            else:
                parts.append(segment)

        return parts

    def _regenerate_code(self) -> None:
        """Regenerate code from current IR."""
        if not self._ir.is_valid:
            return

        # Temporarily disable sync to avoid feedback loop
        self._sync_enabled = False
        try:
            self._code = ir_to_code(self._ir)
            self._notify_code_changed("gui")
        finally:
            self._sync_enabled = True

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # IR Operations
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def add_flow(self, name: str) -> FlowIR:
        """Add a new flow."""
        flow = FlowIR(name=name)
        self._ir.flows.append(flow)
        self._is_dirty = True
        self._regenerate_code()
        self._notify_ir_changed("flow_added")
        return flow

    def remove_flow(self, name: str) -> None:
        """Remove a flow by name."""
        self._ir.flows = [f for f in self._ir.flows if f.name != name]
        self._is_dirty = True
        self._regenerate_code()
        self._notify_ir_changed("flow_removed")

    def add_action_to_flow(self, flow_name: str, action: ActionIR) -> None:
        """Add an action to a flow."""
        flow = self._ir.get_flow(flow_name)
        if flow:
            flow.actions.append(action)
            self._is_dirty = True
            self._regenerate_code()
            self._notify_ir_changed("action_added")

    def add_asset(self, asset: AssetIR) -> None:
        """Add a new asset."""
        self._ir.assets.append(asset)
        self._is_dirty = True
        self._notify_ir_changed("asset_added")

    def remove_asset(self, asset_id: str) -> None:
        """Remove an asset by ID."""
        self._ir.assets = [a for a in self._ir.assets if a.id != asset_id]
        self._is_dirty = True
        self._notify_ir_changed("asset_removed")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Validation
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def validate(self) -> list[str]:
        """
        Validate the current document.

        Returns list of error messages.
        """
        if not self._ir.is_valid:
            return self._ir.parse_errors

        # Parse and run semantic analysis
        parser = Parser(self._code)
        program = parser.parse()

        if parser.errors:
            return [str(e) for e in parser.errors]

        # Semantic analysis
        asset_ids = [a.id for a in self._ir.assets]
        diagnostics = analyze(program, known_assets=asset_ids)

        return [str(d) for d in diagnostics]


================================================================================
FILE PATH: core\dsl\formatter.py
LINES: 447
================================================================================

"""
RetroAuto v2 - DSL Formatter

Pretty printer for DSL code.
Rules:
- 2-space indent
- K&R braces (opening { on same line)
- Keywords lowercase
- Strings always "double quotes"
- Deterministic, idempotent output
- Preserve comments
"""

from __future__ import annotations

from core.dsl.ast import (
    ArrayExpr,
    AssignStmt,
    ASTNode,
    BinaryExpr,
    BlockStmt,
    BreakStmt,
    CallExpr,
    ConstStmt,
    ContinueStmt,
    ExprStmt,
    FlowDecl,
    ForStmt,
    GotoStmt,
    HotkeysDecl,
    Identifier,
    IfStmt,
    InterruptDecl,
    LabelStmt,
    LetStmt,
    Literal,
    Program,
    ReturnStmt,
    TryStmt,
    UnaryExpr,
    WhileStmt,
)


class Formatter:
    """
    DSL code formatter.

    Usage:
        formatter = Formatter()
        formatted_code = formatter.format(program)
    """

    INDENT = "  "  # 2 spaces

    def __init__(self) -> None:
        self.indent_level = 0
        self.output: list[str] = []

    def format(self, program: Program) -> str:
        """Format entire program."""
        self.indent_level = 0
        self.output = []

        # Hotkeys
        if program.hotkeys:
            self._format_hotkeys(program.hotkeys)
            self._newline()

        # Constants
        for const in program.constants:
            self._format_const(const)
            self._newline()

        if program.constants:
            self._newline()

        # Flows
        for i, flow in enumerate(program.flows):
            if i > 0:
                self._newline()
            self._format_flow(flow)

        # Interrupts
        for interrupt in program.interrupts:
            self._newline()
            self._format_interrupt(interrupt)

        return "".join(self.output).rstrip() + "\n"

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Output Helpers
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _write(self, text: str) -> None:
        """Write text to output."""
        self.output.append(text)

    def _indent(self) -> None:
        """Write current indentation."""
        self._write(self.INDENT * self.indent_level)

    def _newline(self) -> None:
        """Write newline."""
        self._write("\n")

    def _write_line(self, text: str) -> None:
        """Write indented line."""
        self._indent()
        self._write(text)
        self._newline()

    def _write_comments(self, node: ASTNode) -> None:
        """Write leading comments for a node."""
        for comment in node.leading_comments:
            self._write_line(comment)

    def _write_trailing_comment(self, node: ASTNode) -> None:
        """Write trailing comment for a node."""
        if node.trailing_comment:
            self._write(f"  {node.trailing_comment}")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Top-level Formatting
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _format_hotkeys(self, hotkeys: HotkeysDecl) -> None:
        """Format hotkeys block."""
        self._write_comments(hotkeys)
        self._write_line("hotkeys {")
        self.indent_level += 1

        for key, value in sorted(hotkeys.bindings.items()):
            self._indent()
            self._write(f'{key} = "{value}"')
            self._newline()

        self.indent_level -= 1
        self._write_line("}")

    def _format_flow(self, flow: FlowDecl) -> None:
        """Format flow declaration."""
        self._write_comments(flow)
        self._indent()
        self._write(f"flow {flow.name} ")
        self._format_block(flow.body, newline_after=True)

    def _format_interrupt(self, interrupt: InterruptDecl) -> None:
        """Format interrupt declaration."""
        self._write_comments(interrupt)
        self._write_line("interrupt {")
        self.indent_level += 1

        self._write_line(f"priority {interrupt.priority}")
        self._write_line(f'when image "{interrupt.when_asset}"')
        self._format_block(interrupt.body, newline_after=True)

        self.indent_level -= 1
        self._write_line("}")

    def _format_const(self, const: ConstStmt) -> None:
        """Format const declaration."""
        self._write_comments(const)
        self._indent()
        self._write(f"const {const.name} = ")
        self._format_expr(const.initializer)
        self._write(";")
        self._write_trailing_comment(const)
        self._newline()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Statement Formatting
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _format_block(self, block: BlockStmt, newline_after: bool = False) -> None:
        """Format block { ... }."""
        self._write("{")
        self._newline()
        self.indent_level += 1

        for stmt in block.statements:
            self._format_statement(stmt)

        self.indent_level -= 1
        self._indent()
        self._write("}")
        if newline_after:
            self._newline()

    def _format_statement(self, stmt: ASTNode) -> None:
        """Format a single statement."""
        self._write_comments(stmt)

        if isinstance(stmt, LabelStmt):
            self._format_label(stmt)
        elif isinstance(stmt, GotoStmt):
            self._format_goto(stmt)
        elif isinstance(stmt, IfStmt):
            self._format_if(stmt)
        elif isinstance(stmt, WhileStmt):
            self._format_while(stmt)
        elif isinstance(stmt, ForStmt):
            self._format_for(stmt)
        elif isinstance(stmt, LetStmt):
            self._format_let(stmt)
        elif isinstance(stmt, AssignStmt):
            self._format_assign(stmt)
        elif isinstance(stmt, BreakStmt):
            self._write_line("break;")
        elif isinstance(stmt, ContinueStmt):
            self._write_line("continue;")
        elif isinstance(stmt, ReturnStmt):
            self._format_return(stmt)
        elif isinstance(stmt, TryStmt):
            self._format_try(stmt)
        elif isinstance(stmt, ExprStmt):
            self._format_expr_stmt(stmt)
        else:
            # Fallback for unknown statements
            self._write_line(f"// Unknown statement: {type(stmt).__name__}")

    def _format_label(self, stmt: LabelStmt) -> None:
        """Format label statement."""
        self._write_line(f"label {stmt.name}:")

    def _format_goto(self, stmt: GotoStmt) -> None:
        """Format goto statement."""
        self._indent()
        self._write(f"goto {stmt.target};")
        self._write_trailing_comment(stmt)
        self._newline()

    def _format_if(self, stmt: IfStmt) -> None:
        """Format if statement."""
        self._indent()
        self._write("if ")
        self._format_expr(stmt.condition)
        self._write(" ")
        self._format_block(stmt.then_branch)

        for elif_cond, elif_body in stmt.elif_branches:
            self._write(" elif ")
            self._format_expr(elif_cond)
            self._write(" ")
            self._format_block(elif_body)

        if stmt.else_branch:
            self._write(" else ")
            self._format_block(stmt.else_branch)

        self._newline()

    def _format_while(self, stmt: WhileStmt) -> None:
        """Format while statement."""
        self._indent()
        self._write("while ")
        self._format_expr(stmt.condition)
        self._write(" ")
        self._format_block(stmt.body)
        self._newline()

    def _format_for(self, stmt: ForStmt) -> None:
        """Format for statement."""
        self._indent()
        self._write(f"for {stmt.variable} in ")
        self._format_expr(stmt.iterable)
        self._write(" ")
        self._format_block(stmt.body)
        self._newline()

    def _format_let(self, stmt: LetStmt) -> None:
        """Format let statement."""
        self._indent()
        self._write(f"let {stmt.name}")
        if stmt.initializer:
            self._write(" = ")
            self._format_expr(stmt.initializer)
        self._write(";")
        self._write_trailing_comment(stmt)
        self._newline()

    def _format_assign(self, stmt: AssignStmt) -> None:
        """Format assignment statement."""
        self._indent()
        self._format_expr(stmt.target)
        self._write(" = ")
        self._format_expr(stmt.value)
        self._write(";")
        self._write_trailing_comment(stmt)
        self._newline()

    def _format_return(self, stmt: ReturnStmt) -> None:
        """Format return statement."""
        self._indent()
        if stmt.value:
            self._write("return ")
            self._format_expr(stmt.value)
            self._write(";")
        else:
            self._write("return;")
        self._write_trailing_comment(stmt)
        self._newline()

    def _format_try(self, stmt: TryStmt) -> None:
        """Format try-catch statement."""
        self._indent()
        self._write("try ")
        self._format_block(stmt.try_block)

        if stmt.catch_block:
            self._write(" catch")
            if stmt.catch_var:
                self._write(f" {stmt.catch_var}")
            self._write(" ")
            self._format_block(stmt.catch_block)

        self._newline()

    def _format_expr_stmt(self, stmt: ExprStmt) -> None:
        """Format expression statement."""
        self._indent()
        self._format_expr(stmt.expr)
        self._write(";")
        self._write_trailing_comment(stmt)
        self._newline()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Expression Formatting
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _format_expr(self, expr: ASTNode) -> None:
        """Format an expression."""
        if isinstance(expr, Literal):
            self._format_literal(expr)
        elif isinstance(expr, Identifier):
            self._write(expr.name)
        elif isinstance(expr, BinaryExpr):
            self._format_binary(expr)
        elif isinstance(expr, UnaryExpr):
            self._format_unary(expr)
        elif isinstance(expr, CallExpr):
            self._format_call(expr)
        elif isinstance(expr, ArrayExpr):
            self._format_array(expr)
        else:
            self._write(f"/* unknown expr: {type(expr).__name__} */")

    def _format_literal(self, lit: Literal) -> None:
        """Format literal value."""
        if lit.literal_type == "string":
            # Always use double quotes
            escaped = str(lit.value).replace("\\", "\\\\").replace('"', '\\"')
            self._write(f'"{escaped}"')
        elif lit.literal_type == "bool":
            self._write("true" if lit.value else "false")
        elif lit.literal_type == "null":
            self._write("null")
        elif lit.literal_type == "duration":
            self._write(str(lit.value))
        else:
            self._write(str(lit.value))

    def _format_binary(self, expr: BinaryExpr) -> None:
        """Format binary expression."""
        needs_parens = isinstance(expr.left, BinaryExpr)
        if needs_parens:
            self._write("(")
        self._format_expr(expr.left)
        if needs_parens:
            self._write(")")

        self._write(f" {expr.operator} ")

        needs_parens = isinstance(expr.right, BinaryExpr)
        if needs_parens:
            self._write("(")
        self._format_expr(expr.right)
        if needs_parens:
            self._write(")")

    def _format_unary(self, expr: UnaryExpr) -> None:
        """Format unary expression."""
        self._write(expr.operator)
        self._format_expr(expr.operand)

    def _format_call(self, expr: CallExpr) -> None:
        """Format function call."""
        # Special case: block end keywords should be formatted as keywords, not function calls
        keyword_map = {
            "end_if": "endif",
            "end_loop": "endloop",
            "end_while": "endwhile",
        }
        if expr.callee in keyword_map:
            self._write(keyword_map[expr.callee])
            return

        self._write(f"{expr.callee}(")

        # Format positional arguments
        parts: list[str] = []
        for arg in expr.args:
            self.output.append("")
            start = len(self.output) - 1
            self._format_expr(arg)
            parts.append("".join(self.output[start:]))
            self.output = self.output[:start]

        # Format keyword arguments
        for key, value in sorted(expr.kwargs.items()):
            self.output.append("")
            start = len(self.output) - 1
            self._format_expr(value)
            val_str = "".join(self.output[start:])
            self.output = self.output[:start]
            parts.append(f"{key}={val_str}")

        self._write(", ".join(parts))
        self._write(")")

    def _format_array(self, expr: ArrayExpr) -> None:
        """Format array literal."""
        self._write("[")
        for i, elem in enumerate(expr.elements):
            if i > 0:
                self._write(", ")
            self._format_expr(elem)
        self._write("]")


def format_code(source: str) -> str:
    """
    Format DSL source code.

    This is idempotent: format(format(code)) == format(code)
    """
    from core.dsl.parser import Parser

    parser = Parser(source)
    program = parser.parse()

    if parser.errors:
        # Return original if there are parse errors
        return source

    formatter = Formatter()
    return formatter.format(program)


================================================================================
FILE PATH: core\dsl\ir.py
LINES: 476
================================================================================

"""
RetroAuto v2 - Intermediate Representation (IR)

The IR serves as the canonical representation for round-trip sync:
- DSL Code ‚Üî IR ‚Üî GUI

When code changes, it's parsed to IR.
When GUI changes, IR is updated and code is regenerated.

This ensures both views stay synchronized.
"""

from __future__ import annotations

from collections.abc import Callable
from dataclasses import dataclass, field
from typing import Any

from core.dsl.ast import FlowDecl, InterruptDecl, Program
from core.dsl.formatter import format_code
from core.dsl.parser import Parser


@dataclass
class AssetIR:
    """Asset representation in IR."""

    id: str
    path: str
    threshold: float = 0.8
    roi: dict[str, int] | None = None  # {x, y, width, height}


@dataclass
class ActionIR:
    """Generic action representation in IR."""

    action_type: str
    params: dict[str, Any] = field(default_factory=dict)
    span_line: int | None = None  # For source mapping


@dataclass
class FlowIR:
    """Flow representation in IR."""

    name: str
    actions: list[ActionIR] = field(default_factory=list)


@dataclass
class InterruptIR:
    """Interrupt representation in IR."""

    priority: int
    when_asset: str
    actions: list[ActionIR] = field(default_factory=list)


@dataclass
class HotkeysIR:
    """Hotkeys configuration in IR."""

    start: str = "F5"
    stop: str = "F6"
    pause: str = "F7"


@dataclass
class ScriptIR:
    """
    Complete script representation in IR.

    This is the single source of truth that both the
    code editor and GUI views sync to.
    """

    name: str = "Untitled"
    version: str = "1.0"
    author: str = ""

    hotkeys: HotkeysIR = field(default_factory=HotkeysIR)
    assets: list[AssetIR] = field(default_factory=list)
    flows: list[FlowIR] = field(default_factory=list)
    interrupts: list[InterruptIR] = field(default_factory=list)

    # Sync state
    is_valid: bool = True
    parse_errors: list[str] = field(default_factory=list)

    # Change listeners
    _listeners: list[Callable[[str], None]] = field(default_factory=list, repr=False)

    def add_listener(self, callback: Callable[[str], None]) -> None:
        """Add a listener for IR changes."""
        self._listeners.append(callback)

    def remove_listener(self, callback: Callable[[str], None]) -> None:
        """Remove a change listener."""
        if callback in self._listeners:
            self._listeners.remove(callback)

    def notify_change(self, change_type: str) -> None:
        """Notify all listeners of a change."""
        for listener in self._listeners:
            listener(change_type)

    # Asset operations
    def get_asset(self, asset_id: str) -> AssetIR | None:
        """Get asset by ID."""
        return next((a for a in self.assets if a.id == asset_id), None)

    def add_asset(self, asset: AssetIR) -> None:
        """Add a new asset."""
        self.assets.append(asset)
        self.notify_change("asset_added")

    def remove_asset(self, asset_id: str) -> None:
        """Remove an asset by ID."""
        self.assets = [a for a in self.assets if a.id != asset_id]
        self.notify_change("asset_removed")

    # Flow operations
    def get_flow(self, name: str) -> FlowIR | None:
        """Get flow by name."""
        return next((f for f in self.flows if f.name == name), None)

    def add_flow(self, flow: FlowIR) -> None:
        """Add a new flow."""
        self.flows.append(flow)
        self.notify_change("flow_added")

    def remove_flow(self, name: str) -> None:
        """Remove a flow by name."""
        self.flows = [f for f in self.flows if f.name != name]
        self.notify_change("flow_removed")


class IRMapper:
    """
    Maps between DSL AST and IR.

    Provides bidirectional conversion:
    - AST ‚Üí IR: For parsing code to IR
    - IR ‚Üí Code: For generating code from IR
    """

    @staticmethod
    def ast_to_ir(program: Program, source: str = "") -> ScriptIR:
        """Convert parsed AST to IR."""
        ir = ScriptIR()

        # Hotkeys
        if program.hotkeys:
            ir.hotkeys = HotkeysIR(
                start=program.hotkeys.bindings.get("start", "F5"),
                stop=program.hotkeys.bindings.get("stop", "F6"),
                pause=program.hotkeys.bindings.get("pause", "F7"),
            )

        # Flows
        for flow_decl in program.flows:
            flow_ir = IRMapper._flow_to_ir(flow_decl)
            ir.flows.append(flow_ir)

        # Interrupts
        for interrupt in program.interrupts:
            interrupt_ir = IRMapper._interrupt_to_ir(interrupt)
            ir.interrupts.append(interrupt_ir)

        return ir

    @staticmethod
    def _flow_to_ir(flow: FlowDecl) -> FlowIR:
        """Convert flow declaration to IR."""
        flow_ir = FlowIR(name=flow.name)

        for stmt in flow.body.statements:
            action = IRMapper._statement_to_action(stmt)
            if action:
                flow_ir.actions.append(action)

        return flow_ir

    @staticmethod
    def _interrupt_to_ir(interrupt: InterruptDecl) -> InterruptIR:
        """Convert interrupt declaration to IR."""
        interrupt_ir = InterruptIR(
            priority=interrupt.priority,
            when_asset=interrupt.when_asset,
        )

        for stmt in interrupt.body.statements:
            action = IRMapper._statement_to_action(stmt)
            if action:
                interrupt_ir.actions.append(action)

        return interrupt_ir

    @staticmethod
    def _statement_to_action(stmt: Any) -> ActionIR | None:
        """Convert statement to action IR."""
        from core.dsl.ast import (
            BreakStmt,
            CallExpr,
            ContinueStmt,
            ExprStmt,
            ForStmt,
            GotoStmt,
            IfStmt,
            LabelStmt,
            ReturnStmt,
            WhileStmt,
        )

        if isinstance(stmt, ExprStmt) and isinstance(stmt.expr, CallExpr):
            call = stmt.expr
            return ActionIR(
                action_type=call.callee,
                params=IRMapper._extract_call_params(call),
                span_line=stmt.span.start_line,
            )

        if isinstance(stmt, LabelStmt):
            return ActionIR(
                action_type="label",
                params={"name": stmt.name},
                span_line=stmt.span.start_line,
            )

        if isinstance(stmt, GotoStmt):
            return ActionIR(
                action_type="goto",
                params={"target": stmt.target},
                span_line=stmt.span.start_line,
            )

        if isinstance(stmt, IfStmt):
            return ActionIR(
                action_type="if",
                params={"has_else": stmt.else_branch is not None},
                span_line=stmt.span.start_line,
            )

        # For complex statements, just track type
        if isinstance(stmt, WhileStmt):
            return ActionIR(action_type="while", span_line=stmt.span.start_line)
        if isinstance(stmt, ForStmt):
            return ActionIR(
                action_type="for",
                params={"variable": stmt.variable},
                span_line=stmt.span.start_line,
            )
        if isinstance(stmt, BreakStmt):
            return ActionIR(action_type="break", span_line=stmt.span.start_line)
        if isinstance(stmt, ContinueStmt):
            return ActionIR(action_type="continue", span_line=stmt.span.start_line)
        if isinstance(stmt, ReturnStmt):
            return ActionIR(action_type="return", span_line=stmt.span.start_line)

        return None

    @staticmethod
    def _extract_call_params(call: Any) -> dict[str, Any]:
        """Extract parameters from a CallExpr."""
        from core.dsl.ast import Identifier, Literal

        params: dict[str, Any] = {}

        # Positional args
        for i, arg in enumerate(call.args):
            if isinstance(arg, Literal):
                params[f"arg{i}"] = arg.value
            elif isinstance(arg, Identifier):
                params[f"arg{i}"] = arg.name

        # Keyword args
        for key, value in call.kwargs.items():
            if isinstance(value, Literal):
                params[key] = value.value
            elif isinstance(value, Identifier):
                params[key] = value.name

        return params

    @staticmethod
    def ir_to_code(ir: ScriptIR) -> str:
        """Generate DSL code from IR using parser-compatible syntax."""
        lines: list[str] = []

        # Header comment
        lines.append("// Generated by RetroAuto v2")
        lines.append("")

        # Hotkeys block
        lines.append("hotkeys {")
        lines.append(f'  start = "{ir.hotkeys.start}";')
        lines.append(f'  stop = "{ir.hotkeys.stop}";')
        lines.append(f'  pause = "{ir.hotkeys.pause}";')
        lines.append("}")
        lines.append("")

        # Flows
        for flow in ir.flows:
            lines.append(f"flow {flow.name} {{")
            if flow.actions:
                for action in flow.actions:
                    code = IRMapper._action_to_code(action)
                    lines.append(f"  {code}")
            else:
                lines.append("  // Empty flow")
            lines.append("}")
            lines.append("")

        # Interrupts
        for interrupt in ir.interrupts:
            lines.append("interrupt {")
            lines.append(f"  priority {interrupt.priority};")
            if interrupt.when_asset:
                lines.append(f'  when image "{interrupt.when_asset}";')
            lines.append("  {")
            for action in interrupt.actions:
                code = IRMapper._action_to_code(action)
                lines.append(f"    {code}")
            lines.append("  }")
            lines.append("}")
            lines.append("")

        return "\n".join(lines)

    @staticmethod
    def _action_to_code(action: ActionIR) -> str:
        """Convert action IR to code string with validation."""
        action_type = action.action_type
        params = action.params

        # Label - validate name
        if action_type == "label":
            name = params.get("name", "")
            if not name or not name.strip():
                return "// label (empty name)"
            return f"label {name}:"

        # Goto - validate target
        if action_type == "goto":
            target = params.get("target", "")
            if not target or not target.strip():
                return "// goto (empty target)"
            return f"goto {target};"

        # Control flow
        if action_type in ("break", "continue", "return"):
            return f"{action_type};"

        # Block markers - output as keywords (not comments!)
        if action_type in ("end_if", "endif"):
            return "endif;"
        if action_type in ("end_loop", "endloop"):
            return "endloop;"
        if action_type in ("end_while", "endwhile"):
            return "endwhile;"
        if action_type == "else":
            return "// else"

        # Special action types that need custom handling
        if action_type == "click_image":
            asset = params.get("asset_id", params.get("arg0", ""))
            return f'click_image("{asset}");'

        if action_type == "click_random":
            x1 = params.get("x1", params.get("from_x", 0))
            y1 = params.get("y1", params.get("from_y", 0))
            x2 = params.get("x2", params.get("to_x", 100))
            y2 = params.get("y2", params.get("to_y", 100))
            return f"click_random({x1}, {y1}, {x2}, {y2});"

        if action_type == "read_text":
            var = params.get("variable_name", "text")
            return f'read_text("{var}");'

        if action_type == "if_text":
            var = params.get("variable_name", "")
            op = params.get("operator", "contains")
            val = params.get("value", "")
            return f'if_text("{var}", "{op}", "{val}");'

        if action_type == "notify":
            msg = params.get("message", params.get("arg0", ""))
            method = params.get("method", "popup")
            return f'notify("{msg}", method="{method}");'

        # Generic function call
        args = []
        kwargs = []

        for key, value in params.items():
            if key.startswith("arg"):
                if isinstance(value, str):
                    args.append(f'"{value}"')
                else:
                    args.append(str(value))
            else:
                if isinstance(value, str):
                    kwargs.append(f'{key}="{value}"')
                elif isinstance(value, bool):
                    kwargs.append(f"{key}={str(value).lower()}")
                else:
                    kwargs.append(f"{key}={value}")

        all_args = ", ".join(args + kwargs)
        return f"{action_type}({all_args});"

    @staticmethod
    def _action_to_code_v9(action: ActionIR) -> str:
        """Convert action IR to RetroScript 9.0 code (no semicolons)."""
        if action.action_type == "label":
            return f"label {action.params.get('name', 'unnamed')}:"

        if action.action_type == "goto":
            return f"goto {action.params.get('target', 'unknown')}"

        if action.action_type in ("break", "continue", "return"):
            return action.action_type

        # Function call - build args
        args = []
        kwargs = []

        for key, value in action.params.items():
            if key.startswith("arg"):
                if isinstance(value, str):
                    args.append(f'"{value}"')
                else:
                    args.append(str(value))
            else:
                if isinstance(value, str):
                    kwargs.append(f'{key}: "{value}"')
                elif isinstance(value, bool):
                    kwargs.append(f"{key}: {str(value).lower()}")
                else:
                    kwargs.append(f"{key}: {value}")

        all_args = ", ".join(args + kwargs)
        return f"{action.action_type}({all_args})"


def parse_to_ir(source: str) -> tuple[ScriptIR, list[str]]:
    """
    Parse DSL source code to IR.

    Returns:
        Tuple of (ScriptIR, list of error messages)
    """
    parser = Parser(source)
    program = parser.parse()

    errors = [str(e) for e in parser.errors]

    if errors:
        # Return empty IR with errors
        ir = ScriptIR(is_valid=False, parse_errors=errors)
        return ir, errors

    ir = IRMapper.ast_to_ir(program, source)
    ir.is_valid = True
    return ir, []


def ir_to_code(ir: ScriptIR) -> str:
    """
    Generate DSL code from IR.

    The output is formatted per DSL spec.
    """
    raw_code = IRMapper.ir_to_code(ir)
    return format_code(raw_code)


================================================================================
FILE PATH: core\dsl\lexer.py
LINES: 376
================================================================================

"""
RetroAuto v2 - DSL Lexer

Tokenizes DSL source code into a stream of tokens.
Supports:
- Keywords (flow, if, while, etc.)
- Identifiers
- Literals (strings, numbers, durations, booleans)
- Operators and delimiters
- Comments (line and block)
"""

from __future__ import annotations

from core.dsl.tokens import KEYWORDS, Token, TokenType


class LexerError(Exception):
    """Lexer error with position information."""

    def __init__(self, message: str, line: int, column: int) -> None:
        self.message = message
        self.line = line
        self.column = column
        super().__init__(f"{message} at line {line}, column {column}")


class Lexer:
    """
    DSL Lexer - converts source code to tokens.

    Usage:
        lexer = Lexer(source_code)
        tokens = lexer.tokenize()
    """

    def __init__(self, source: str) -> None:
        self.source = source
        self.pos = 0
        self.line = 1
        self.column = 1
        self.tokens: list[Token] = []
        self.errors: list[LexerError] = []

    def tokenize(self) -> list[Token]:
        """Tokenize the source code and return list of tokens."""
        self.tokens = []
        self.errors = []
        self.pos = 0
        self.line = 1
        self.column = 1

        while not self._at_end():
            self._scan_token()

        # Add EOF token
        self.tokens.append(Token(TokenType.EOF, "", self.line, self.column))
        return self.tokens

    def _at_end(self) -> bool:
        """Check if we've reached the end of source."""
        return self.pos >= len(self.source)

    def _peek(self, offset: int = 0) -> str:
        """Look at character at current position + offset."""
        idx = self.pos + offset
        if idx >= len(self.source):
            return "\0"
        return self.source[idx]

    def _advance(self) -> str:
        """Consume and return current character."""
        char = self._peek()
        self.pos += 1
        if char == "\n":
            self.line += 1
            self.column = 1
        else:
            self.column += 1
        return char

    def _match(self, expected: str) -> bool:
        """Consume character if it matches expected."""
        if self._peek() == expected:
            self._advance()
            return True
        return False

    def _add_token(
        self,
        token_type: TokenType,
        value: str,
        start_line: int,
        start_col: int,
    ) -> None:
        """Add a token to the list."""
        self.tokens.append(Token(token_type, value, start_line, start_col, self.line, self.column))

    def _skip_whitespace(self) -> None:
        """Skip spaces and tabs (not newlines)."""
        while self._peek() in " \t\r":
            self._advance()

    def _scan_token(self) -> None:
        """Scan and add the next token."""
        self._skip_whitespace()

        if self._at_end():
            return

        start_line = self.line
        start_col = self.column
        char = self._peek()

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Newlines
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if char == "\n":
            self._advance()
            # Skip newlines as whitespace (DSL is not newline-sensitive)
            return

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Comments (// and #)
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if char == "/":
            if self._peek(1) == "/":
                self._scan_line_comment(start_line, start_col)
                return
            elif self._peek(1) == "*":
                self._scan_block_comment(start_line, start_col)
                return

        # RetroScript: # for line comments
        if char == "#":
            self._scan_hash_comment(start_line, start_col)
            return

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Strings
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if char in "\"'":
            self._scan_string(start_line, start_col)
            return

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Numbers and Durations
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if char.isdigit():
            self._scan_number(start_line, start_col)
            return

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # RetroScript: $variable
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if char == "$":
            self._scan_variable(start_line, start_col)
            return

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # RetroScript Phase 2: @ decorator (@test, @config, etc.)
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if char == "@":
            self._scan_at_decorator(start_line, start_col)
            return

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Identifiers and Keywords
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if char.isalpha() or char == "_":
            self._scan_identifier(start_line, start_col)
            return

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Operators and Delimiters
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self._scan_operator(start_line, start_col)

    def _scan_line_comment(self, start_line: int, start_col: int) -> None:
        """Scan // line comment."""
        self._advance()  # /
        self._advance()  # /
        start = self.pos
        while not self._at_end() and self._peek() != "\n":
            self._advance()
        value = "//" + self.source[start : self.pos]
        self._add_token(TokenType.LINE_COMMENT, value, start_line, start_col)

    def _scan_hash_comment(self, start_line: int, start_col: int) -> None:
        """Scan # line comment (RetroScript style)."""
        self._advance()  # #
        start = self.pos
        while not self._at_end() and self._peek() != "\n":
            self._advance()
        value = "#" + self.source[start : self.pos]
        self._add_token(TokenType.LINE_COMMENT, value, start_line, start_col)

    def _scan_variable(self, start_line: int, start_col: int) -> None:
        """Scan $variable name (RetroScript)."""
        self._advance()  # $
        start = self.pos

        if not (self._peek().isalpha() or self._peek() == "_"):
            self.errors.append(LexerError("Expected variable name after $", start_line, start_col))
            self._add_token(TokenType.ERROR, "$", start_line, start_col)
            return

        while self._peek().isalnum() or self._peek() == "_":
            self._advance()

        value = "$" + self.source[start : self.pos]
        self._add_token(TokenType.VARIABLE, value, start_line, start_col)

    def _scan_at_decorator(self, start_line: int, start_col: int) -> None:
        """Scan @decorator (RetroScript Phase 2).

        @test, @config, @permissions, @meta -> AT_SIGN token followed by keyword
        """
        self._advance()  # @
        self._add_token(TokenType.AT_SIGN, "@", start_line, start_col)

        # Now scan the identifier that follows
        if self._peek().isalpha() or self._peek() == "_":
            ident_start_line = self.line
            ident_start_col = self.column
            self._scan_identifier(ident_start_line, ident_start_col)

    def _scan_block_comment(self, start_line: int, start_col: int) -> None:
        """Scan /* block comment */."""
        self._advance()  # /
        self._advance()  # *
        start = self.pos
        while not self._at_end():
            if self._peek() == "*" and self._peek(1) == "/":
                value = "/*" + self.source[start : self.pos] + "*/"
                self._advance()  # *
                self._advance()  # /
                self._add_token(TokenType.BLOCK_COMMENT, value, start_line, start_col)
                return
            self._advance()
        # Unterminated block comment
        self.errors.append(LexerError("Unterminated block comment", start_line, start_col))
        value = "/*" + self.source[start : self.pos]
        self._add_token(TokenType.ERROR, value, start_line, start_col)

    def _scan_string(self, start_line: int, start_col: int) -> None:
        """Scan string literal."""
        quote = self._advance()  # " or '
        chars: list[str] = []

        while not self._at_end() and self._peek() != quote:
            if self._peek() == "\n":
                self.errors.append(LexerError("Unterminated string", start_line, start_col))
                self._add_token(TokenType.ERROR, quote + "".join(chars), start_line, start_col)
                return
            if self._peek() == "\\":
                self._advance()  # backslash
                escape_char = self._advance()
                escape_map = {"n": "\n", "t": "\t", "r": "\r", "\\": "\\", '"': '"', "'": "'"}
                chars.append(escape_map.get(escape_char, escape_char))
            else:
                chars.append(self._advance())

        if self._at_end():
            self.errors.append(LexerError("Unterminated string", start_line, start_col))
            self._add_token(TokenType.ERROR, quote + "".join(chars), start_line, start_col)
            return

        self._advance()  # closing quote
        value = "".join(chars)
        self._add_token(TokenType.STRING, value, start_line, start_col)

    def _scan_number(self, start_line: int, start_col: int) -> None:
        """Scan integer, float, or duration literal."""
        start = self.pos

        # Consume digits
        while self._peek().isdigit():
            self._advance()

        # Check for float
        if self._peek() == "." and self._peek(1).isdigit():
            self._advance()  # .
            while self._peek().isdigit():
                self._advance()
            value = self.source[start : self.pos]
            self._add_token(TokenType.FLOAT, value, start_line, start_col)
            return

        # Check for duration suffix
        suffix_start = self.pos
        while self._peek().isalpha():
            self._advance()

        suffix = self.source[suffix_start : self.pos].lower()
        if suffix in ("ms", "s", "m", "h"):
            value = self.source[start : self.pos]
            self._add_token(TokenType.DURATION, value, start_line, start_col)
        else:
            # Backtrack if there was an invalid suffix (treat as identifier later)
            self.pos = suffix_start
            self.column -= len(suffix)
            value = self.source[start : self.pos]
            self._add_token(TokenType.INTEGER, value, start_line, start_col)

    def _scan_identifier(self, start_line: int, start_col: int) -> None:
        """Scan identifier or keyword."""
        start = self.pos

        while self._peek().isalnum() or self._peek() == "_":
            self._advance()

        value = self.source[start : self.pos]
        token_type = KEYWORDS.get(value.lower(), TokenType.IDENTIFIER)

        # Keywords should be lowercase
        if token_type != TokenType.IDENTIFIER:
            value = value.lower()

        self._add_token(token_type, value, start_line, start_col)

    def _scan_operator(self, start_line: int, start_col: int) -> None:
        """Scan operator or delimiter."""
        char = self._advance()

        # Two-character operators
        two_char_ops = {
            "==": TokenType.EQ,
            "!=": TokenType.NEQ,
            "<=": TokenType.LTE,
            ">=": TokenType.GTE,
            "&&": TokenType.AND,
            "||": TokenType.OR,
            "->": TokenType.ARROW,
        }

        # Check for Unicode arrow first
        if char == "‚Üí":
            self._add_token(TokenType.ARROW, "‚Üí", start_line, start_col)
            return

        for op, token_type in two_char_ops.items():
            if char == op[0] and self._peek() == op[1]:
                self._advance()
                self._add_token(token_type, op, start_line, start_col)
                return

        # Single-character operators/delimiters
        single_char_ops = {
            "+": TokenType.PLUS,
            "-": TokenType.MINUS,
            "*": TokenType.STAR,
            "/": TokenType.SLASH,
            "%": TokenType.PERCENT,
            "<": TokenType.LT,
            ">": TokenType.GT,
            "!": TokenType.NOT,
            "=": TokenType.ASSIGN,
            "(": TokenType.LPAREN,
            ")": TokenType.RPAREN,
            "{": TokenType.LBRACE,
            "}": TokenType.RBRACE,
            "[": TokenType.LBRACKET,
            "]": TokenType.RBRACKET,
            ";": TokenType.SEMICOLON,
            ":": TokenType.COLON,
            ",": TokenType.COMMA,
            ".": TokenType.DOT,
        }

        if char in single_char_ops:
            self._add_token(single_char_ops[char], char, start_line, start_col)
        else:
            # Unknown character
            self.errors.append(LexerError(f"Unexpected character '{char}'", start_line, start_col))
            self._add_token(TokenType.ERROR, char, start_line, start_col)


================================================================================
FILE PATH: core\dsl\module_loader.py
LINES: 157
================================================================================

"""
RetroAuto v2 - Module Loader

Handles import resolution, caching, and circular dependency detection.
Part of RetroScript Phase 3 - Package Manager + Ecosystem.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from core.dsl.ast import Program


@dataclass
class LoadedModule:
    """Represents a loaded module."""

    path: str  # Absolute path to module
    alias: str | None  # Import alias
    ast: Program | None = None  # Parsed AST
    exports: dict[str, any] = field(default_factory=dict)  # Exported symbols


class ModuleLoader:
    """Module loader with caching and circular dependency detection.

    Usage:
        loader = ModuleLoader(base_path="/path/to/scripts")
        module = loader.load("lib/combat")
        # Access module.ast or module.exports
    """

    def __init__(self, base_path: str | Path | None = None) -> None:
        """Initialize module loader.

        Args:
            base_path: Base directory for resolving imports
        """
        self.base_path = Path(base_path) if base_path else Path.cwd()
        self._cache: dict[str, LoadedModule] = {}
        self._loading: set[str] = set()  # For circular dependency detection
        self._search_paths: list[Path] = [
            self.base_path,
            self.base_path / "lib",
            self.base_path / "modules",
        ]

    def add_search_path(self, path: str | Path) -> None:
        """Add a path to search for modules."""
        self._search_paths.append(Path(path))

    def resolve_path(self, import_path: str) -> Path | None:
        """Resolve import path to absolute file path.

        Args:
            import_path: Import path from the source (e.g., "lib/combat")

        Returns:
            Absolute path to the module file, or None if not found
        """
        # Try with .retro extension first
        for search_path in self._search_paths:
            # Try exact path with extension
            candidate = search_path / f"{import_path}.retro"
            if candidate.exists():
                return candidate

            # Try without extension (for directories with index.retro)
            candidate_index = search_path / import_path / "index.retro"
            if candidate_index.exists():
                return candidate_index

            # Try as absolute/relative path
            candidate_direct = Path(import_path)
            if candidate_direct.exists():
                return candidate_direct

        return None

    def load(self, import_path: str, alias: str | None = None) -> LoadedModule | None:
        """Load a module by import path.

        Args:
            import_path: Path from import statement
            alias: Optional alias for the module

        Returns:
            LoadedModule if successful, None if not found

        Raises:
            ModuleError: If circular dependency detected
        """
        # Resolve to absolute path
        resolved = self.resolve_path(import_path)
        if not resolved:
            return None

        abs_path = str(resolved.resolve())

        # Check cache
        if abs_path in self._cache:
            return self._cache[abs_path]

        # Detect circular dependency
        if abs_path in self._loading:
            raise ModuleError(f"Circular dependency detected: {import_path}")

        self._loading.add(abs_path)

        try:
            # Read and parse module
            source = resolved.read_text(encoding="utf-8")

            # Import parser here to avoid circular import
            from core.dsl.parser import Parser

            parser = Parser(source)
            ast = parser.parse()

            # Create module
            module = LoadedModule(
                path=abs_path,
                alias=alias or import_path.split("/")[-1],
                ast=ast,
            )

            # Cache it
            self._cache[abs_path] = module

            # Process nested imports
            for import_stmt in ast.imports:
                nested = self.load(import_stmt.path, import_stmt.alias)
                if nested:
                    module.exports[nested.alias] = nested

            return module

        finally:
            self._loading.discard(abs_path)

    def get_cached(self, path: str) -> LoadedModule | None:
        """Get a cached module by path."""
        return self._cache.get(path)

    def clear_cache(self) -> None:
        """Clear all cached modules."""
        self._cache.clear()


class ModuleError(Exception):
    """Error during module loading."""

    pass


================================================================================
FILE PATH: core\dsl\parser.py
LINES: 1226
================================================================================

"""
RetroAuto v2 - DSL Parser

Recursive descent parser with error recovery.
Produces AST with precise span tracking.
"""

from __future__ import annotations

from typing import Any

from core.dsl.ast import (
    ArrayExpr,
    AssignStmt,
    ASTNode,
    BinaryExpr,
    BlockStmt,
    BreakStmt,
    CallExpr,
    ConstStmt,
    ContinueStmt,
    ExprStmt,
    FlowDecl,
    ForStmt,
    GotoStmt,
    HotkeysDecl,
    Identifier,
    IfStmt,
    ImportStmt,  # Phase 3
    InterruptDecl,
    LabelStmt,
    LetStmt,
    Literal,
    Program,
    ReturnStmt,
    Span,
    TryStmt,
    UnaryExpr,
    WhileStmt,
)
from core.dsl.diagnostics import (
    Diagnostic,
    Severity,
    expected_token,
    unexpected_token,
)
from core.dsl.lexer import Lexer
from core.dsl.tokens import Token, TokenType


class ParseError(Exception):
    """Parse error for internal use."""

    def __init__(self, diagnostic: Diagnostic) -> None:
        self.diagnostic = diagnostic
        super().__init__(diagnostic.message)


class Parser:
    """
    DSL Parser - converts tokens to AST.

    Features:
    - Recursive descent parsing
    - Error recovery (synchronize at statement boundaries)
    - Comment preservation
    - Precise span tracking

    Usage:
        parser = Parser(source_code)
        program = parser.parse()
        if parser.errors:
            print(parser.errors)
    """

    def __init__(self, source: str) -> None:
        self.source = source
        self.tokens: list[Token] = []
        self.pos = 0
        self.errors: list[Diagnostic] = []
        self.comments: list[Token] = []  # Collected comments

    def parse(self) -> Program:
        """Parse source code and return AST."""
        # Tokenize
        lexer = Lexer(self.source)
        all_tokens = lexer.tokenize()

        # Separate comments from tokens
        self.tokens = []
        self.comments = []
        for token in all_tokens:
            if token.type in (TokenType.LINE_COMMENT, TokenType.BLOCK_COMMENT):
                self.comments.append(token)
            else:
                self.tokens.append(token)

        # Add lexer errors
        for err in lexer.errors:
            self.errors.append(
                Diagnostic(
                    code="E1003",
                    severity=Severity.ERROR,
                    message=err.message,
                    span=Span(err.line, err.column, err.line, err.column + 1),
                )
            )

        self.pos = 0

        # Parse program
        return self._parse_program()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Token Handling
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _at_end(self) -> bool:
        """Check if at end of tokens."""
        return self._peek().type == TokenType.EOF

    def _peek(self, offset: int = 0) -> Token:
        """Look at current token."""
        idx = self.pos + offset
        if idx >= len(self.tokens):
            return self.tokens[-1]  # EOF
        return self.tokens[idx]

    def _advance(self) -> Token:
        """Consume and return current token."""
        token = self._peek()
        if not self._at_end():
            self.pos += 1
        return token

    def _check(self, *types: TokenType) -> bool:
        """Check if current token is of given type."""
        if self._at_end():
            return False
        return self._peek().type in types

    def _match(self, *types: TokenType) -> Token | None:
        """Consume token if it matches, return it or None."""
        if self._check(*types):
            return self._advance()
        return None

    def _expect(self, token_type: TokenType, message: str = "") -> Token:
        """Consume token or raise error."""
        if self._check(token_type):
            return self._advance()
        current = self._peek()
        expected_name = token_type.name.lower()
        raise ParseError(expected_token(expected_name, current.value, Span.from_token(current)))

    def _span_from(self, start_token: Token) -> Span:
        """Create span from start token to current position."""
        end_token = self.tokens[max(0, self.pos - 1)]
        return Span(
            start_token.line,
            start_token.column,
            end_token.end_line,
            end_token.end_column,
        )

    def _synchronize(self) -> None:
        """Recover from parse error by skipping to next statement boundary."""
        self._advance()

        while not self._at_end():
            # Sync at statement boundaries
            if self._peek(-1).type == TokenType.SEMICOLON:
                return

            # Sync at block starts
            if self._check(
                TokenType.FLOW,
                TokenType.INTERRUPT,
                TokenType.HOTKEYS,
                TokenType.IF,
                TokenType.WHILE,
                TokenType.FOR,
                TokenType.LABEL,
                TokenType.RETURN,
                TokenType.BREAK,
                TokenType.CONTINUE,
                TokenType.RBRACE,
            ):
                return

            self._advance()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Top-level Parsing
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _parse_program(self) -> Program:
        """Parse entire program."""
        start = self._peek()
        hotkeys: HotkeysDecl | None = None
        flows: list[FlowDecl] = []
        interrupts: list[InterruptDecl] = []
        constants: list[ConstStmt] = []
        imports: list[ImportStmt] = []  # Phase 3: imports list
        permissions: list[str] = []  # Phase 15: permissions

        while not self._at_end():
            try:
                # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                # Phase 3: import statements at top of file
                # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                if self._check(TokenType.IMPORT):
                    imports.append(self._parse_import())
                elif self._check(TokenType.HOTKEYS):
                    hotkeys = self._parse_hotkeys()
                elif self._check(TokenType.FLOW):
                    flows.append(self._parse_flow())
                elif self._check(TokenType.INTERRUPT):
                    interrupts.append(self._parse_interrupt())
                elif self._check(TokenType.CONST):
                    constants.append(self._parse_const())
                # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                # RetroScript Phase 2: @decorator blocks
                # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                elif self._check(TokenType.AT_SIGN):
                    deco_data = self._parse_decorator_block()
                    if deco_data and deco_data.get("type") == "permissions":
                        permissions.extend(deco_data.get("values", []))
                else:
                    # Try to parse as statement for better error
                    token = self._peek()
                    self.errors.append(unexpected_token(token.value, Span.from_token(token)))
                    self._synchronize()
            except ParseError as e:
                self.errors.append(e.diagnostic)
                self._synchronize()

        return Program(
            span=self._span_from(start),
            permissions=permissions,
            imports=imports,  # Phase 3
            hotkeys=hotkeys,
            flows=flows,
            interrupts=interrupts,
            constants=constants,
        )

    def _parse_decorator_block(self) -> dict[str, Any] | None:
        """Parse decorator block like @permissions { ... }."""
        self._expect(TokenType.AT_SIGN)

        # Check decorator type
        self._peek()
        if self._match(TokenType.PERMISSIONS):
            # @permissions { "FS_READ", "NET_ALL" }
            self._expect(TokenType.LBRACE)
            perms: list[str] = []

            while not self._check(TokenType.RBRACE) and not self._at_end():
                if self._check(TokenType.STRING):
                    perms.append(self._advance().value)
                elif self._check(TokenType.IDENTIFIER):
                    # Allow non-quoted identifiers too
                    perms.append(self._advance().value)

                self._match(TokenType.COMMA)

            self._expect(TokenType.RBRACE)
            return {"type": "permissions", "values": perms}

        elif self._match(TokenType.CONFIG):
            # @config { ... } - Placeholder for now
            self._parse_block()  # Skip body
            return {"type": "config"}

        elif self._check(TokenType.TEST, TokenType.META):
            # Other decorators - skip for now
            self._advance()
            if self._check(TokenType.LBRACE):
                self._parse_block()
            return None

        else:
            # Unknown decorator
            self._expect(TokenType.IDENTIFIER)
            # Maybe skip block?
            if self._check(TokenType.LBRACE):
                self._parse_block()
            return None

    def _parse_hotkeys(self) -> HotkeysDecl:
        """Parse hotkeys block."""
        start = self._expect(TokenType.HOTKEYS)
        self._expect(TokenType.LBRACE)

        bindings: dict[str, str] = {}

        while not self._check(TokenType.RBRACE) and not self._at_end():
            name_token = self._expect(TokenType.IDENTIFIER)
            self._expect(TokenType.ASSIGN)
            value_token = self._expect(TokenType.STRING)
            bindings[name_token.value] = value_token.value

            # Optional semicolon
            self._match(TokenType.SEMICOLON)

        self._expect(TokenType.RBRACE)

        return HotkeysDecl(
            span=self._span_from(start),
            bindings=bindings,
        )

    def _parse_flow(self) -> FlowDecl:
        """Parse flow declaration."""
        start = self._expect(TokenType.FLOW)
        name_token = self._expect(TokenType.IDENTIFIER)
        body = self._parse_block()

        return FlowDecl(
            span=self._span_from(start),
            name=name_token.value,
            body=body,
        )

    def _parse_interrupt(self) -> InterruptDecl:
        """Parse interrupt declaration."""
        start = self._expect(TokenType.INTERRUPT)
        self._expect(TokenType.LBRACE)

        priority = 0
        when_asset = ""
        roi: ASTNode | None = None

        # Parse priority and when clauses
        while not self._check(TokenType.LBRACE, TokenType.RBRACE) and not self._at_end():
            if self._match(TokenType.PRIORITY):
                priority_token = self._expect(TokenType.INTEGER)
                priority = int(priority_token.value)
            elif self._match(TokenType.WHEN):
                self._expect(TokenType.IMAGE)
                asset_token = self._expect(TokenType.STRING)
                when_asset = asset_token.value
            else:
                break

        # Parse body block
        body = self._parse_block()

        self._expect(TokenType.RBRACE)

        return InterruptDecl(
            span=self._span_from(start),
            priority=priority,
            when_asset=when_asset,
            body=body,
            roi=roi,
        )

    def _parse_const(self) -> ConstStmt:
        """Parse const declaration."""
        start = self._expect(TokenType.CONST)
        name_token = self._expect(TokenType.IDENTIFIER)
        self._expect(TokenType.ASSIGN)
        value = self._parse_expression()
        self._match(TokenType.SEMICOLON)

        return ConstStmt(
            span=self._span_from(start),
            name=name_token.value,
            initializer=value,
        )

    def _parse_import(self) -> ImportStmt:
        """Parse import statement (Phase 3).

        Syntax:
            import "path/to/module"
            import "lib/combat" as combat
            import "antiban-pro@2.0" as ab
        """
        start = self._expect(TokenType.IMPORT)

        # Parse module path (required string)
        path_token = self._expect(TokenType.STRING, "Expected module path string")
        path = path_token.value

        # Parse optional alias: as name
        alias: str | None = None
        if self._match(TokenType.AS):
            alias_token = self._expect(TokenType.IDENTIFIER, "Expected alias name")
            alias = alias_token.value

        # Optional semicolon
        self._match(TokenType.SEMICOLON)

        return ImportStmt(
            span=self._span_from(start),
            path=path,
            alias=alias,
        )

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Statement Parsing
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _parse_block(self) -> BlockStmt:
        """Parse block of statements { ... }."""
        start = self._expect(TokenType.LBRACE)
        statements: list[ASTNode] = []

        while not self._check(TokenType.RBRACE) and not self._at_end():
            try:
                stmt = self._parse_statement()
                if stmt:
                    statements.append(stmt)
            except ParseError as e:
                self.errors.append(e.diagnostic)
                self._synchronize()

        self._expect(TokenType.RBRACE)

        return BlockStmt(
            span=self._span_from(start),
            statements=statements,
        )

    def _parse_statement(self) -> ASTNode | None:
        """Parse a single statement."""
        # Label statement
        if self._check(TokenType.LABEL):
            return self._parse_label()

        # Goto statement
        if self._check(TokenType.GOTO):
            return self._parse_goto()

        # If statement
        if self._check(TokenType.IF):
            return self._parse_if()

        # While statement
        if self._check(TokenType.WHILE):
            return self._parse_while()

        # For statement
        if self._check(TokenType.FOR):
            return self._parse_for()

        # Let statement
        if self._check(TokenType.LET):
            return self._parse_let()

        # Try statement
        if self._check(TokenType.TRY):
            return self._parse_try()

        # Break
        if self._check(TokenType.BREAK):
            start = self._advance()
            self._match(TokenType.SEMICOLON)
            return BreakStmt(span=self._span_from(start))

        # Continue
        if self._check(TokenType.CONTINUE):
            start = self._advance()
            self._match(TokenType.SEMICOLON)
            return ContinueStmt(span=self._span_from(start))

        # Return
        if self._check(TokenType.RETURN):
            return self._parse_return()

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # RetroScript: $variable assignment
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if self._check(TokenType.VARIABLE):
            return self._parse_variable_assignment()

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # RetroScript: repeat N: block
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if self._check(TokenType.REPEAT):
            return self._parse_repeat()

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # RetroScript: retry N: block
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if self._check(TokenType.RETRY):
            return self._parse_retry()

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # RetroScript: match $expr: patterns
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if self._check(TokenType.MATCH):
            return self._parse_match()

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Block end statements: endif, endloop, endwhile
        # These are parsed as function calls: endif();
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if self._check(TokenType.ENDIF):
            start = self._advance()
            self._match(TokenType.SEMICOLON)
            return ExprStmt(
                span=self._span_from(start),
                expr=CallExpr(
                    span=self._span_from(start),
                    callee="end_if",
                    args=[],
                ),
            )

        if self._check(TokenType.ENDLOOP):
            start = self._advance()
            self._match(TokenType.SEMICOLON)
            return ExprStmt(
                span=self._span_from(start),
                expr=CallExpr(
                    span=self._span_from(start),
                    callee="end_loop",
                    args=[],
                ),
            )

        if self._check(TokenType.ENDWHILE):
            start = self._advance()
            self._match(TokenType.SEMICOLON)
            return ExprStmt(
                span=self._span_from(start),
                expr=CallExpr(
                    span=self._span_from(start),
                    callee="end_while",
                    args=[],
                ),
            )

        # Expression statement
        return self._parse_expression_statement()

    def _parse_label(self) -> LabelStmt:
        """Parse label statement: label name:."""
        start = self._expect(TokenType.LABEL)
        name_token = self._expect(TokenType.IDENTIFIER)
        self._expect(TokenType.COLON)

        return LabelStmt(
            span=self._span_from(start),
            name=name_token.value,
        )

    def _parse_goto(self) -> GotoStmt:
        """Parse goto statement: goto name;."""
        start = self._expect(TokenType.GOTO)
        target_token = self._expect(TokenType.IDENTIFIER)
        self._match(TokenType.SEMICOLON)

        return GotoStmt(
            span=self._span_from(start),
            target=target_token.value,
        )

    def _parse_if(self) -> IfStmt:
        """Parse if statement with elif/else."""
        start = self._expect(TokenType.IF)
        condition = self._parse_expression()
        then_branch = self._parse_block()

        elif_branches: list[tuple[ASTNode, BlockStmt]] = []
        while self._match(TokenType.ELIF):
            elif_cond = self._parse_expression()
            elif_body = self._parse_block()
            elif_branches.append((elif_cond, elif_body))

        else_branch: BlockStmt | None = None
        if self._match(TokenType.ELSE):
            else_branch = self._parse_block()

        return IfStmt(
            span=self._span_from(start),
            condition=condition,
            then_branch=then_branch,
            elif_branches=elif_branches,
            else_branch=else_branch,
        )

    def _parse_while(self) -> WhileStmt:
        """Parse while loop."""
        start = self._expect(TokenType.WHILE)
        condition = self._parse_expression()
        body = self._parse_block()

        return WhileStmt(
            span=self._span_from(start),
            condition=condition,
            body=body,
        )

    def _parse_for(self) -> ForStmt:
        """Parse for loop: for i in range(10) { }."""
        start = self._expect(TokenType.FOR)
        var_token = self._expect(TokenType.IDENTIFIER)
        self._expect(TokenType.IN)
        iterable = self._parse_expression()
        body = self._parse_block()

        return ForStmt(
            span=self._span_from(start),
            variable=var_token.value,
            iterable=iterable,
            body=body,
        )

    def _parse_let(self) -> LetStmt:
        """Parse let statement: let x = 5;."""
        start = self._expect(TokenType.LET)
        name_token = self._expect(TokenType.IDENTIFIER)

        initializer: ASTNode | None = None
        if self._match(TokenType.ASSIGN):
            initializer = self._parse_expression()

        self._match(TokenType.SEMICOLON)

        return LetStmt(
            span=self._span_from(start),
            name=name_token.value,
            initializer=initializer,
        )

    def _parse_try(self) -> TryStmt:
        """Parse try-catch statement."""
        start = self._expect(TokenType.TRY)
        try_block = self._parse_block()

        catch_var: str | None = None
        catch_block: BlockStmt | None = None

        if self._match(TokenType.CATCH):
            if self._check(TokenType.IDENTIFIER):
                catch_var = self._advance().value
            catch_block = self._parse_block()

        return TryStmt(
            span=self._span_from(start),
            try_block=try_block,
            catch_var=catch_var,
            catch_block=catch_block,
        )

    def _parse_return(self) -> ReturnStmt:
        """Parse return statement."""
        start = self._expect(TokenType.RETURN)

        value: ASTNode | None = None
        if not self._check(TokenType.SEMICOLON, TokenType.RBRACE):
            value = self._parse_expression()

        self._match(TokenType.SEMICOLON)

        return ReturnStmt(
            span=self._span_from(start),
            value=value,
        )

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # RetroScript Parsing
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _parse_variable_assignment(self) -> AssignStmt:
        """Parse $variable = expression (RetroScript)."""
        start = self._advance()  # $variable token
        var_name = start.value  # includes $ prefix

        self._expect(TokenType.ASSIGN, "Expected '=' after variable name")
        value = self._parse_expression()

        # Optional semicolon (RetroScript doesn't require it)
        self._match(TokenType.SEMICOLON)

        # Create identifier node for target
        target = Identifier(span=self._span_from(start), name=var_name)

        return AssignStmt(
            span=self._span_from(start),
            target=target,
            value=value,
        )

    def _parse_repeat(self) -> ForStmt:
        """Parse repeat N: block (RetroScript).

        Translates to: for _i in range(N) { block }
        """
        start = self._expect(TokenType.REPEAT)

        # Parse count (optional - if missing, infinite loop)
        count: ASTNode | None = None
        if self._check(TokenType.INTEGER):
            count_token = self._advance()
            count = Literal(
                span=self._span_from(count_token),
                value=int(count_token.value),
                literal_type="integer",
            )

        # Optional 'times' keyword
        self._match(TokenType.TIMES)

        # Expect colon or brace
        if not self._match(TokenType.COLON):
            self._expect(TokenType.LBRACE)
            # Put back for block parsing
            self.pos -= 1

        # Parse block
        body = self._parse_block()

        # Optional 'end' keyword (RetroScript style)
        self._match(TokenType.END)

        # Create synthetic range call
        if count:
            range_call = CallExpr(
                span=self._span_from(start),
                callee="range",
                args=[count],
            )
        else:
            # Infinite loop - use large number with safety limit
            range_call = CallExpr(
                span=self._span_from(start),
                callee="range",
                args=[Literal(span=self._span_from(start), value=1000, literal_type="integer")],
            )

        return ForStmt(
            span=self._span_from(start),
            variable="_i",
            iterable=range_call,
            body=body,
        )

    def _parse_retry(self) -> TryStmt:
        """Parse retry N: block (RetroScript).

        Syntax: retry 3 times: block
        Translates to: try { block } catch err { if _retry < 3 { _retry++; goto retry } }
        """
        start = self._expect(TokenType.RETRY)

        # Parse count
        count = 3  # Default retry count
        if self._check(TokenType.INTEGER):
            count_token = self._advance()
            count = int(count_token.value)

        # Optional 'times' keyword
        self._match(TokenType.TIMES)

        # Expect colon or brace
        if not self._match(TokenType.COLON):
            self._expect(TokenType.LBRACE)
            self.pos -= 1

        # Parse try block
        try_block = self._parse_block()

        # Optional 'end' keyword
        self._match(TokenType.END)

        # Parse optional else block (runs if all retries fail)
        else_block: BlockStmt | None = None
        if self._match(TokenType.ELSE):
            if not self._match(TokenType.COLON):
                self._expect(TokenType.LBRACE)
                self.pos -= 1
            else_block = self._parse_block()
            self._match(TokenType.END)

        # For now, we create a simple TryStmt
        # The engine will handle retry logic based on retry_count metadata
        result = TryStmt(
            span=self._span_from(start),
            try_block=try_block,
            catch_var="_retry_err",
            catch_block=(
                else_block
                if else_block
                else BlockStmt(
                    span=self._span_from(start),
                    statements=[],
                )
            ),
        )

        # Store retry count as attribute (engine uses this)
        result.retry_count = count  # type: ignore
        return result

    def _parse_match(self) -> IfStmt:
        """Parse match statement (RetroScript pattern matching).

        Syntax:
            match $result:
                Found(pos, score): click pos
                NotFound: log "Not found"
                Timeout: retry

        Translates to if-elif chain based on expression value.
        """
        start = self._expect(TokenType.MATCH)

        # Parse the expression to match on
        match_expr = self._parse_expression()

        # Expect colon
        self._expect(TokenType.COLON, "Expected ':' after match expression")

        # Parse match arms - simplified version
        # For now, we treat match as a simple if-statement
        # match $result:
        #   Found: body1
        #   NotFound: body2
        # becomes: if $result == "Found" { body1 } elif $result == "NotFound" { body2 }

        # Expect block or indented patterns
        if self._match(TokenType.LBRACE):
            # Block-style match
            body = self._parse_block_inner()
            self._expect(TokenType.RBRACE)
        else:
            # Simple single-line or indented
            body = self._parse_block()

        # Optional 'end' keyword
        self._match(TokenType.END)

        # For now, create a simplified structure
        # The match expression becomes an if statement checking the expression
        # This is a placeholder - full pattern matching would need more complex AST
        return IfStmt(
            span=self._span_from(start),
            condition=match_expr,
            then_branch=body,
            elif_branches=[],
            else_branch=None,
        )

    def _parse_block_inner(self) -> BlockStmt:
        """Parse block statements without braces (for match arms)."""
        statements: list[ASTNode] = []
        start = self._peek()

        while not self._check(TokenType.RBRACE, TokenType.EOF):
            try:
                stmt = self._parse_statement()
                if stmt:
                    statements.append(stmt)
            except ParseError as e:
                self.errors.append(e.diagnostic)
                self._synchronize()

        return BlockStmt(
            span=self._span_from(start),
            statements=statements,
        )

    def _parse_expression_statement(self) -> ASTNode:
        """Parse expression statement or assignment."""
        start = self._peek()
        expr = self._parse_expression()

        # Check for assignment
        if self._match(TokenType.ASSIGN):
            value = self._parse_expression()
            self._match(TokenType.SEMICOLON)
            return AssignStmt(
                span=self._span_from(start),
                target=expr,
                value=value,
            )

        self._match(TokenType.SEMICOLON)
        from core.dsl.ast import ExprStmt

        return ExprStmt(
            span=self._span_from(start),
            expr=expr,
        )

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Expression Parsing (Precedence Climbing)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _parse_expression(self) -> ASTNode:
        """Parse expression (entry point)."""
        return self._parse_or()

    def _parse_or(self) -> ASTNode:
        """Parse || or 'or' expression."""
        left = self._parse_and()

        # Support both || and 'or' keyword (RetroScript)
        while self._match(TokenType.OR, TokenType.OR_KW):
            right = self._parse_and()
            left = BinaryExpr(
                span=left.span.merge(right.span),
                left=left,
                operator="or",  # Normalize to 'or'
                right=right,
            )

        return left

    def _parse_and(self) -> ASTNode:
        """Parse && or 'and' expression."""
        left = self._parse_equality()

        # Support both && and 'and' keyword (RetroScript)
        while self._match(TokenType.AND, TokenType.AND_KW):
            right = self._parse_equality()
            left = BinaryExpr(
                span=left.span.merge(right.span),
                left=left,
                operator="and",  # Normalize to 'and'
                right=right,
            )

        return left

    def _parse_equality(self) -> ASTNode:
        """Parse == != expression."""
        left = self._parse_comparison()

        while True:
            if self._match(TokenType.EQ):
                right = self._parse_comparison()
                left = BinaryExpr(
                    span=left.span.merge(right.span),
                    left=left,
                    operator="==",
                    right=right,
                )
            elif self._match(TokenType.NEQ):
                right = self._parse_comparison()
                left = BinaryExpr(
                    span=left.span.merge(right.span),
                    left=left,
                    operator="!=",
                    right=right,
                )
            else:
                break

        return left

    def _parse_comparison(self) -> ASTNode:
        """Parse < > <= >= expression."""
        left = self._parse_additive()

        op_map = {
            TokenType.LT: "<",
            TokenType.GT: ">",
            TokenType.LTE: "<=",
            TokenType.GTE: ">=",
        }

        while True:
            matched = False
            for token_type, op in op_map.items():
                if self._match(token_type):
                    right = self._parse_additive()
                    left = BinaryExpr(
                        span=left.span.merge(right.span),
                        left=left,
                        operator=op,
                        right=right,
                    )
                    matched = True
                    break
            if not matched:
                break

        return left

    def _parse_additive(self) -> ASTNode:
        """Parse + - expression."""
        left = self._parse_multiplicative()

        while True:
            if self._match(TokenType.PLUS):
                right = self._parse_multiplicative()
                left = BinaryExpr(
                    span=left.span.merge(right.span),
                    left=left,
                    operator="+",
                    right=right,
                )
            elif self._match(TokenType.MINUS):
                right = self._parse_multiplicative()
                left = BinaryExpr(
                    span=left.span.merge(right.span),
                    left=left,
                    operator="-",
                    right=right,
                )
            else:
                break

        return left

    def _parse_multiplicative(self) -> ASTNode:
        """Parse * / % expression."""
        left = self._parse_unary()

        while True:
            if self._match(TokenType.STAR):
                right = self._parse_unary()
                left = BinaryExpr(
                    span=left.span.merge(right.span),
                    left=left,
                    operator="*",
                    right=right,
                )
            elif self._match(TokenType.SLASH):
                right = self._parse_unary()
                left = BinaryExpr(
                    span=left.span.merge(right.span),
                    left=left,
                    operator="/",
                    right=right,
                )
            elif self._match(TokenType.PERCENT):
                right = self._parse_unary()
                left = BinaryExpr(
                    span=left.span.merge(right.span),
                    left=left,
                    operator="%",
                    right=right,
                )
            else:
                break

        return left

    def _parse_unary(self) -> ASTNode:
        """Parse ! - unary expression."""
        if self._match(TokenType.NOT):
            start = self.tokens[self.pos - 1]
            operand = self._parse_unary()
            return UnaryExpr(
                span=self._span_from(start),
                operator="!",
                operand=operand,
            )

        if self._match(TokenType.MINUS):
            start = self.tokens[self.pos - 1]
            operand = self._parse_unary()
            return UnaryExpr(
                span=self._span_from(start),
                operator="-",
                operand=operand,
            )

        return self._parse_call()

    def _parse_call(self) -> ASTNode:
        """Parse function call or primary."""
        expr = self._parse_primary()

        while True:
            if self._match(TokenType.LPAREN):
                expr = self._finish_call(expr)
            else:
                break

        return expr

    def _finish_call(self, callee: ASTNode) -> CallExpr:
        """Parse function call arguments."""
        args: list[ASTNode] = []
        kwargs: dict[str, ASTNode] = {}

        if not self._check(TokenType.RPAREN):
            while True:
                # Check for keyword argument
                if self._check(TokenType.IDENTIFIER) and self._peek(1).type == TokenType.ASSIGN:
                    name = self._advance().value
                    self._advance()  # =
                    value = self._parse_expression()
                    kwargs[name] = value
                else:
                    args.append(self._parse_expression())

                if not self._match(TokenType.COMMA):
                    break

        self._expect(TokenType.RPAREN)

        callee_name = callee.name if isinstance(callee, Identifier) else "unknown"

        return CallExpr(
            span=callee.span.merge(Span.from_token(self.tokens[self.pos - 1])),
            callee=callee_name,
            args=args,
            kwargs=kwargs,
        )

    def _parse_primary(self) -> ASTNode:
        """Parse primary expression (literals, identifiers, groups)."""
        token = self._peek()

        # Null
        if self._match(TokenType.NULL):
            return Literal(
                span=Span.from_token(token),
                value=None,
                literal_type="null",
            )

        # Booleans
        if self._match(TokenType.TRUE):
            return Literal(
                span=Span.from_token(token),
                value=True,
                literal_type="bool",
            )

        if self._match(TokenType.FALSE):
            return Literal(
                span=Span.from_token(token),
                value=False,
                literal_type="bool",
            )

        # Numbers
        if self._match(TokenType.INTEGER):
            return Literal(
                span=Span.from_token(token),
                value=int(token.value),
                literal_type="int",
            )

        if self._match(TokenType.FLOAT):
            return Literal(
                span=Span.from_token(token),
                value=float(token.value),
                literal_type="float",
            )

        # Duration
        if self._match(TokenType.DURATION):
            return Literal(
                span=Span.from_token(token),
                value=token.value,
                literal_type="duration",
            )

        # String
        if self._match(TokenType.STRING):
            return Literal(
                span=Span.from_token(token),
                value=token.value,
                literal_type="string",
            )

        # Identifier
        if self._match(TokenType.IDENTIFIER):
            return Identifier(
                span=Span.from_token(token),
                name=token.value,
            )

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # RetroScript: Action keywords as callable identifiers
        # These can be used as function calls: find(btn), click(100, 200), etc.
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        retro_actions = (
            TokenType.FIND,
            TokenType.WAIT,
            TokenType.CLICK,
            TokenType.TYPE_KW,
            TokenType.PRESS,
            TokenType.SLEEP,
            TokenType.SCROLL,
            TokenType.DRAG,
            TokenType.RUN,
        )
        if self._check(*retro_actions):
            token = self._advance()
            return Identifier(
                span=Span.from_token(token),
                name=token.value,
            )

        # RetroScript: $variable as expression
        if self._match(TokenType.VARIABLE):
            return Identifier(
                span=Span.from_token(token),
                name=token.value,
            )

        # Array literal
        if self._match(TokenType.LBRACKET):
            elements: list[ASTNode] = []
            if not self._check(TokenType.RBRACKET):
                while True:
                    elements.append(self._parse_expression())
                    if not self._match(TokenType.COMMA):
                        break
            self._expect(TokenType.RBRACKET)
            return ArrayExpr(
                span=self._span_from(token),
                elements=elements,
            )

        # Grouped expression
        if self._match(TokenType.LPAREN):
            expr = self._parse_expression()
            self._expect(TokenType.RPAREN)
            return expr

        # Error
        raise ParseError(unexpected_token(token.value, Span.from_token(token)))


================================================================================
FILE PATH: core\dsl\semantic.py
LINES: 451
================================================================================

"""
RetroAuto v2 - DSL Semantic Analyzer

Validates AST semantically:
- Resolves asset references
- Resolves flow references
- Validates label/goto pairs
- Type checks built-in function arguments
- Produces diagnostics with quick-fix hints
"""

from __future__ import annotations

from dataclasses import dataclass, field

from core.dsl.ast import (
    ArrayExpr,
    AssignStmt,
    ASTNode,
    BinaryExpr,
    BlockStmt,
    CallExpr,
    ConstStmt,
    ExprStmt,
    FlowDecl,
    ForStmt,
    GotoStmt,
    Identifier,
    IfStmt,
    LabelStmt,
    LetStmt,
    Literal,
    Program,
    ReturnStmt,
    Span,
    TryStmt,
    UnaryExpr,
    WhileStmt,
)
from core.dsl.diagnostics import (
    Diagnostic,
    duplicate_flow,
    duplicate_label,
    missing_argument,
    unknown_asset,
    unknown_flow,
    unknown_label,
)


@dataclass
class FunctionSignature:
    """Signature of a built-in function."""

    name: str
    required_args: list[str]
    optional_args: dict[str, str]  # name -> type
    return_type: str


# Built-in function signatures
BUILTIN_FUNCTIONS: dict[str, FunctionSignature] = {
    # Vision
    "wait_image": FunctionSignature(
        name="wait_image",
        required_args=["asset"],
        optional_args={
            "appear": "bool",
            "timeout": "duration",
            "poll": "duration",
            "roi": "roi",
            "threshold": "float",
        },
        return_type="match",
    ),
    "find_image": FunctionSignature(
        name="find_image",
        required_args=["asset"],
        optional_args={
            "roi": "roi",
            "threshold": "float",
        },
        return_type="match",
    ),
    "image_exists": FunctionSignature(
        name="image_exists",
        required_args=["asset"],
        optional_args={
            "roi": "roi",
            "threshold": "float",
        },
        return_type="bool",
    ),
    "wait_any": FunctionSignature(
        name="wait_any",
        required_args=["assets"],
        optional_args={
            "timeout": "duration",
            "poll": "duration",
        },
        return_type="tuple",
    ),
    # Input
    "click": FunctionSignature(
        name="click",
        required_args=["x", "y"],
        optional_args={
            "button": "string",
            "clicks": "int",
            "interval": "duration",
        },
        return_type="void",
    ),
    "move": FunctionSignature(
        name="move",
        required_args=["x", "y"],
        optional_args={},
        return_type="void",
    ),
    "hotkey": FunctionSignature(
        name="hotkey",
        required_args=[],  # Variadic
        optional_args={},
        return_type="void",
    ),
    "type_text": FunctionSignature(
        name="type_text",
        required_args=["text"],
        optional_args={
            "paste": "bool",
            "enter": "bool",
        },
        return_type="void",
    ),
    "sleep": FunctionSignature(
        name="sleep",
        required_args=["duration"],
        optional_args={},
        return_type="void",
    ),
    # Control
    "run_flow": FunctionSignature(
        name="run_flow",
        required_args=["flow_name"],
        optional_args={},
        return_type="void",
    ),
    "log": FunctionSignature(
        name="log",
        required_args=["message"],
        optional_args={
            "level": "string",
        },
        return_type="void",
    ),
    "assert": FunctionSignature(
        name="assert",
        required_args=["condition"],
        optional_args={
            "message": "string",
        },
        return_type="void",
    ),
    # Utility
    "range": FunctionSignature(
        name="range",
        required_args=["end"],
        optional_args={
            "start": "int",
            "step": "int",
        },
        return_type="iterable",
    ),
}


@dataclass
class Scope:
    """Variable scope for semantic analysis."""

    variables: dict[str, ASTNode] = field(default_factory=dict)
    parent: Scope | None = None

    def lookup(self, name: str) -> ASTNode | None:
        """Look up variable in scope chain."""
        if name in self.variables:
            return self.variables[name]
        if self.parent:
            return self.parent.lookup(name)
        return None

    def define(self, name: str, node: ASTNode) -> None:
        """Define variable in current scope."""
        self.variables[name] = node


@dataclass
class SymbolTable:
    """Symbol table for the entire program."""

    assets: dict[str, Span] = field(default_factory=dict)
    flows: dict[str, FlowDecl] = field(default_factory=dict)
    labels: dict[str, dict[str, LabelStmt]] = field(default_factory=dict)  # flow -> {label -> stmt}
    constants: dict[str, ConstStmt] = field(default_factory=dict)


class SemanticAnalyzer:
    """
    Semantic analyzer for DSL programs.

    Usage:
        analyzer = SemanticAnalyzer(known_assets=["btn_ok", "popup"])
        diagnostics = analyzer.analyze(program)
    """

    def __init__(self, known_assets: list[str] | None = None) -> None:
        self.known_assets = set(known_assets or [])
        self.symbols = SymbolTable()
        self.diagnostics: list[Diagnostic] = []
        self.current_flow: str = ""
        self.scope: Scope = Scope()

    def analyze(self, program: Program) -> list[Diagnostic]:
        """Analyze program and return diagnostics."""
        self.diagnostics = []
        self.symbols = SymbolTable()

        # First pass: collect all declarations
        self._collect_declarations(program)

        # Second pass: validate references
        self._validate_program(program)

        return self.diagnostics

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # First Pass: Declaration Collection
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _collect_declarations(self, program: Program) -> None:
        """Collect all top-level declarations."""
        # Collect constants
        for const in program.constants:
            if const.name in self.symbols.constants:
                # Duplicate constant (warning)
                pass
            self.symbols.constants[const.name] = const

        # Collect flows
        for flow in program.flows:
            if flow.name in self.symbols.flows:
                original = self.symbols.flows[flow.name]
                self.diagnostics.append(duplicate_flow(flow.name, flow.span, original.span))
            else:
                self.symbols.flows[flow.name] = flow

            # Collect labels within flow
            self.symbols.labels[flow.name] = {}
            self._collect_labels(flow.name, flow.body)

        # Collect interrupt assets
        for interrupt in program.interrupts:
            if interrupt.when_asset and interrupt.when_asset not in self.known_assets:
                self.diagnostics.append(unknown_asset(interrupt.when_asset, interrupt.span))

    def _collect_labels(self, flow_name: str, block: BlockStmt) -> None:
        """Collect labels in a block."""
        for stmt in block.statements:
            if isinstance(stmt, LabelStmt):
                labels = self.symbols.labels[flow_name]
                if stmt.name in labels:
                    original = labels[stmt.name]
                    self.diagnostics.append(duplicate_label(stmt.name, stmt.span, original.span))
                else:
                    labels[stmt.name] = stmt

            # Recurse into nested blocks
            if isinstance(stmt, IfStmt):
                self._collect_labels(flow_name, stmt.then_branch)
                for _, elif_body in stmt.elif_branches:
                    self._collect_labels(flow_name, elif_body)
                if stmt.else_branch:
                    self._collect_labels(flow_name, stmt.else_branch)
            elif isinstance(stmt, (WhileStmt, ForStmt)):
                self._collect_labels(flow_name, stmt.body)
            elif isinstance(stmt, TryStmt):
                self._collect_labels(flow_name, stmt.try_block)
                if stmt.catch_block:
                    self._collect_labels(flow_name, stmt.catch_block)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Second Pass: Validation
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _validate_program(self, program: Program) -> None:
        """Validate all references in program."""
        for flow in program.flows:
            self.current_flow = flow.name
            self.scope = Scope()
            self._validate_block(flow.body)

        for interrupt in program.interrupts:
            self.current_flow = "__interrupt__"
            self.scope = Scope()
            self._validate_block(interrupt.body)

    def _validate_block(self, block: BlockStmt) -> None:
        """Validate statements in a block."""
        for stmt in block.statements:
            self._validate_statement(stmt)

    def _validate_statement(self, stmt: ASTNode) -> None:
        """Validate a single statement."""
        if isinstance(stmt, GotoStmt):
            self._validate_goto(stmt)
        elif isinstance(stmt, IfStmt):
            self._validate_expression(stmt.condition)
            self._validate_block(stmt.then_branch)
            for elif_cond, elif_body in stmt.elif_branches:
                self._validate_expression(elif_cond)
                self._validate_block(elif_body)
            if stmt.else_branch:
                self._validate_block(stmt.else_branch)
        elif isinstance(stmt, WhileStmt):
            self._validate_expression(stmt.condition)
            self._validate_block(stmt.body)
        elif isinstance(stmt, ForStmt):
            self._validate_expression(stmt.iterable)
            # Add loop variable to scope
            old_scope = self.scope
            self.scope = Scope(parent=old_scope)
            self.scope.define(stmt.variable, stmt)
            self._validate_block(stmt.body)
            self.scope = old_scope
        elif isinstance(stmt, LetStmt):
            if stmt.initializer:
                self._validate_expression(stmt.initializer)
            self.scope.define(stmt.name, stmt)
        elif isinstance(stmt, AssignStmt):
            self._validate_expression(stmt.target)
            self._validate_expression(stmt.value)
        elif isinstance(stmt, ReturnStmt):
            if stmt.value:
                self._validate_expression(stmt.value)
        elif isinstance(stmt, TryStmt):
            self._validate_block(stmt.try_block)
            if stmt.catch_block:
                old_scope = self.scope
                self.scope = Scope(parent=old_scope)
                if stmt.catch_var:
                    self.scope.define(stmt.catch_var, stmt)
                self._validate_block(stmt.catch_block)
                self.scope = old_scope
        elif isinstance(stmt, ExprStmt):
            self._validate_expression(stmt.expr)

    def _validate_goto(self, stmt: GotoStmt) -> None:
        """Validate goto target exists."""
        if self.current_flow not in self.symbols.labels:
            return
        labels = self.symbols.labels[self.current_flow]
        if stmt.target not in labels:
            self.diagnostics.append(unknown_label(stmt.target, stmt.span))

    def _validate_expression(self, expr: ASTNode) -> None:
        """Validate an expression."""
        if isinstance(expr, CallExpr):
            self._validate_call(expr)
        elif isinstance(expr, BinaryExpr):
            self._validate_expression(expr.left)
            self._validate_expression(expr.right)
        elif isinstance(expr, UnaryExpr):
            self._validate_expression(expr.operand)
        elif isinstance(expr, ArrayExpr):
            for elem in expr.elements:
                self._validate_expression(elem)
        elif isinstance(expr, Identifier):  # noqa: SIM102
            # Check if variable exists
            if not self.scope.lookup(expr.name):  # noqa: SIM102
                # Could be a constant
                if expr.name not in self.symbols.constants:
                    # Unknown variable - could add warning here
                    pass

    def _validate_call(self, call: CallExpr) -> None:
        """Validate function call."""
        # Check if it's a built-in
        sig = BUILTIN_FUNCTIONS.get(call.callee)

        if call.callee == "run_flow":
            # Validate flow reference
            if call.args:
                flow_arg = call.args[0]
                if isinstance(flow_arg, Literal) and flow_arg.literal_type == "string":
                    flow_name = flow_arg.value
                    if flow_name not in self.symbols.flows:
                        self.diagnostics.append(unknown_flow(flow_name, call.span))

        elif call.callee in ("wait_image", "find_image", "image_exists"):
            # Validate asset reference
            if call.args:
                asset_arg = call.args[0]
                if isinstance(asset_arg, Literal) and asset_arg.literal_type == "string":
                    asset_id = asset_arg.value
                    if asset_id not in self.known_assets:
                        self.diagnostics.append(unknown_asset(asset_id, call.span))

        elif call.callee == "wait_any":  # noqa: SIM102
            # Validate asset list
            if call.args:
                list_arg = call.args[0]
                if isinstance(list_arg, ArrayExpr):
                    for elem in list_arg.elements:  # noqa: SIM102
                        if (
                            isinstance(elem, Literal) and elem.literal_type == "string"
                        ):  # noqa: SIM102
                            if elem.value not in self.known_assets:
                                self.diagnostics.append(unknown_asset(elem.value, elem.span))

        # Validate argument count for known functions
        if sig:
            min_args = len(sig.required_args)
            if len(call.args) < min_args:
                # Check if missing args are provided as kwargs
                missing = []
                for i, arg_name in enumerate(sig.required_args):
                    if i >= len(call.args) and arg_name not in call.kwargs:
                        missing.append(arg_name)
                for arg_name in missing:
                    self.diagnostics.append(missing_argument(call.callee, arg_name, call.span))

        # Validate all argument expressions
        for arg in call.args:
            self._validate_expression(arg)
        for arg in call.kwargs.values():
            self._validate_expression(arg)


def analyze(program: Program, known_assets: list[str] | None = None) -> list[Diagnostic]:
    """
    Analyze program and return diagnostics.

    Args:
        program: Parsed AST
        known_assets: List of known asset IDs for validation

    Returns:
        List of diagnostics (errors, warnings)
    """
    analyzer = SemanticAnalyzer(known_assets)
    return analyzer.analyze(program)


================================================================================
FILE PATH: core\dsl\sync_manager.py
LINES: 282
================================================================================

"""
RetroAuto v2 - Sync Manager

Coordinates bidirectional synchronization between GUI panels and ScriptDocument.
Handles debouncing, conflict prevention, and cursor preservation.
"""

from __future__ import annotations

from typing import TYPE_CHECKING

from PySide6.QtCore import QObject, QTimer, Signal

from core.dsl.adapter import action_to_ir, ir_to_action, ir_to_actions
from core.dsl.document import ScriptDocument
from core.models import Action
from infra import get_logger

if TYPE_CHECKING:
    pass

logger = get_logger("SyncManager")


class SyncManager(QObject):
    """
    Manages sync between GUI and ScriptDocument.

    Features:
    - Debounced code ‚Üí IR sync (500ms delay)
    - Immediate GUI ‚Üí IR ‚Üí code sync
    - Prevents feedback loops
    - Cursor position preservation

    Usage:
        doc = ScriptDocument()
        sync = SyncManager(doc)

        # Connect ActionsPanel
        actions_panel.action_changed.connect(sync.on_action_changed)
        sync.ir_changed.connect(actions_panel.refresh_from_ir)

        # Connect CodeEditor
        code_editor.textChanged.connect(sync.on_code_changed)
        sync.code_regenerated.connect(code_editor.set_code)
    """

    # Signals
    ir_changed = Signal(str)  # change_type
    code_regenerated = Signal(str)  # new code
    errors_occurred = Signal(list)  # error messages

    def __init__(self, document: ScriptDocument) -> None:
        super().__init__()
        self._doc = document
        self._sync_lock = False

        # Debounce timer for code ‚Üí IR sync
        self._code_debounce = QTimer()
        self._code_debounce.setSingleShot(True)
        self._code_debounce.timeout.connect(self._do_code_to_ir)
        self._pending_code: str = ""

        # Connect to document callbacks
        self._doc.on_ir_changed(self._on_doc_ir_changed)
        self._doc.on_code_changed(self._on_doc_code_changed)
        self._doc.on_error(self._on_doc_error)

        logger.info("SyncManager initialized")

    @property
    def document(self) -> ScriptDocument:
        """Get the managed document."""
        return self._doc

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Code Editor ‚Üí IR (debounced)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def on_code_changed(self, new_code: str) -> None:
        """
        Handle code changes from the editor.

        Debounces by 500ms to avoid parsing on every keystroke.
        """
        if self._sync_lock:
            return

        self._pending_code = new_code
        self._code_debounce.start(500)  # 500ms debounce

    def on_code_saved(self, code: str) -> None:
        """
        Handle code save from IDE - sync immediately without debounce.

        Use this when user explicitly saves, not on every keystroke.
        """
        if self._sync_lock:
            logger.warning("on_code_saved: sync_lock is active, skipping")
            return

        # Cancel any pending debounced sync
        self._code_debounce.stop()

        logger.info("on_code_saved: Starting immediate sync (code length: %d)", len(code))

        # Sync immediately
        self._sync_lock = True
        try:
            self._doc.update_from_code(code, source="editor")
            logger.info(
                "on_code_saved: update_from_code completed, IR valid: %s", self._doc.ir.is_valid
            )
            logger.info("on_code_saved: IR has %d flows", len(self._doc.ir.flows))
            if self._doc.ir.flows:
                logger.info(
                    "on_code_saved: main flow has %d actions", len(self._doc.ir.flows[0].actions)
                )
        finally:
            self._sync_lock = False

    def _do_code_to_ir(self) -> None:
        """Execute the debounced code ‚Üí IR sync."""
        if self._sync_lock:
            return

        self._sync_lock = True
        try:
            self._doc.update_from_code(self._pending_code, source="editor")
        finally:
            self._sync_lock = False

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # GUI ‚Üí IR ‚Üí Code (immediate)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def on_action_changed(
        self,
        flow_name: str,
        action_index: int,
        action: Action,
    ) -> None:
        """
        Handle action changed in GUI.

        Immediately updates IR and regenerates code.
        """
        if self._sync_lock:
            return

        self._sync_lock = True
        try:
            action_ir = action_to_ir(action)
            flow = self._doc.ir.get_flow(flow_name)

            if flow and 0 <= action_index < len(flow.actions):
                flow.actions[action_index] = action_ir
                self._doc._is_dirty = True
                self._doc._regenerate_code()
                self._doc._notify_ir_changed("gui_action_changed")
        finally:
            self._sync_lock = False

    def on_action_added(
        self,
        flow_name: str,
        action: Action,
        at_index: int = -1,
    ) -> None:
        """Handle action added in GUI."""
        if self._sync_lock:
            return

        self._sync_lock = True
        try:
            action_ir = action_to_ir(action)
            flow = self._doc.ir.get_flow(flow_name)

            if flow:
                if at_index < 0 or at_index >= len(flow.actions):
                    flow.actions.append(action_ir)
                else:
                    flow.actions.insert(at_index, action_ir)
                self._doc._is_dirty = True
                self._doc._regenerate_code()
                self._doc._notify_ir_changed("gui_action_added")
        finally:
            self._sync_lock = False

    def on_action_removed(self, flow_name: str, action_index: int) -> None:
        """Handle action removed in GUI."""
        if self._sync_lock:
            return

        self._sync_lock = True
        try:
            flow = self._doc.ir.get_flow(flow_name)

            if flow and 0 <= action_index < len(flow.actions):
                del flow.actions[action_index]
                self._doc._is_dirty = True
                self._doc._regenerate_code()
                self._doc._notify_ir_changed("gui_action_removed")
        finally:
            self._sync_lock = False

    def on_actions_reordered(
        self,
        flow_name: str,
        from_index: int,
        to_index: int,
    ) -> None:
        """Handle action reordered in GUI."""
        if self._sync_lock:
            return

        self._sync_lock = True
        try:
            flow = self._doc.ir.get_flow(flow_name)

            if flow:
                action = flow.actions.pop(from_index)
                flow.actions.insert(to_index, action)
                self._doc._is_dirty = True
                self._doc._regenerate_code()
                self._doc._notify_ir_changed("gui_action_reordered")
        finally:
            self._sync_lock = False

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # IR ‚Üí GUI Helpers
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def get_flow_actions(self, flow_name: str) -> list[Action]:
        """Get all actions for a flow as Action models.

        Uses ir_to_actions() which automatically adds EndIf/EndLoop/EndWhile
        markers for proper GUI flat list display.
        """
        flow = self._doc.ir.get_flow(flow_name)
        if not flow:
            return []

        # Use ir_to_actions which adds auto-EndIf markers
        return ir_to_actions(flow.actions)

    def get_flow_names(self) -> list[str]:
        """Get all flow names."""
        return [f.name for f in self._doc.ir.flows]

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Document Callback Handlers
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _on_doc_ir_changed(self, change_type: str) -> None:
        """Forward IR changes to listeners."""
        if change_type.startswith("code_"):
            # IR changed from code edit - GUI should refresh
            self.ir_changed.emit(change_type)

    def _on_doc_code_changed(self, source: str) -> None:
        """Forward code changes to listeners."""
        if source == "gui":
            # Code regenerated from GUI change - editor should update
            self.code_regenerated.emit(self._doc.code)

    def _on_doc_error(self, errors: list[str]) -> None:
        """Forward errors to listeners."""
        self.errors_occurred.emit(errors)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Utilities
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def force_sync_from_ir(self) -> None:
        """Force regenerate code from current IR."""
        self._doc._regenerate_code()

    def cancel_pending_sync(self) -> None:
        """Cancel any pending debounced sync."""
        self._code_debounce.stop()
        self._pending_code = ""


================================================================================
FILE PATH: core\dsl\tokens.py
LINES: 242
================================================================================

"""
RetroAuto v2 - DSL Token Types

Defines all token types for the DSL lexer.
"""

from enum import Enum, auto


class TokenType(Enum):
    """Token types for DSL lexer."""

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Literals
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    INTEGER = auto()  # 123
    FLOAT = auto()  # 1.5
    STRING = auto()  # "hello" or 'hello'
    DURATION = auto()  # 250ms, 2s, 1m
    TRUE = auto()  # true
    FALSE = auto()  # false
    NULL = auto()  # null

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Identifiers
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    IDENTIFIER = auto()  # variable names, function names

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Keywords
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    FLOW = auto()  # flow
    INTERRUPT = auto()  # interrupt
    PRIORITY = auto()  # priority
    WHEN = auto()  # when
    IMAGE = auto()  # image
    CONST = auto()  # const
    LET = auto()  # let
    IF = auto()  # if
    ELIF = auto()  # elif
    ELSE = auto()  # else
    WHILE = auto()  # while
    FOR = auto()  # for
    IN = auto()  # in
    RANGE = auto()  # range
    LABEL = auto()  # label
    GOTO = auto()  # goto
    TRY = auto()  # try
    CATCH = auto()  # catch
    BREAK = auto()  # break
    CONTINUE = auto()  # continue
    RETURN = auto()  # return
    HOTKEYS = auto()  # hotkeys

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # RetroScript Keywords (Phase 1)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    MATCH = auto()  # match (pattern matching)
    RETRY = auto()  # retry
    TIMES = auto()  # times (retry 3 times)
    FIND = auto()  # find
    RUN = auto()  # run (call flow)
    DEF = auto()  # def (function definition)
    END = auto()  # end (block end)
    REPEAT = auto()  # repeat
    WAIT = auto()  # wait
    CLICK = auto()  # click
    TYPE_KW = auto()  # type
    PRESS = auto()  # press
    SLEEP = auto()  # sleep
    SCROLL = auto()  # scroll
    DRAG = auto()  # drag
    ENDIF = auto()  # endif (ends if block)
    ENDLOOP = auto()  # endloop (ends loop block)
    ENDWHILE = auto()  # endwhile (ends while block)

    # RetroScript logical keywords (word form)
    AND_KW = auto()  # and (word form)
    OR_KW = auto()  # or (word form)
    NOT_KW = auto()  # not (word form)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # RetroScript Phase 2: Testing & Config
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    TEST = auto()  # test
    MOCK = auto()  # mock
    ASSERT = auto()  # assert
    PERMISSIONS = auto()  # permissions
    CONFIG = auto()  # config
    META = auto()  # meta
    IMPORT = auto()  # import
    AS = auto()  # as (import ... as ...)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # RetroScript Variable
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    VARIABLE = auto()  # $varname
    AT_SIGN = auto()  # @ (for @test, @config, etc.)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Operators
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    PLUS = auto()  # +
    MINUS = auto()  # -
    STAR = auto()  # *
    SLASH = auto()  # /
    PERCENT = auto()  # %
    EQ = auto()  # ==
    NEQ = auto()  # !=
    LT = auto()  # <
    GT = auto()  # >
    LTE = auto()  # <=
    GTE = auto()  # >=
    AND = auto()  # &&
    OR = auto()  # ||
    NOT = auto()  # !
    ASSIGN = auto()  # =

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Delimiters
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    LPAREN = auto()  # (
    RPAREN = auto()  # )
    LBRACE = auto()  # {
    RBRACE = auto()  # }
    LBRACKET = auto()  # [
    RBRACKET = auto()  # ]
    SEMICOLON = auto()  # ;
    COLON = auto()  # :
    COMMA = auto()  # ,
    DOT = auto()  # .
    ARROW = auto()  # ->

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Comments (preserved for formatter)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    LINE_COMMENT = auto()  # // ...
    BLOCK_COMMENT = auto()  # /* ... */

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Special
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    NEWLINE = auto()  # \n (for error reporting)
    EOF = auto()  # End of file
    ERROR = auto()  # Lexer error token


# Keyword mapping
KEYWORDS: dict[str, TokenType] = {
    "flow": TokenType.FLOW,
    "interrupt": TokenType.INTERRUPT,
    "priority": TokenType.PRIORITY,
    "when": TokenType.WHEN,
    "image": TokenType.IMAGE,
    "const": TokenType.CONST,
    "let": TokenType.LET,
    "if": TokenType.IF,
    "elif": TokenType.ELIF,
    "else": TokenType.ELSE,
    "while": TokenType.WHILE,
    "for": TokenType.FOR,
    "in": TokenType.IN,
    "label": TokenType.LABEL,
    "goto": TokenType.GOTO,
    "try": TokenType.TRY,
    "catch": TokenType.CATCH,
    "break": TokenType.BREAK,
    "continue": TokenType.CONTINUE,
    "return": TokenType.RETURN,
    "hotkeys": TokenType.HOTKEYS,
    "true": TokenType.TRUE,
    "false": TokenType.FALSE,
    "null": TokenType.NULL,
    # RetroScript keywords
    "match": TokenType.MATCH,
    "retry": TokenType.RETRY,
    "times": TokenType.TIMES,
    "find": TokenType.FIND,
    "run": TokenType.RUN,
    "def": TokenType.DEF,
    "end": TokenType.END,
    "repeat": TokenType.REPEAT,
    "wait": TokenType.WAIT,
    "click": TokenType.CLICK,
    "type": TokenType.TYPE_KW,
    "press": TokenType.PRESS,
    "sleep": TokenType.SLEEP,
    "scroll": TokenType.SCROLL,
    "drag": TokenType.DRAG,
    # Logical keywords (word form)
    "and": TokenType.AND_KW,
    "or": TokenType.OR_KW,
    "not": TokenType.NOT_KW,
    # Phase 2: Testing & Config
    "test": TokenType.TEST,
    "mock": TokenType.MOCK,
    "assert": TokenType.ASSERT,
    "permissions": TokenType.PERMISSIONS,
    "config": TokenType.CONFIG,
    "meta": TokenType.META,
    "import": TokenType.IMPORT,
    "as": TokenType.AS,
    # Block end keywords
    "endif": TokenType.ENDIF,
    "endloop": TokenType.ENDLOOP,
    "endwhile": TokenType.ENDWHILE,
}


class Token:
    """A single token from the lexer."""

    __slots__ = ("type", "value", "line", "column", "end_line", "end_column")

    def __init__(
        self,
        token_type: TokenType,
        value: str,
        line: int,
        column: int,
        end_line: int | None = None,
        end_column: int | None = None,
    ) -> None:
        self.type = token_type
        self.value = value
        self.line = line
        self.column = column
        self.end_line = end_line if end_line is not None else line
        self.end_column = end_column if end_column is not None else column + len(value)

    def __repr__(self) -> str:
        return f"Token({self.type.name}, {self.value!r}, {self.line}:{self.column})"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Token):
            return False
        return self.type == other.type and self.value == other.value

    @property
    def span(self) -> tuple[int, int, int, int]:
        """Return (start_line, start_col, end_line, end_col)."""
        return (self.line, self.column, self.end_line, self.end_column)


================================================================================
FILE PATH: core\engine\__init__.py
LINES: 30
================================================================================

"""RetroAuto v2 - Engine package."""

from core.engine.context import EngineState, ExecutionContext
from core.engine.interrupts import InterruptManager, InterruptWatcher
from core.engine.memory_manager import MemoryManager, get_memory_manager
from core.engine.perf_profile import (
    PerformanceProfile,
    ProfileLevel,
    ProfileManager,
    get_profile,
    get_profile_manager,
)
from core.engine.runner import Runner

__all__ = [
    "ExecutionContext",
    "EngineState",
    "Runner",
    "InterruptWatcher",
    "InterruptManager",
    "MemoryManager",
    "get_memory_manager",
    "PerformanceProfile",
    "ProfileLevel",
    "ProfileManager",
    "get_profile",
    "get_profile_manager",
]




================================================================================
FILE PATH: core\engine\builtins.py
LINES: 375
================================================================================

"""
RetroAuto v2 - Built-in Functions

Standard library functions for RetroScript execution.
Part of RetroScript Phase 9 - Script Execution Engine.
"""

from __future__ import annotations

import random
import time
from collections.abc import Callable
from dataclasses import dataclass
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from core.engine.scope import ExecutionContext


from core.security.policy import Permission


@dataclass
class BuiltinFunction:
    """A built-in function definition."""

    name: str
    func: Callable[..., Any]
    min_args: int = 0
    max_args: int = -1  # -1 = unlimited
    description: str = ""
    permission: Permission = Permission.NONE


class BuiltinRegistry:
    """Registry of built-in functions.

    Usage:
        registry = BuiltinRegistry()
        result = registry.call("log", "Hello, world!")
    """

    def __init__(self) -> None:
        self._functions: dict[str, BuiltinFunction] = {}
        self._context: ExecutionContext | None = None
        self._register_defaults()

    def set_context(self, context: ExecutionContext) -> None:
        """Set execution context for builtins that need it."""
        self._context = context

    def register(
        self,
        name: str,
        func: Callable[..., Any],
        min_args: int = 0,
        max_args: int = -1,
        description: str = "",
        permission: Permission = Permission.NONE,
    ) -> None:
        """Register a built-in function."""
        self._functions[name] = BuiltinFunction(
            name=name,
            func=func,
            min_args=min_args,
            max_args=max_args,
            description=description,
            permission=permission,
        )

    def has(self, name: str) -> bool:
        """Check if function exists."""
        return name in self._functions

    def call(self, name: str, *args: Any, **kwargs: Any) -> Any:
        """Call a built-in function.

        Raises:
            NameError: If function not found
            TypeError: If wrong number of arguments
            SecurityViolation: If permission denied
        """
        if name not in self._functions:
            raise NameError(f"Unknown function: {name}")

        builtin = self._functions[name]

        # Security Check
        if builtin.permission != Permission.NONE and self._context:
            self._context.policy.check(builtin.permission)

        # Check argument count
        if len(args) < builtin.min_args:
            raise TypeError(
                f"{name}() requires at least {builtin.min_args} arguments, " f"got {len(args)}"
            )
        if builtin.max_args >= 0 and len(args) > builtin.max_args:
            raise TypeError(
                f"{name}() takes at most {builtin.max_args} arguments, " f"got {len(args)}"
            )

        return builtin.func(*args, **kwargs)

    def get_all(self) -> list[BuiltinFunction]:
        """Get all registered functions."""
        return list(self._functions.values())

    def _register_defaults(self) -> None:
        """Register default built-in functions."""
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Output functions
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.register("log", self._log, 1, -1, "Log a message")
        self.register("print", self._log, 1, -1, "Print a message")

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Time functions
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.register("sleep", self._sleep, 1, 1, "Sleep for duration")
        self.register("timestamp", self._timestamp, 0, 0, "Get current timestamp")
        self.register("time", self._time, 0, 0, "Get current time in seconds")

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Math functions
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.register("random", self._random, 0, 2, "Random number")
        self.register("abs", abs, 1, 1, "Absolute value")
        self.register("min", min, 2, -1, "Minimum value")
        self.register("max", max, 2, -1, "Maximum value")
        self.register("round", round, 1, 2, "Round number")
        self.register("floor", self._floor, 1, 1, "Floor value")
        self.register("ceil", self._ceil, 1, 1, "Ceiling value")

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # String functions
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.register("str", str, 1, 1, "Convert to string")
        self.register("int", self._to_int, 1, 1, "Convert to integer")
        self.register("float", float, 1, 1, "Convert to float")
        self.register("len", len, 1, 1, "Length of string/list")
        self.register("upper", self._upper, 1, 1, "Uppercase string")
        self.register("lower", self._lower, 1, 1, "Lowercase string")
        self.register("trim", self._trim, 1, 1, "Trim whitespace")
        self.register("split", self._split, 1, 2, "Split string")
        self.register("join", self._join, 2, 2, "Join list with separator")
        self.register("contains", self._contains, 2, 2, "Check if contains")
        self.register("replace", self._replace, 3, 3, "Replace in string")

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # List functions
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.register("range", self._range, 1, 3, "Generate range")
        self.register("list", list, 0, 1, "Create list")
        self.register("append", self._append, 2, 2, "Append to list")
        self.register("pop", self._pop, 1, 2, "Pop from list")
        self.register("first", self._first, 1, 1, "Get first element")
        self.register("last", self._last, 1, 1, "Get last element")

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Type checking
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.register("type", self._type, 1, 1, "Get type name")
        self.register("is_null", self._is_null, 1, 1, "Check if null")
        self.register("is_number", self._is_number, 1, 1, "Check if number")
        self.register("is_string", self._is_string, 1, 1, "Check if string")
        self.register("is_list", self._is_list, 1, 1, "Check if list")

        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # Automation stubs (to be implemented by engine)
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.register("find", self._find_stub, 1, 2, "Find image on screen", Permission.SCREEN_READ)
        self.register("wait", self._wait_stub, 1, 2, "Wait for image", Permission.SCREEN_READ)
        self.register(
            "click", self._click_stub, 1, 3, "Click at position", Permission.INPUT_CONTROL
        )
        self.register("move", self._move_stub, 2, 2, "Move mouse", Permission.INPUT_CONTROL)
        self.register("press", self._press_stub, 1, 1, "Press key", Permission.INPUT_CONTROL)
        self.register("type", self._type_text_stub, 1, 1, "Type text", Permission.INPUT_CONTROL)
        self.register("scroll", self._scroll_stub, 1, 1, "Scroll wheel", Permission.INPUT_CONTROL)
        self.register("drag", self._drag_stub, 4, 4, "Drag from to", Permission.INPUT_CONTROL)
        self.register(
            "hotkey", self._hotkey_stub, 1, 1, "Key combination", Permission.INPUT_CONTROL
        )

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Implementation functions
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _log(self, *args: Any) -> None:
        """Log message to console."""
        message = " ".join(str(a) for a in args)
        print(f"[LOG] {message}")

    def _sleep(self, duration: int | float) -> None:
        """Sleep for duration in milliseconds."""
        # Handle duration - could be ms or have suffix
        if isinstance(duration, str):
            duration = self._parse_duration(duration)
        elif isinstance(duration, (int, float)):  # noqa: SIM102
            # Assume milliseconds if small, seconds if < 1
            if duration > 100:  # Likely milliseconds
                duration = duration / 1000
        time.sleep(duration)

    def _timestamp(self) -> str:
        """Get current timestamp."""
        return time.strftime("%Y-%m-%d %H:%M:%S")

    def _time(self) -> float:
        """Get current time in seconds."""
        return time.time()

    def _random(self, *args: Any) -> int | float:
        """Generate random number."""
        if len(args) == 0:
            return random.random()
        elif len(args) == 1:
            return random.randint(0, int(args[0]))
        else:
            return random.randint(int(args[0]), int(args[1]))

    def _floor(self, x: float) -> int:
        """Floor value."""
        import math

        return math.floor(x)

    def _ceil(self, x: float) -> int:
        """Ceiling value."""
        import math

        return math.ceil(x)

    def _to_int(self, x: Any) -> int:
        """Convert to integer."""
        if isinstance(x, str):
            # Handle duration strings
            if x.endswith("ms"):
                return int(x[:-2])
            elif x.endswith("s"):
                return int(x[:-1]) * 1000
        return int(x)

    def _upper(self, s: str) -> str:
        return str(s).upper()

    def _lower(self, s: str) -> str:
        return str(s).lower()

    def _trim(self, s: str) -> str:
        return str(s).strip()

    def _split(self, s: str, sep: str = " ") -> list[str]:
        return str(s).split(sep)

    def _join(self, lst: list, sep: str) -> str:
        return sep.join(str(x) for x in lst)

    def _contains(self, haystack: Any, needle: Any) -> bool:
        return needle in haystack

    def _replace(self, s: str, old: str, new: str) -> str:
        return str(s).replace(old, new)

    def _range(self, *args: Any) -> list[int]:
        """Generate range as list."""
        if len(args) == 1:
            return list(range(int(args[0])))
        elif len(args) == 2:
            return list(range(int(args[0]), int(args[1])))
        else:
            return list(range(int(args[0]), int(args[1]), int(args[2])))

    def _append(self, lst: list, item: Any) -> list:
        """Append to list and return it."""
        lst.append(item)
        return lst

    def _pop(self, lst: list, index: int = -1) -> Any:
        """Pop from list."""
        return lst.pop(index)

    def _first(self, lst: list) -> Any:
        """Get first element."""
        return lst[0] if lst else None

    def _last(self, lst: list) -> Any:
        """Get last element."""
        return lst[-1] if lst else None

    def _type(self, x: Any) -> str:
        """Get type name."""
        if x is None:
            return "null"
        return type(x).__name__

    def _is_null(self, x: Any) -> bool:
        return x is None

    def _is_number(self, x: Any) -> bool:
        return isinstance(x, (int, float))

    def _is_string(self, x: Any) -> bool:
        return isinstance(x, str)

    def _is_list(self, x: Any) -> bool:
        return isinstance(x, list)

    def _parse_duration(self, duration: str) -> float:
        """Parse duration string to seconds."""
        duration = str(duration).strip().lower()
        if duration.endswith("ms"):
            return float(duration[:-2]) / 1000
        elif duration.endswith("s"):
            return float(duration[:-1])
        elif duration.endswith("m"):
            return float(duration[:-1]) * 60
        elif duration.endswith("h"):
            return float(duration[:-1]) * 3600
        return float(duration)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Automation stubs (replaced by actual engine)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _find_stub(self, target: str, **kwargs: Any) -> dict[str, Any] | None:
        """Stub for find - returns mock result."""
        print(f"[STUB] find({target})")
        return {"x": 100, "y": 100, "score": 0.95}

    def _wait_stub(self, target: str, timeout: Any = "10s") -> dict[str, Any] | None:
        """Stub for wait."""
        print(f"[STUB] wait({target}, timeout={timeout})")
        return {"x": 100, "y": 100, "score": 0.95}

    def _click_stub(self, x: int, y: int | None = None, button: str = "left") -> None:
        """Stub for click."""
        if y is None and isinstance(x, dict):
            # click($result) where result is {x, y}
            y = x.get("y", 0)
            x = x.get("x", 0)
        print(f"[STUB] click({x}, {y}, button={button})")

    def _move_stub(self, x: int, y: int) -> None:
        """Stub for move."""
        print(f"[STUB] move({x}, {y})")

    def _press_stub(self, key: str) -> None:
        """Stub for press."""
        print(f"[STUB] press({key})")

    def _type_text_stub(self, text: str) -> None:
        """Stub for type."""
        print(f"[STUB] type({text})")

    def _scroll_stub(self, amount: int) -> None:
        """Stub for scroll."""
        print(f"[STUB] scroll({amount})")

    def _drag_stub(self, x1: int, y1: int, x2: int, y2: int) -> None:
        """Stub for drag."""
        print(f"[STUB] drag({x1}, {y1}, {x2}, {y2})")

    def _hotkey_stub(self, keys: str) -> None:
        """Stub for hotkey."""
        print(f"[STUB] hotkey({keys})")


# Global registry instance
_default_registry = BuiltinRegistry()


def get_builtins() -> BuiltinRegistry:
    """Get the default builtin registry."""
    return _default_registry


================================================================================
FILE PATH: core\engine\context.py
LINES: 173
================================================================================

"""
RetroAuto v2 - Engine Execution Context

Shared state and resources for action execution.
"""

from dataclasses import dataclass, field
from enum import Enum
from threading import Event, Lock
from typing import Any

from core.models import Match, Script
from core.security.policy import SecurityPolicy
from core.templates import TemplateStore
from infra import get_logger
from input import KeyboardController, MouseController
from vision import ImageWaiter, Matcher, ScreenCapture, WaitOutcome

logger = get_logger("Context")


class EngineState(Enum):
    """Engine execution state."""

    IDLE = "idle"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPING = "stopping"


@dataclass
class ExecutionContext:
    """
    Shared context for action execution.

    Provides access to all services and shared state.
    Thread-safe for state changes.
    """

    # Script and templates
    script: Script
    templates: TemplateStore

    # Security
    policy: SecurityPolicy = field(default_factory=SecurityPolicy.unsafe)

    # Services
    capture: ScreenCapture = field(default_factory=ScreenCapture)
    matcher: Matcher | None = None
    waiter: ImageWaiter | None = None
    mouse: MouseController = field(default_factory=MouseController)
    keyboard: KeyboardController = field(default_factory=KeyboardController)

    # Execution state
    state: EngineState = EngineState.IDLE
    current_flow: str = ""
    current_step: int = 0

    # Last match result (for Click with use_match=True)
    last_match: Match | None = None

    # Variables for custom logic
    variables: dict[str, Any] = field(default_factory=dict)

    # Thread synchronization
    _lock: Lock = field(default_factory=Lock)
    _pause_event: Event = field(default_factory=Event)
    _stop_event: Event = field(default_factory=Event)

    def __post_init__(self) -> None:
        """Initialize derived services."""
        if self.matcher is None:
            self.matcher = Matcher(self.templates, self.capture)
        if self.waiter is None:
            self.waiter = ImageWaiter(self.matcher)
        self._pause_event.set()  # Not paused initially

    @property
    def is_running(self) -> bool:
        """Check if engine is running."""
        return self.state == EngineState.RUNNING

    @property
    def is_paused(self) -> bool:
        """Check if engine is paused."""
        return self.state == EngineState.PAUSED

    @property
    def should_stop(self) -> bool:
        """Check if stop was requested."""
        return self._stop_event.is_set()

    def set_state(self, state: EngineState) -> None:
        """Thread-safe state change."""
        with self._lock:
            old_state = self.state
            self.state = state
            logger.info("Engine state: %s -> %s", old_state.value, state.value)

    def request_pause(self) -> None:
        """Request pause (blocks execution at next checkpoint)."""
        self._pause_event.clear()
        self.set_state(EngineState.PAUSED)

    def request_resume(self) -> None:
        """Resume from pause."""
        self._pause_event.set()
        self.set_state(EngineState.RUNNING)

    def request_stop(self) -> None:
        """Request stop (sets flag, also unblocks pause)."""
        self._stop_event.set()
        self._pause_event.set()  # Unblock if paused
        self.set_state(EngineState.STOPPING)

    def reset(self) -> None:
        """Reset state for new execution."""
        self._stop_event.clear()
        self._pause_event.set()
        self.current_flow = ""
        self.current_step = 0
        self.last_match = None
        self.set_state(EngineState.IDLE)

    def wait_if_paused(self) -> bool:
        """
        Wait if paused. Returns False if stop requested.

        Call this at checkpoints in action execution.
        """
        self._pause_event.wait()
        return not self.should_stop

    def update_step(self, flow: str, step: int) -> None:
        """Update current position (thread-safe)."""
        with self._lock:
            self.current_flow = flow
            self.current_step = step

    def wait_for_image(
        self,
        asset_id: str,
        timeout_ms: int = 10000,
        appear: bool = True,
        smart_wait: bool = True,
    ) -> WaitOutcome | None:
        """Wait for image using configured waiter."""
        if not self.waiter:
            return None

        if appear:
            return self.waiter.wait_appear(asset_id, timeout_ms=timeout_ms, smart_wait=smart_wait)
        else:
            return self.waiter.wait_vanish(asset_id, timeout_ms=timeout_ms, smart_wait=smart_wait)

    def get_asset(self, asset_id: str) -> Any | None:
        """Get asset by ID from script."""
        if self.script:
            for asset in self.script.assets:
                if asset.id == asset_id:
                    return asset
        return None

    def last_match_center(self) -> tuple[int | None, int | None]:
        """Get center coordinates of last match."""
        if not self.last_match:
            return None, None

        # Calculate center
        # Match(x, y, w, h, confidence)
        cx = self.last_match.x + (self.last_match.w // 2)
        cy = self.last_match.y + (self.last_match.h // 2)
        return cx, cy


================================================================================
FILE PATH: core\engine\hotkey_listener.py
LINES: 248
================================================================================

"""
RetroAuto v2 - Hotkey Listener

Global keyboard shortcut listener for triggering Flows.
Uses pynput for cross-process key detection.
"""

from __future__ import annotations

import threading
from collections.abc import Callable
from dataclasses import dataclass

from infra import get_logger

logger = get_logger("HotkeyListener")

# Try to import pynput
try:
    from pynput import keyboard

    HAS_PYNPUT = True
except ImportError:
    HAS_PYNPUT = False
    keyboard = None


@dataclass
class HotkeyBinding:
    """A hotkey-to-action binding."""

    hotkey: str  # e.g., "f4", "ctrl+f4", "ctrl+shift+a"
    callback: Callable[[], None]
    enabled: bool = True


class HotkeyListener:
    """
    Global hotkey listener using pynput.

    Usage:
        listener = HotkeyListener()
        listener.register("f4", lambda: print("F4 pressed!"))
        listener.register("ctrl+f4", lambda: print("Ctrl+F4 pressed!"))
        listener.start()
        # ... later
        listener.stop()

    Note:
        - Keys are case-insensitive: "F4" == "f4"
        - Modifiers: ctrl, alt, shift, cmd (or win)
        - Special keys: f1-f12, space, enter, tab, etc.
    """

    _instance: HotkeyListener | None = None
    _lock = threading.Lock()
    _initialized: bool = False  # Type annotation for mypy

    def __new__(cls) -> HotkeyListener:
        """Singleton pattern."""
        with cls._lock:
            if cls._instance is None:
                cls._instance = super().__new__(cls)
                cls._instance._initialized = False
            return cls._instance

    def __init__(self) -> None:
        if self._initialized:
            return
        self._initialized = True

        self._bindings: dict[str, HotkeyBinding] = {}
        self._listener: keyboard.GlobalHotKeys | None = None
        self._running = False
        self._current_modifiers: set[str] = set()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Public API
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def register(self, hotkey: str, callback: Callable[[], None]) -> None:
        """
        Register a hotkey binding.

        Args:
            hotkey: Key combination (e.g., "f4", "ctrl+shift+a")
            callback: Function to call when hotkey is pressed
        """
        normalized = self._normalize_hotkey(hotkey)
        self._bindings[normalized] = HotkeyBinding(
            hotkey=normalized,
            callback=callback,
            enabled=True,
        )
        logger.info(f"Registered hotkey: {normalized}")

        # Restart listener if running to pick up new binding
        if self._running:
            self._restart_listener()

    def unregister(self, hotkey: str) -> bool:
        """Unregister a hotkey binding."""
        normalized = self._normalize_hotkey(hotkey)
        if normalized in self._bindings:
            del self._bindings[normalized]
            logger.info(f"Unregistered hotkey: {normalized}")
            if self._running:
                self._restart_listener()
            return True
        return False

    def set_enabled(self, hotkey: str, enabled: bool) -> None:
        """Enable or disable a hotkey without removing it."""
        normalized = self._normalize_hotkey(hotkey)
        if normalized in self._bindings:
            self._bindings[normalized].enabled = enabled

    def start(self) -> bool:
        """Start listening for hotkeys."""
        if not HAS_PYNPUT:
            logger.error("pynput not installed. Run: pip install pynput")
            return False

        if self._running:
            return True

        if not self._bindings:
            logger.warning("No hotkeys registered, nothing to listen for")
            return False

        self._create_listener()
        self._running = True
        logger.info(f"HotkeyListener started with {len(self._bindings)} bindings")
        return True

    def stop(self) -> None:
        """Stop listening for hotkeys."""
        if self._listener:
            self._listener.stop()
            self._listener = None
        self._running = False
        logger.info("HotkeyListener stopped")

    def is_running(self) -> bool:
        """Check if listener is active."""
        return self._running

    def get_bindings(self) -> list[str]:
        """Get list of registered hotkeys."""
        return list(self._bindings.keys())

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Internal Methods
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _normalize_hotkey(self, hotkey: str) -> str:
        """
        Normalize hotkey string to pynput format.
        "Ctrl+Shift+C" -> "<ctrl>+<shift>+c"
        "Ctrl+F4" -> "<ctrl>+<f4>"
        """
        # Special keys that need angle brackets
        special_keys = {
            "ctrl", "control", "alt", "shift", "cmd", "win", "windows",
            "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12",
            "space", "enter", "return", "tab", "escape", "esc",
            "backspace", "delete", "insert", "home", "end", "pageup", "pagedown",
            "up", "down", "left", "right", "caps_lock", "num_lock", "scroll_lock",
        }

        parts = hotkey.lower().replace(" ", "").split("+")
        normalized_parts = []

        for part in parts:
            # Map common aliases
            if part in ("control",):
                part = "ctrl"
            if part in ("win", "windows"):
                part = "cmd"

            # Only wrap special keys in angle brackets
            # Regular character keys like 'a', 'c', '1' stay as-is
            if part in special_keys:
                if not part.startswith("<"):
                    part = f"<{part}>"
            normalized_parts.append(part)

        return "+".join(normalized_parts)

    def _create_listener(self) -> None:
        """Create pynput GlobalHotKeys listener."""
        hotkey_map = {}

        for normalized, binding in self._bindings.items():
            if binding.enabled:
                # Create a closure to capture the binding
                def make_callback(b: HotkeyBinding) -> Callable[[], None]:
                    def cb() -> None:
                        logger.info(f">>> Global hotkey triggered: {b.hotkey} <<<")
                        try:
                            b.callback()
                        except Exception as e:
                            logger.error(f"Hotkey callback error: {e}")

                    return cb

                hotkey_map[normalized] = make_callback(binding)

        # Log registered hotkeys for debugging
        logger.info(f"Creating GlobalHotKeys with bindings: {list(hotkey_map.keys())}")
        self._listener = keyboard.GlobalHotKeys(hotkey_map)
        self._listener.daemon = True  # Ensure daemon thread
        self._listener.start()

    def _restart_listener(self) -> None:
        """Restart the listener to pick up new bindings."""
        self.stop()
        self.start()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Convenience Functions
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


def get_hotkey_listener() -> HotkeyListener:
    """Get the global HotkeyListener instance."""
    return HotkeyListener()


# Simple test
if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG)

    listener = get_hotkey_listener()
    listener.register("f4", lambda: print(">>> F4 pressed! <<<"))
    listener.register("ctrl+f4", lambda: print(">>> Ctrl+F4 pressed! <<<"))
    listener.start()

    print("Listening for F4 and Ctrl+F4... Press Ctrl+C to exit.")
    try:
        import time

        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        listener.stop()
        print("Stopped.")


================================================================================
FILE PATH: core\engine\interpreter.py
LINES: 433
================================================================================

"""
RetroAuto v2 - AST Interpreter

Execute RetroScript AST nodes directly.
Part of RetroScript Phase 9 - Script Execution Engine.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

from core.dsl.ast import (
    ArrayExpr,
    AssignStmt,
    ASTNode,
    BinaryExpr,
    BlockStmt,
    BreakStmt,
    CallExpr,
    ContinueStmt,
    ExprStmt,
    FlowDecl,
    ForStmt,
    Identifier,
    IfStmt,
    LetStmt,
    Literal,
    Program,
    ReturnStmt,
    TryStmt,
    UnaryExpr,
    WhileStmt,
)
from core.engine.builtins import BuiltinRegistry, get_builtins
from core.engine.scope import ExecutionContext

if TYPE_CHECKING:
    pass


class InterpreterError(Exception):
    """Error during script interpretation."""

    def __init__(self, message: str, node: ASTNode | None = None) -> None:
        self.node = node
        super().__init__(message)


from core.security.policy import Permission, SecurityPolicy  # noqa: E402


class Interpreter:
    """AST interpreter for RetroScript.

    Usage:
        interpreter = Interpreter()
        result = interpreter.execute(program)
    """

    def __init__(self, builtins: BuiltinRegistry | None = None) -> None:
        self.builtins = builtins or get_builtins()
        self.context = ExecutionContext()
        self.builtins.set_context(self.context)  # Bind context for security checks
        self._flows: dict[str, FlowDecl] = {}

        # Optimization: Dispatch tables
        self._stmt_dispatch = {
            LetStmt: self._execute_let,
            AssignStmt: self._execute_assign,
            IfStmt: self._execute_if,
            WhileStmt: self._execute_while,
            ForStmt: self._execute_for,
            TryStmt: self._execute_try,
            ReturnStmt: self._execute_return,
            BreakStmt: lambda n: self.context.set_break(),
            ContinueStmt: lambda n: self.context.set_continue(),
            BlockStmt: self._execute_block,
            ExprStmt: lambda n: self._eval(n.expr),
            CallExpr: self._eval_call,
        }

        self._expr_dispatch = {
            Literal: self._eval_literal,
            Identifier: self._eval_identifier,
            BinaryExpr: self._eval_binary,
            UnaryExpr: self._eval_unary,
            CallExpr: self._eval_call,
            ArrayExpr: self._eval_array,
        }

    def execute(self, program: Program) -> Any:
        """Execute a program.

        Args:
            program: Parsed program AST

        Returns:
            Result of main flow, if any
        """
        # Phase 15: Apply Security Policy
        if program.permissions:
            # Parse permissions list ["FS_READ", "NET_ALL"]
            allowed = Permission.NONE
            for perm_str in program.permissions:
                try:
                    # Support single flags (FS_READ) and combined (FS_ALL)
                    p = getattr(Permission, perm_str)
                    allowed |= p
                except AttributeError:
                    print(f"[WARN] Unknown permission: {perm_str}")

            # Update policy (restrictive)
            self.context.policy = SecurityPolicy(permissions=allowed)
        else:
            # Default policy (Safe or Unsafe depending on config - defaulting to Unsafe for now to not break existing scripts)
            pass

        # Register constants
        for const in program.constants:
            value = self._eval(const.initializer)
            self.context.scope.set_global(const.name, value)

        # Register flows
        for flow in program.flows:
            self._flows[flow.name] = flow

        # Execute main flow
        main_flow = program.main_flow
        if main_flow:
            return self._execute_flow(main_flow)

        return None

    def _execute_flow(self, flow: FlowDecl) -> Any:
        """Execute a flow."""
        self.context.call_depth += 1
        if self.context.call_depth > 500:
            # Reset to avoid lock-up state if caught
            self.context.call_depth -= 1
            raise InterpreterError("Stack Overflow: Max recursion depth exceeded (500)")

        self.context.enter_flow(flow.name)
        try:
            self._execute_block(flow.body)
            return self.context.get_return()
        finally:
            self.context.exit_flow()
            self.context.call_depth -= 1

    def _execute_block(self, block: BlockStmt) -> None:
        """Execute a block of statements."""
        for stmt in block.statements:
            self._execute_stmt(stmt)

            # Check for control flow
            if (
                self.context.should_return()
                or self.context.should_break()
                or self.context.should_continue()
            ):
                break

    def _execute_stmt(self, node: ASTNode) -> None:
        """Execute a statement using dispatch table."""
        handler = self._stmt_dispatch.get(type(node))
        if handler:
            handler(node)
        else:
            # Fallback for expression statements or unknown nodes
            self._eval(node)

    def _execute_let(self, node: LetStmt) -> None:
        """Execute let declaration."""
        value = None
        if node.initializer:
            value = self._eval(node.initializer)
        self.context.scope.define(node.name, value)

    def _execute_assign(self, node: AssignStmt) -> None:
        """Execute assignment."""
        value = self._eval(node.value)

        if isinstance(node.target, Identifier):
            name = node.target.name
            # Handle $variable syntax
            if name.startswith("$"):
                name = name[1:]
            self.context.scope.assign(name, value)
        else:
            raise InterpreterError(f"Invalid assignment target: {node.target}", node)

    def _execute_if(self, node: IfStmt) -> None:
        """Execute if statement."""
        condition = self._eval(node.condition)

        if self._is_truthy(condition):
            self._execute_block(node.then_branch)
        else:
            # Check elif branches
            for elif_cond, elif_block in node.elif_branches:
                if self._is_truthy(self._eval(elif_cond)):
                    self._execute_block(elif_block)
                    return

            # Execute else
            if node.else_branch:
                self._execute_block(node.else_branch)

    def _execute_while(self, node: WhileStmt) -> None:
        """Execute while loop."""
        while self._is_truthy(self._eval(node.condition)):
            self._execute_block(node.body)

            # Handle break/continue
            if self.context.clear_break():
                break
            self.context.clear_continue()

            # Handle return
            if self.context.should_return():
                break

    def _execute_for(self, node: ForStmt) -> None:
        """Execute for loop."""
        iterable = self._eval(node.iterable)

        if not hasattr(iterable, "__iter__"):
            raise InterpreterError(f"Cannot iterate over: {type(iterable)}", node)

        for item in iterable:
            self.context.scope.define(node.variable, item)
            self._execute_block(node.body)

            # Handle break/continue
            if self.context.clear_break():
                break
            self.context.clear_continue()

            # Handle return
            if self.context.should_return():
                break

    def _execute_try(self, node: TryStmt) -> None:
        """Execute try-catch block."""
        try:
            self._execute_block(node.try_block)
        except Exception as e:
            # Set catch variable
            if node.catch_var:
                self.context.scope.define(node.catch_var, str(e))
            self._execute_block(node.catch_block)

    def _execute_return(self, node: ReturnStmt) -> None:
        """Execute return statement."""
        value = None
        if node.value:
            value = self._eval(node.value)
        self.context.set_return(value)

    def _eval(self, node: ASTNode) -> Any:
        """Evaluate an expression using dispatch table."""
        handler = self._expr_dispatch.get(type(node))
        if handler:
            return handler(node)

        raise InterpreterError(f"Unknown expression type: {type(node)}", node)

    def _eval_literal(self, node: Literal) -> Any:
        """Evaluate literal value."""
        if node.literal_type == "null":
            return None
        elif node.literal_type == "bool":
            return node.value in (True, "true", "True")
        elif node.literal_type == "duration":
            # Return duration in milliseconds
            return self._parse_duration_ms(node.value)
        return node.value

    def _eval_identifier(self, node: Identifier) -> Any:
        """Evaluate identifier."""
        name = node.name
        if name.startswith("$"):
            name = name[1:]
        return self.context.scope.get(name)

    def _eval_binary(self, node: BinaryExpr) -> Any:
        """Evaluate binary expression."""
        op = node.operator

        # Short-circuit evaluation for logical operators
        if op in ("and", "&&"):
            left = self._eval(node.left)
            if not self._is_truthy(left):
                return left
            return self._eval(node.right)

        if op in ("or", "||"):
            left = self._eval(node.left)
            if self._is_truthy(left):
                return left
            return self._eval(node.right)

        # Evaluate both sides
        left = self._eval(node.left)
        right = self._eval(node.right)

        # Arithmetic
        if op == "+":
            if isinstance(left, str) or isinstance(right, str):
                return str(left) + str(right)
            return left + right
        elif op == "-":
            return left - right
        elif op == "*":
            return left * right
        elif op == "/":
            if right == 0:
                raise InterpreterError("Division by zero", node)
            return left / right
        elif op == "%":
            return left % right

        # Comparison
        elif op == "==":
            return left == right
        elif op == "!=":
            return left != right
        elif op == "<":
            return left < right
        elif op == "<=":
            return left <= right
        elif op == ">":
            return left > right
        elif op == ">=":
            return left >= right

        else:
            raise InterpreterError(f"Unknown operator: {op}", node)

    def _eval_unary(self, node: UnaryExpr) -> Any:
        """Evaluate unary expression."""
        operand = self._eval(node.operand)

        if node.operator == "-":
            return -operand
        elif node.operator in ("!", "not"):
            return not self._is_truthy(operand)

        raise InterpreterError(f"Unknown unary operator: {node.operator}", node)

    def _eval_call(self, node: CallExpr) -> Any:
        """Evaluate function call."""
        name = node.callee

        # Check if it's a flow call
        if name in self._flows:
            return self._call_flow(name, node.args)

        # Check if it's a built-in
        if self.builtins.has(name):
            args = [self._eval(arg) for arg in node.args]
            kwargs = {k: self._eval(v) for k, v in node.kwargs.items()}
            return self.builtins.call(name, *args, **kwargs)

        # Check special built-in "run"
        if name == "run" and node.args:
            flow_name = self._eval(node.args[0])
            if isinstance(flow_name, str) and flow_name in self._flows:
                return self._call_flow(flow_name, node.args[1:])

        raise InterpreterError(f"Unknown function: {name}", node)

    def _call_flow(self, name: str, args: list[ASTNode]) -> Any:
        """Call a flow by name."""
        flow = self._flows.get(name)
        if not flow:
            raise InterpreterError(f"Unknown flow: {name}")

        return self._execute_flow(flow)

    def _eval_array(self, node: ArrayExpr) -> list[Any]:
        """Evaluate array expression."""
        return [self._eval(elem) for elem in node.elements]

    def _is_truthy(self, value: Any) -> bool:
        """Check if value is truthy."""
        if value is None:
            return False
        if isinstance(value, bool):
            return value
        if isinstance(value, (int, float)):
            return value != 0
        if isinstance(value, str):
            return len(value) > 0
        if isinstance(value, (list, dict)):
            return len(value) > 0
        return True

    def _parse_duration_ms(self, value: Any) -> int:
        """Parse duration to milliseconds."""
        if isinstance(value, (int, float)):
            return int(value)
        s = str(value).strip().lower()
        if s.endswith("ms"):
            return int(s[:-2])
        elif s.endswith("s"):
            return int(float(s[:-1]) * 1000)
        elif s.endswith("m"):
            return int(float(s[:-1]) * 60000)
        elif s.endswith("h"):
            return int(float(s[:-1]) * 3600000)
        return int(value)


def interpret(source: str) -> Any:
    """Convenience function to parse and interpret source code.

    Args:
        source: RetroScript source code

    Returns:
        Result of execution
    """
    from core.dsl.parser import Parser

    parser = Parser(source)
    program = parser.parse()

    if parser.errors:
        raise InterpreterError(f"Parse errors: {parser.errors}")

    interpreter = Interpreter()
    return interpreter.execute(program)


================================================================================
FILE PATH: core\engine\interrupt_scanner.py
LINES: 384
================================================================================

"""
RetroAuto v2 - Interrupt Scanner

Background thread that monitors screen for interrupt triggers.
When an interrupt image is detected, it pauses main flow and executes interrupt actions.
"""

from __future__ import annotations

import threading
import time
from collections.abc import Callable
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import TYPE_CHECKING

from core.engine.hotkey_listener import get_hotkey_listener
from core.models import Action, InterruptRule
from infra import get_logger

if TYPE_CHECKING:
    from core.engine.context import ExecutionContext
    from vision import TemplateMatcher

logger = get_logger("InterruptScanner")


class InterruptState(Enum):
    """Interrupt scanner state."""

    IDLE = auto()
    SCANNING = auto()
    EXECUTING = auto()
    STOPPED = auto()


@dataclass
class InterruptMatch:
    """Result of an interrupt trigger."""

    rule: InterruptRule
    match_x: int
    match_y: int
    match_w: int
    match_h: int
    confidence: float
    timestamp: float = field(default_factory=time.time)


class InterruptScanner:
    """
    Background scanner for interrupt triggers.

    Features:
    - Scans screen at configurable interval
    - Checks interrupts by priority order
    - Pauses main flow when interrupt triggered
    - Executes interrupt actions
    - Resumes main flow after interrupt

    Usage:
        scanner = InterruptScanner(ctx, matcher)
        scanner.on_interrupt(callback)  # Register handler
        scanner.start()
        # ... main script runs ...
        scanner.stop()
    """

    def __init__(
        self,
        ctx: ExecutionContext,
        matcher: TemplateMatcher,
        scan_interval_ms: int = 200,
    ) -> None:
        """
        Initialize interrupt scanner.

        Args:
            ctx: Execution context with script and state
            matcher: Template matcher for image detection
            scan_interval_ms: Time between scans in milliseconds
        """
        self._ctx = ctx
        self._matcher = matcher
        self._scan_interval = scan_interval_ms / 1000.0

        self._state = InterruptState.IDLE
        self._thread: threading.Thread | None = None
        self._stop_event = threading.Event()
        self._pause_event = threading.Event()
        self._pause_event.set()  # Not paused initially

        # Callbacks
        self._on_interrupt_callbacks: list[Callable[[InterruptMatch], None]] = []
        self._on_interrupt_complete_callbacks: list[Callable[[InterruptMatch, bool], None]] = []

        # Current interrupt being executed
        self._current_interrupt: InterruptMatch | None = None

        # Cooldown to avoid re-triggering same interrupt
        self._cooldown: dict[str, float] = {}

        # Hotkey listener for hotkey-type interrupts
        self._hotkey_listener = get_hotkey_listener()
        self._cooldown_duration = 2.0  # seconds

        # Adaptive scan intervals (performance optimization)
        self._interval_idle = 0.5  # 500ms when no script running
        self._interval_active = scan_interval_ms / 1000.0  # User-specified
        self._interval_fast = 0.1  # 100ms for time-critical scenarios
        self._last_scan_had_activity = False

    @property
    def state(self) -> InterruptState:
        """Get current scanner state."""
        return self._state

    @property
    def is_running(self) -> bool:
        """Check if scanner is running."""
        return self._state in (InterruptState.SCANNING, InterruptState.EXECUTING)

    def on_interrupt(self, callback: Callable[[InterruptMatch], None]) -> None:
        """Register callback for when interrupt is triggered."""
        self._on_interrupt_callbacks.append(callback)

    def on_interrupt_complete(self, callback: Callable[[InterruptMatch, bool], None]) -> None:
        """Register callback for when interrupt execution completes."""
        self._on_interrupt_complete_callbacks.append(callback)

    def start(self) -> None:
        """Start the interrupt scanner thread."""
        if self._thread is not None and self._thread.is_alive():
            logger.warning("Scanner already running")
            return

        self._stop_event.clear()
        self._pause_event.set()
        self._state = InterruptState.SCANNING

        # Register hotkey-type interrupts
        self._register_hotkey_interrupts()

        self._thread = threading.Thread(target=self._scan_loop, daemon=True)
        self._thread.start()
        logger.info("Interrupt scanner started (interval: %.0fms)", self._scan_interval * 1000)

    def stop(self) -> None:
        """Stop the interrupt scanner thread."""
        self._stop_event.set()
        self._state = InterruptState.STOPPED

        # Stop hotkey listener
        self._hotkey_listener.stop()

        if self._thread is not None:
            self._thread.join(timeout=2.0)
            self._thread = None

        logger.info("Interrupt scanner stopped")

    def pause(self) -> None:
        """Pause scanning (e.g., while executing interrupt)."""
        self._pause_event.clear()
        logger.debug("Scanner paused")

    def resume(self) -> None:
        """Resume scanning after pause."""
        self._pause_event.set()
        logger.debug("Scanner resumed")

    def _register_hotkey_interrupts(self) -> None:
        """Register hotkey-type interrupts with the HotkeyListener."""
        for rule in self._ctx.script.interrupts:
            if rule.trigger_type == "hotkey" and rule.when_hotkey:
                # Create a callback that triggers this rule
                def make_callback(r: InterruptRule):
                    def cb():
                        logger.info(f"Hotkey triggered: {r.when_hotkey}")
                        # Create a dummy InterruptMatch for hotkey triggers
                        match = InterruptMatch(
                            rule=r,
                            match_x=0,
                            match_y=0,
                            match_w=0,
                            match_h=0,
                            confidence=1.0,
                        )
                        self._handle_interrupt(match)

                    return cb

                self._hotkey_listener.register(rule.when_hotkey, make_callback(rule))
                logger.info(f"Registered hotkey interrupt: {rule.when_hotkey}")

        # Start the hotkey listener if we have any bindings
        if self._hotkey_listener.get_bindings():
            self._hotkey_listener.start()

    def _scan_loop(self) -> None:
        """Main scanning loop - runs in background thread."""
        while not self._stop_event.is_set():
            # Wait for resume if paused
            self._pause_event.wait()

            if self._stop_event.is_set():
                break

            # Scan for interrupts
            try:
                match = self._check_interrupts()
                if match is not None:
                    self._handle_interrupt(match)
                    self._last_scan_had_activity = True
                else:
                    self._last_scan_had_activity = False
            except Exception as e:
                logger.error("Error in interrupt scan: %s", e)

            # Adaptive interval: slower when idle, faster when active
            interval = self._get_adaptive_interval()
            time.sleep(interval)

        self._state = InterruptState.STOPPED

    def _get_adaptive_interval(self) -> float:
        """Calculate adaptive scan interval based on engine state."""
        # If engine is not running (idle), use slow interval to save CPU
        engine_state = self._ctx.state
        from core.engine.context import EngineState

        if engine_state == EngineState.IDLE:
            return self._interval_idle
        elif engine_state == EngineState.RUNNING:
            # If last scan had activity, use fast interval
            if self._last_scan_had_activity:
                return self._interval_fast
            return self._interval_active
        else:
            return self._interval_active

    def _check_interrupts(self) -> InterruptMatch | None:
        """
        Check all interrupts in priority order.

        Returns:
            InterruptMatch if an interrupt is triggered, None otherwise
        """
        # Get interrupts sorted by priority (high first)
        interrupts = sorted(self._ctx.script.interrupts, key=lambda r: r.priority, reverse=True)

        current_time = time.time()

        for rule in interrupts:
            # Skip hotkey-type rules (handled by HotkeyListener)
            if rule.trigger_type == "hotkey":
                continue

            # Skip if no when_image for image-type
            if not rule.when_image:
                continue

            # Skip if in cooldown
            cooldown_key = rule.when_image
            if (
                cooldown_key in self._cooldown
                and current_time - self._cooldown[cooldown_key] < self._cooldown_duration
            ):
                continue

            # Get asset for this interrupt
            asset = self._ctx.script.get_asset(rule.when_image)
            if asset is None:
                continue

            # Determine ROI
            roi = rule.roi_override or asset.roi
            roi_tuple = (roi.x, roi.y, roi.w, roi.h) if roi else None

            # Try to match
            result = self._matcher.find(
                asset_id=asset.id,
                threshold=asset.threshold,
                roi=roi_tuple,
            )

            if result is not None:
                # Found a match!
                logger.info("Interrupt triggered: %s (priority %d)", rule.when_image, rule.priority)

                # Set cooldown
                self._cooldown[cooldown_key] = current_time

                return InterruptMatch(
                    rule=rule,
                    match_x=result.x,
                    match_y=result.y,
                    match_w=result.w,
                    match_h=result.h,
                    confidence=result.confidence,
                )

        return None

    def _handle_interrupt(self, match: InterruptMatch) -> None:
        """Handle a triggered interrupt."""
        self._state = InterruptState.EXECUTING
        self._current_interrupt = match

        # Notify callbacks
        for callback in self._on_interrupt_callbacks:
            try:
                callback(match)
            except Exception as e:
                logger.error("Error in interrupt callback: %s", e)

        # Execute interrupt actions
        success = True
        try:
            if match.rule.do_actions:
                # Execute inline actions
                success = self._execute_actions(match.rule.do_actions)
            elif match.rule.run_flow:
                # Run a flow
                # This would need integration with Runner
                logger.info("Would run flow: %s", match.rule.run_flow)
        except Exception as e:
            logger.error("Error executing interrupt: %s", e)
            success = False

        # Notify completion
        for callback in self._on_interrupt_complete_callbacks:
            try:
                callback(match, success)
            except Exception as e:
                logger.error("Error in completion callback: %s", e)

        self._current_interrupt = None
        self._state = InterruptState.SCANNING

    def _execute_actions(self, actions: list[Action]) -> bool:
        """
        Execute a list of actions.

        For now, this is a simple implementation.
        In production, this should integrate with Runner.
        """
        from core.models import Click, Delay, Hotkey, TypeText
        from input.keyboard import KeyboardController
        from input.mouse import MouseController

        mouse = MouseController()
        keyboard = KeyboardController()

        for action in actions:
            if self._stop_event.is_set():
                return False

            if isinstance(action, Click):
                x = (
                    action.x
                    or self._current_interrupt.match_x + self._current_interrupt.match_w // 2
                )
                y = (
                    action.y
                    or self._current_interrupt.match_y + self._current_interrupt.match_h // 2
                )
                mouse.click(x, y, action.button, action.clicks)

            elif isinstance(action, Delay):
                time.sleep(action.ms / 1000.0)

            elif isinstance(action, Hotkey):
                keyboard.hotkey(action.keys)

            elif isinstance(action, TypeText):
                keyboard.type_text(action.text, paste=action.paste_mode)

        return True

    def clear_cooldowns(self) -> None:
        """Clear all interrupt cooldowns."""
        self._cooldown.clear()
        logger.debug("Interrupt cooldowns cleared")


================================================================================
FILE PATH: core\engine\interrupts.py
LINES: 215
================================================================================

"""
RetroAuto v2 - Interrupt Watcher

Background thread that monitors for interrupt conditions.
"""

import threading
import time
from typing import TYPE_CHECKING

from core.engine.context import EngineState, ExecutionContext
from core.models import InterruptRule
from infra import get_logger

if TYPE_CHECKING:
    from core.engine.runner import Runner

logger = get_logger("Interrupts")


class InterruptWatcher:
    """
    Background thread that watches for interrupt conditions.

    Features:
    - Priority-based checking (higher priority first)
    - Pauses main runner when triggered
    - Executes interrupt actions or flow
    - Thread-safe with locks
    - Exponential backoff during idle
    """

    def __init__(
        self,
        ctx: ExecutionContext,
        runner: "Runner",
        poll_ms: int = 200,
        backoff_max_ms: int = 1000,
    ) -> None:
        """
        Initialize interrupt watcher.

        Args:
            ctx: Execution context
            runner: Runner for executing interrupt actions
            poll_ms: Base polling interval
            backoff_max_ms: Maximum backoff during idle
        """
        self._ctx = ctx
        self._runner = runner
        self._poll_ms = poll_ms
        self._backoff_max_ms = backoff_max_ms

        self._thread: threading.Thread | None = None
        self._running = False
        self._lock = threading.Lock()
        self._triggered_cooldown: dict[str, float] = {}  # Prevent spam

    def start(self) -> None:
        """Start the watcher thread."""
        if self._running:
            return

        self._running = True
        self._thread = threading.Thread(target=self._watch_loop, daemon=True)
        self._thread.start()
        logger.info("InterruptWatcher started")

    def stop(self) -> None:
        """Stop the watcher thread."""
        self._running = False
        if self._thread:
            self._thread.join(timeout=2.0)
            self._thread = None
        logger.info("InterruptWatcher stopped")

    def _watch_loop(self) -> None:
        """Main watch loop."""
        current_poll = self._poll_ms
        consecutive_idle = 0

        while self._running:
            # Only check when engine is running
            if self._ctx.state != EngineState.RUNNING:
                time.sleep(self._poll_ms / 1000.0)
                continue

            # Check interrupts in priority order
            triggered = self._check_interrupts()

            if triggered:
                consecutive_idle = 0
                current_poll = self._poll_ms
            else:
                consecutive_idle += 1
                # Exponential backoff during idle
                if consecutive_idle > 5:
                    current_poll = min(current_poll * 1.2, self._backoff_max_ms)

            time.sleep(current_poll / 1000.0)

    def _check_interrupts(self) -> bool:
        """
        Check all interrupt rules in priority order.

        Returns:
            True if any interrupt was triggered
        """
        rules = self._get_sorted_rules()

        for rule in rules:
            # Check cooldown
            cooldown_key = rule.when_image
            if (
                cooldown_key in self._triggered_cooldown
                and time.time() - self._triggered_cooldown[cooldown_key] < 1.0
            ):
                continue  # Skip, still in cooldown

            # Check if image is present
            match = self._ctx.matcher.find(rule.when_image, rule.roi_override)
            if match is None:
                continue

            logger.info(
                "Interrupt triggered: %s (priority=%d, conf=%.2f)",
                rule.when_image,
                rule.priority,
                match.confidence,
            )

            # Update cooldown
            self._triggered_cooldown[cooldown_key] = time.time()

            # Store match for actions
            self._ctx.last_match = match

            # Execute interrupt
            self._execute_interrupt(rule)
            return True

        return False

    def _get_sorted_rules(self) -> list[InterruptRule]:
        """Get interrupt rules sorted by priority (descending)."""
        rules = list(self._ctx.script.interrupts)
        rules.sort(key=lambda r: r.priority, reverse=True)
        return rules

    def _execute_interrupt(self, rule: InterruptRule) -> None:
        """
        Execute interrupt actions.

        The main runner is already paused via shared state.
        """
        with self._lock:
            # Pause main execution while handling interrupt
            was_running = self._ctx.is_running
            if was_running:
                self._ctx.request_pause()

            try:
                if rule.run_flow:
                    # Run a flow
                    logger.info("Interrupt running flow: %s", rule.run_flow)
                    self._runner.run_flow(rule.run_flow)
                elif rule.do_actions:
                    # Execute inline actions
                    logger.info("Interrupt executing %d actions", len(rule.do_actions))
                    for action in rule.do_actions:
                        if self._ctx.should_stop:
                            break
                        self._runner._execute_action(action, None, {})
            except Exception as e:
                logger.exception("Error executing interrupt: %s", e)
            finally:
                # Resume main execution
                if was_running and not self._ctx.should_stop:
                    self._ctx.request_resume()


class InterruptManager:
    """
    High-level manager for interrupt handling.

    Coordinates between runner and watcher.
    """

    def __init__(self, ctx: ExecutionContext) -> None:
        self._ctx = ctx
        self._runner: Runner | None = None
        self._watcher: InterruptWatcher | None = None

    def set_runner(self, runner: "Runner") -> None:
        """Set the runner instance."""
        self._runner = runner

    def start_watching(self) -> None:
        """Start interrupt watching."""
        if self._runner is None:
            logger.warning("Cannot start watching: no runner set")
            return

        if not self._ctx.script.interrupts:
            logger.debug("No interrupt rules defined, skipping watcher")
            return

        self._watcher = InterruptWatcher(self._ctx, self._runner)
        self._watcher.start()

    def stop_watching(self) -> None:
        """Stop interrupt watching."""
        if self._watcher:
            self._watcher.stop()
            self._watcher = None


================================================================================
FILE PATH: core\engine\memory_manager.py
LINES: 180
================================================================================

"""
RetroAuto v2 - Memory Manager

Background memory monitoring and cleanup for 24/7 operation.
Phase 2.2 Performance Optimization.
"""

import gc
import threading
import time
from typing import Callable

from infra import get_logger

logger = get_logger("MemoryManager")


class MemoryManager:
    """
    Background memory monitoring and cleanup for 24/7 operation.

    Features:
    - Periodic memory monitoring
    - Threshold-based garbage collection
    - Cache cleanup coordination
    - Memory usage logging
    """

    _instance: "MemoryManager | None" = None
    _lock = threading.Lock()

    def __new__(cls) -> "MemoryManager":
        """Singleton pattern for single memory manager."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialized = False
        return cls._instance

    def __init__(
        self,
        threshold_mb: int = 200,  # Lowered from 300 for 24/7 stability
        check_interval_seconds: int = 30,  # More frequent from 60 for proactive cleanup
    ) -> None:
        if self._initialized:
            return

        self._threshold = threshold_mb * 1024 * 1024  # Convert to bytes
        self._check_interval = check_interval_seconds
        self._running = False
        self._thread: threading.Thread | None = None

        # Callbacks for coordinated cleanup
        self._cleanup_callbacks: list[Callable[[], None]] = []

        # Stats
        self._cleanup_count = 0
        self._peak_memory = 0

        self._initialized = True
        logger.info(
            "MemoryManager initialized (threshold: %dMB, interval: %ds)",
            threshold_mb,
            check_interval_seconds,
        )

    def register_cleanup(self, callback: Callable[[], None]) -> None:
        """Register a callback to be called during cleanup."""
        self._cleanup_callbacks.append(callback)

    def start(self) -> None:
        """Start background monitoring thread."""
        if self._running:
            return

        self._running = True
        self._thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self._thread.start()
        logger.info("MemoryManager started")

    def stop(self) -> None:
        """Stop background monitoring."""
        self._running = False
        if self._thread:
            self._thread.join(timeout=2.0)
            self._thread = None
        logger.info("MemoryManager stopped")

    def _monitor_loop(self) -> None:
        """Main monitoring loop."""
        while self._running:
            try:
                mem_bytes = self._get_memory_usage()
                mem_mb = mem_bytes / (1024 * 1024)

                # Track peak
                if mem_bytes > self._peak_memory:
                    self._peak_memory = mem_bytes

                # Check threshold
                if mem_bytes > self._threshold:
                    logger.warning(
                        "Memory threshold exceeded: %.1fMB > %.1fMB, triggering cleanup",
                        mem_mb,
                        self._threshold / (1024 * 1024),
                    )
                    self._force_cleanup()

            except Exception as e:
                logger.error("MemoryManager error: %s", e)

            time.sleep(self._check_interval)

    def _get_memory_usage(self) -> int:
        """Get current process memory usage in bytes."""
        try:
            import psutil

            return psutil.Process().memory_info().rss
        except ImportError:
            # Fallback: estimate from gc
            import sys

            return sum(sys.getsizeof(obj) for obj in gc.get_objects()[:1000])
        except Exception:
            return 0

    def _force_cleanup(self) -> None:
        """Force garbage collection and notify callbacks."""
        before = self._get_memory_usage()

        # Run registered cleanup callbacks
        for callback in self._cleanup_callbacks:
            try:
                callback()
            except Exception as e:
                logger.warning("Cleanup callback error: %s", e)

        # Force garbage collection
        gc.collect()

        after = self._get_memory_usage()
        freed = before - after
        self._cleanup_count += 1

        logger.info(
            "Cleanup #%d: freed %.1fMB (%.1fMB -> %.1fMB)",
            self._cleanup_count,
            freed / (1024 * 1024),
            before / (1024 * 1024),
            after / (1024 * 1024),
        )

    def get_stats(self) -> dict:
        """Get memory statistics."""
        current = self._get_memory_usage()
        return {
            "current_mb": current / (1024 * 1024),
            "peak_mb": self._peak_memory / (1024 * 1024),
            "threshold_mb": self._threshold / (1024 * 1024),
            "cleanup_count": self._cleanup_count,
            "running": self._running,
        }

    def force_gc(self) -> None:
        """Manually trigger garbage collection."""
        self._force_cleanup()


# Singleton accessor
_memory_manager: MemoryManager | None = None


def get_memory_manager() -> MemoryManager:
    """Get singleton MemoryManager instance."""
    global _memory_manager
    if _memory_manager is None:
        _memory_manager = MemoryManager()
    return _memory_manager


================================================================================
FILE PATH: core\engine\perf_profile.py
LINES: 203
================================================================================

"""
RetroAuto v2 - Performance Profiles

Resource presets for different machine capabilities.
Phase 3.2 Performance Optimization.
"""

from dataclasses import dataclass
from enum import Enum, auto
from typing import Any

from infra import get_logger

logger = get_logger("PerfProfile")


class ProfileLevel(Enum):
    """Performance profile levels."""

    LOW = auto()  # Low-spec machines (2-4GB RAM, older CPUs)
    MEDIUM = auto()  # Standard machines (8GB RAM)
    HIGH = auto()  # High-spec machines (16GB+ RAM, modern CPUs)
    ULTRA = auto()  # Maximum performance (GPU, multi-core)


@dataclass
class PerformanceProfile:
    """Performance settings for a specific profile level."""

    # Interrupt Scanner
    scan_interval_idle_ms: int
    scan_interval_active_ms: int
    scan_interval_fast_ms: int

    # Image Cache
    template_cache_size: int
    template_cache_ttl_seconds: int

    # OCR Cache
    ocr_cache_size: int
    ocr_cache_ttl_seconds: float

    # Memory Manager
    memory_threshold_mb: int
    memory_check_interval_seconds: int

    # Parallel Processing
    max_workers: int

    # Vision
    default_poll_ms: int
    adaptive_threshold: bool


# Predefined profiles
PROFILES: dict[ProfileLevel, PerformanceProfile] = {
    ProfileLevel.LOW: PerformanceProfile(
        scan_interval_idle_ms=1000,
        scan_interval_active_ms=500,
        scan_interval_fast_ms=200,
        template_cache_size=20,
        template_cache_ttl_seconds=600,
        ocr_cache_size=20,
        ocr_cache_ttl_seconds=3.0,
        memory_threshold_mb=150,
        memory_check_interval_seconds=120,
        max_workers=2,
        default_poll_ms=200,
        adaptive_threshold=True,
    ),
    ProfileLevel.MEDIUM: PerformanceProfile(
        scan_interval_idle_ms=500,
        scan_interval_active_ms=200,
        scan_interval_fast_ms=100,
        template_cache_size=50,
        template_cache_ttl_seconds=300,
        ocr_cache_size=50,
        ocr_cache_ttl_seconds=2.0,
        memory_threshold_mb=300,
        memory_check_interval_seconds=60,
        max_workers=4,
        default_poll_ms=100,
        adaptive_threshold=True,
    ),
    ProfileLevel.HIGH: PerformanceProfile(
        scan_interval_idle_ms=300,
        scan_interval_active_ms=100,
        scan_interval_fast_ms=50,
        template_cache_size=100,
        template_cache_ttl_seconds=180,
        ocr_cache_size=100,
        ocr_cache_ttl_seconds=1.0,
        memory_threshold_mb=500,
        memory_check_interval_seconds=30,
        max_workers=6,
        default_poll_ms=50,
        adaptive_threshold=True,
    ),
    ProfileLevel.ULTRA: PerformanceProfile(
        scan_interval_idle_ms=200,
        scan_interval_active_ms=50,
        scan_interval_fast_ms=25,
        template_cache_size=200,
        template_cache_ttl_seconds=120,
        ocr_cache_size=200,
        ocr_cache_ttl_seconds=0.5,
        memory_threshold_mb=1000,
        memory_check_interval_seconds=15,
        max_workers=8,
        default_poll_ms=25,
        adaptive_threshold=True,
    ),
}


class ProfileManager:
    """Manages performance profiles and auto-detection."""

    _instance: "ProfileManager | None" = None
    _lock = None

    def __new__(cls) -> "ProfileManager":
        if cls._instance is None:
            import threading
            cls._lock = threading.Lock()
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialized = False
        return cls._instance

    def __init__(self) -> None:
        if self._initialized:
            return

        self._current_level = ProfileLevel.MEDIUM
        self._current_profile = PROFILES[ProfileLevel.MEDIUM]
        self._initialized = True

    @property
    def profile(self) -> PerformanceProfile:
        """Get current performance profile."""
        return self._current_profile

    @property
    def level(self) -> ProfileLevel:
        """Get current profile level."""
        return self._current_level

    def set_level(self, level: ProfileLevel) -> None:
        """Set performance profile level."""
        self._current_level = level
        self._current_profile = PROFILES[level]
        logger.info("Performance profile set to: %s", level.name)

    def auto_detect(self) -> ProfileLevel:
        """Auto-detect appropriate profile based on system specs."""
        try:
            import psutil

            # Get system info
            ram_gb = psutil.virtual_memory().total / (1024**3)
            cpu_count = psutil.cpu_count(logical=False) or 2

            logger.info("System: %.1fGB RAM, %d CPU cores", ram_gb, cpu_count)

            # Determine profile
            if ram_gb < 4 or cpu_count < 2:
                level = ProfileLevel.LOW
            elif ram_gb < 8 or cpu_count < 4:
                level = ProfileLevel.MEDIUM
            elif ram_gb < 16 or cpu_count < 6:
                level = ProfileLevel.HIGH
            else:
                level = ProfileLevel.ULTRA

            self.set_level(level)
            return level

        except ImportError:
            logger.warning("psutil not available, using MEDIUM profile")
            return ProfileLevel.MEDIUM

    def get_setting(self, key: str) -> Any:
        """Get a specific setting from current profile."""
        return getattr(self._current_profile, key, None)


# Singleton accessor
_profile_manager: ProfileManager | None = None


def get_profile_manager() -> ProfileManager:
    """Get singleton ProfileManager instance."""
    global _profile_manager
    if _profile_manager is None:
        _profile_manager = ProfileManager()
    return _profile_manager


def get_profile() -> PerformanceProfile:
    """Get current performance profile."""
    return get_profile_manager().profile


================================================================================
FILE PATH: core\engine\runner.py
LINES: 1094
================================================================================

"""
RetroAuto v2 - Core Runner

Execute flows with Label/Goto support and action dispatch.
"""

import time
from collections.abc import Callable
from typing import Any

from core.engine.context import EngineState, ExecutionContext
from core.graph.walker import GraphWalker
from core.models import (
    Action,
    Click,
    ClickImage,
    ClickRandom,
    ClickUntil,
    Delay,
    DelayRandom,
    Drag,
    Flow,
    Goto,
    Hotkey,
    IfImage,
    IfNotImage,
    IfAllImages,
    IfAnyImage,
    IfPixel,
    IfText,
    Label,
    Loop,
    Notify,
    NotifyMethod,
    ReadText,
    RunFlow,
    Scroll,
    TypeText,
    WaitImage,
    WaitPixel,
    WhileImage,
)
from core.vision.hasher import calculate_phash, hamming_distance
from infra import get_logger
from vision import WaitResult
from vision.ocr import TextReader

logger = get_logger("Runner")


from core.watchdog import SystemWatchdog


class Runner:
    """
    Execute automation flows.

    Features:
    - Single-step and full-flow execution
    - Label/Goto flow control
    - IfImage conditional branching
    - Nested flow calls (RunFlow)
    - Stop/Pause support
    - System Watchdog monitoring
    """

    def __init__(
        self,
        ctx: ExecutionContext,
        on_step: Callable[[str, int, Action], None] | None = None,
        on_complete: Callable[[str, bool], None] | None = None,
        on_notify: Callable[[str, str], None] | None = None,
    ) -> None:
        """
        Initialize runner.

        Args:
            ctx: Execution context with all services
            on_step: Callback when step starts (flow, index, action)
            on_complete: Callback when flow completes (flow, success)
        """
        self._ctx = ctx
        self._on_step = on_step
        self._on_complete = on_complete
        self._on_notify = on_notify
        self._call_stack: list[tuple[str, int]] = []  # For nested RunFlow
        self._ocr = TextReader()
        self._watchdog = SystemWatchdog()

    def run_flow(self, flow_name: str, from_step: int = 0) -> bool:
        """
        Execute a flow.

        Args:
            flow_name: Name of flow to execute
            from_step: Start from this step index

        Returns:
            True if completed successfully, False if stopped/error
        """
        flow = self._ctx.script.get_flow(flow_name)
        if flow is None:
            logger.error("Flow not found: %s", flow_name)
            return False

        self._ctx.set_state(EngineState.RUNNING)
        logger.info("Starting flow: %s (from step %d)", flow_name, from_step)

        # üõ°Ô∏è Pre-flight validation
        validation_errors = self._validate_assets_before_run(flow)
        if validation_errors:
            for error in validation_errors:
                logger.error(f"‚ùå Pre-flight check failed: {error}")
            # Continue anyway but warn user
            logger.warning(f"‚ö†Ô∏è {len(validation_errors)} validation warnings, proceeding...")

        # Check OCR availability if needed
        if self._flow_needs_ocr(flow) and not self._ocr.is_available():
            logger.warning(
                "‚ö†Ô∏è OCR not available (Tesseract not found). ReadText/IfText actions may fail."
            )

        # Check if flow has a graph representation
        if flow.graph and flow.graph.nodes:
            logger.info("Executing flow using graph mode")
            return self._execute_graph(flow)

        # Legacy mode: execute as linear list
        logger.info("Executing flow using legacy list mode")
        labels = self._build_label_index(flow)
        return self._execute_list(flow, from_step, labels, flow_name)

    def _execute_graph(self, flow: Flow) -> bool:
        """Execute flow using graph walker."""
        try:
            walker = GraphWalker(flow.graph)

            # Create action executor callback that maintains context
            def execute_action(action: Action) -> Any:
                # Check stop/pause before each action
                if not self._ctx.wait_if_paused():
                    raise InterruptedError("Flow stopped by user")

                # Execute the action and return result
                return self._execute_action(action, flow, {})

            # Execute graph
            walker.execute_graph(execute_action)
            return True

        except InterruptedError:
            logger.info("Graph execution stopped by user")
            return False
        except Exception as e:
            logger.error(f"Graph execution failed: {e}")
            return False

    def _execute_list(
        self, flow: Flow, from_step: int, labels: dict[str, int], flow_name: str = "main"
    ) -> bool:
        """Execute flow using traditional linear list walker (backward compat)."""
        # Build label index for fast Goto
        labels = self._build_label_index(flow)

        pc = from_step  # Program counter
        success = True

        try:
            while pc < len(flow.actions):
                # 1. System Watchdog Check (only if run_options available)
                run_options = getattr(self._ctx, "run_options", {})
                if run_options:
                    watchdog_cfg = run_options.get("watchdog", {})
                    is_healthy, msg = self._watchdog.check_health(watchdog_cfg)
                    if not is_healthy:
                        logger.error(f"üõë Watchdog Stop: {msg}")
                        # Handle as error to stop script
                        raise RuntimeError(f"System Watchdog failed: {msg}")

                # 2. Check stop/pause
                if not self._ctx.wait_if_paused():
                    logger.info("Flow stopped by user")
                    success = False
                    break

                action = flow.actions[pc]
                self._ctx.update_step(flow_name, pc)

                # Callback
                if self._on_step:
                    self._on_step(flow_name, pc, action)

                # Execute action
                start_time = time.perf_counter()
                result = self._execute_action(action, flow, labels)
                elapsed = int((time.perf_counter() - start_time) * 1000)

                logger.debug("Step %d completed in %dms", pc, elapsed)

                # Handle Goto
                if isinstance(result, int):
                    pc = result
                elif result is False:
                    success = False
                    break
                else:
                    pc += 1

        except Exception as e:
            logger.exception("Error in flow %s step %d: %s", flow_name, pc, e)
            success = False

        # Callback
        if self._on_complete:
            self._on_complete(flow_name, success)

        if success:
            self._ctx.set_state(EngineState.IDLE)
        return success

    def run_step(self, flow_name: str, step_index: int) -> bool:
        """Execute single step."""
        flow = self._ctx.script.get_flow(flow_name)
        if flow is None or step_index >= len(flow.actions):
            return False

        action = flow.actions[step_index]
        labels = self._build_label_index(flow)

        try:
            result = self._execute_action(action, flow, labels)
            return result is not False
        except Exception as e:
            logger.exception("Error executing step: %s", e)
            return False

    def _build_label_index(self, flow: Flow) -> dict[str, int]:
        """Build index of label names to step indices."""
        labels = {}
        for i, action in enumerate(flow.actions):
            if isinstance(action, Label):
                labels[action.name] = i
        return labels

    def _validate_assets_before_run(self, flow: Flow) -> list[str]:
        """
        Validate all referenced assets exist before running.

        Returns:
            List of error messages (empty if all valid)
        """
        # Skip validation if context doesn't support get_asset (e.g., tests)
        if not hasattr(self._ctx, "get_asset"):
            return []

        errors = []
        checked = set()

        for action in flow.actions:
            # Check asset_id if action has one
            if hasattr(action, "asset_id") and action.asset_id:
                asset_id = action.asset_id
                if asset_id in checked:
                    continue
                checked.add(asset_id)

                # Try to get asset from context
                try:
                    asset = self._ctx.get_asset(asset_id)
                    if asset is None or getattr(asset, "image", None) is None:
                        errors.append(f"Asset '{asset_id}' not loaded or image is None")
                except Exception as e:
                    errors.append(f"Asset '{asset_id}' error: {e}")

        return errors

    def _flow_needs_ocr(self, flow: Flow) -> bool:
        """Check if flow uses any OCR actions."""
        return any(isinstance(action, (ReadText, IfText)) for action in flow.actions)

    def _execute_action(
        self,
        action: Action,
        flow: Flow,
        labels: dict[str, int],
    ) -> bool | int | None:
        """
        Execute single action.

        Returns:
            - None: Continue to next step
            - int: Jump to this step index (Goto)
            - False: Stop execution
        """
        if isinstance(action, (Click, ClickImage, ClickRandom, Drag)):
            hash_before = self._capture_hash()

            # Execute
            result = self._dispatch_action(action, flow, labels)

            # Flight Recorder: Check for change
            if hash_before is not None:
                # Wait for reaction (small delay)
                time.sleep(0.1)
                hash_after = self._capture_hash()
                if hash_after is not None:
                    dist = hamming_distance(hash_before, hash_after)
                    if dist <= 1:  # Allow exceedingly minor noise (0 or 1 bit)
                        logger.warning(
                            f"‚úàÔ∏è FlightRecorder: Action '{type(action).__name__}' resulted in NO VISUAL CHANGE (dist={dist}). Possible failure."
                        )
                    else:
                        logger.debug(f"FlightRecorder: Visual change confirmed (dist={dist})")

            return result
        else:
            return self._dispatch_action(action, flow, labels)

    def _dispatch_action(
        self, action: Action, flow: Flow, labels: dict[str, int]
    ) -> bool | int | None:
        """
        Internal dispatch with error handling wrapper.

        All action execution is wrapped for:
        - Execution time logging
        - Graceful error recovery
        - Detailed error context
        """
        action_type = type(action).__name__
        start_time = time.perf_counter()

        try:
            result = self._safe_execute(action, flow, labels)
            elapsed_ms = int((time.perf_counter() - start_time) * 1000)
            logger.info(f"‚úÖ {action_type} completed in {elapsed_ms}ms")
            return result

        except TimeoutError as e:
            elapsed_ms = int((time.perf_counter() - start_time) * 1000)
            logger.error(f"‚è±Ô∏è {action_type} TIMEOUT after {elapsed_ms}ms: {e}")
            return None  # Continue to next action

        except FileNotFoundError as e:
            logger.error(f"‚ùå {action_type} Asset not found: {e}")
            return None  # Continue to next action

        except Exception as e:
            elapsed_ms = int((time.perf_counter() - start_time) * 1000)
            logger.error(f"‚ùå {action_type} FAILED after {elapsed_ms}ms: {e}")
            # Log full traceback at debug level
            logger.debug(f"Traceback for {action_type}:", exc_info=True)
            return None  # Continue to next action (don't crash flow)

    def _safe_execute(
        self, action: Action, flow: Flow, labels: dict[str, int]
    ) -> bool | int | None:
        """Execute action with specific handlers."""
        if isinstance(action, WaitImage):
            return self._exec_wait_image(action)

        elif isinstance(action, Click):
            return self._exec_click(action)

        elif isinstance(action, ClickRandom):
            return self._exec_click_random(action)

        elif isinstance(action, IfImage):
            return self._exec_if_image(action, flow, labels)

        elif isinstance(action, Hotkey):
            return self._exec_hotkey(action)

        elif isinstance(action, TypeText):
            return self._exec_type_text(action)

        elif isinstance(action, Label):
            # Labels are no-ops at runtime
            return None

        elif isinstance(action, Goto):
            return self._exec_goto(action, labels)

        elif isinstance(action, RunFlow):
            return self._exec_run_flow(action)

        elif isinstance(action, Delay):
            return self._exec_delay(action)

        elif isinstance(action, ReadText):
            return self._exec_read_text(action)

        elif isinstance(action, IfText):
            return self._exec_if_text(action, flow, labels)

        elif isinstance(action, ClickImage):
            return self._exec_click_image(action)

        elif isinstance(action, Drag):
            return self._exec_drag(action)

        elif isinstance(action, Notify):
            return self._exec_notify(action)

        elif isinstance(action, Scroll):
            return self._exec_scroll(action)

        elif isinstance(action, DelayRandom):
            return self._exec_delay_random(action)

        elif isinstance(action, Loop):
            return self._exec_loop(action, flow, labels)

        elif isinstance(action, WhileImage):
            return self._exec_while_image(action, flow, labels)

        elif isinstance(action, WaitPixel):
            return self._exec_wait_pixel(action)

        elif isinstance(action, IfPixel):
            return self._exec_if_pixel(action, flow, labels)

        elif isinstance(action, ClickUntil):
            return self._exec_click_until(action)

        elif isinstance(action, IfNotImage):
            return self._exec_if_not_image(action, flow, labels)

        elif isinstance(action, IfAllImages):
            return self._exec_if_all_images(action, flow, labels)

        elif isinstance(action, IfAnyImage):
            return self._exec_if_any_image(action, flow, labels)

        else:
            logger.warning("Unknown action type: %s", type(action).__name__)
            return None

    def _capture_hash(self) -> int | None:
        """Capture screen and calculate hash for Flight Recorder."""
        try:
            # We need to grab screen.
            # self._ctx.capture (ScreenCapture) usually has grab() returning numpy/PIL
            img = self._ctx.capture.grab()
            return calculate_phash(img)
        except Exception as e:
            logger.warning(f"FlightRecorder capture failed: {e}")
            return None

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Action Executors
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    def _resolve_variables(self, text: str) -> str:
        """Replace $var with values from context."""
        if not text:
            return ""
        result = text
        for name, value in self._ctx.variables.items():
            if name in result:
                result = result.replace(name, str(value))
        return result

    def _exec_notify(self, action: Notify) -> None:
        """Execute Notify action."""
        msg = self._resolve_variables(action.message)
        title = self._resolve_variables(action.title)

        logger.info(f"Notify [{action.method}]: {title} - {msg}")

        if action.method == NotifyMethod.POPUP:
            if self._on_notify:
                self._on_notify(title, msg)

        elif action.method == NotifyMethod.TELEGRAM or action.method == NotifyMethod.DISCORD:
            target = self._resolve_variables(action.target)
            if not target:
                logger.warning("Notification target not specified")
                return

            try:
                import json
                import urllib.request

                if action.method == NotifyMethod.DISCORD:
                    data = json.dumps({"content": f"**{title}**\n{msg}"}).encode("utf-8")
                    req = urllib.request.Request(
                        target,
                        data=data,
                        headers={"Content-Type": "application/json", "User-Agent": "Mozilla/5.0"},
                    )
                    urllib.request.urlopen(req)

                elif action.method == NotifyMethod.TELEGRAM:
                    if "|" in target:
                        token, chat_id = target.split("|", 1)
                        import urllib.parse

                        encoded_msg = urllib.parse.quote(f"{title}\n{msg}")
                        url = f"https://api.telegram.org/bot{token}/sendMessage?chat_id={chat_id}&text={encoded_msg}"
                        urllib.request.urlopen(url)
                    else:
                        logger.warning("Telegram target format: TOKEN|CHAT_ID")

            except Exception as e:
                logger.error(f"Notification failed: {e}")

    def _exec_read_text(self, action: ReadText) -> None:
        """Execute ReadText action."""
        try:
            # Capture screen (returns PIL Image usually, depends on Capture impl)
            # ctx.capture.grab() -> Image
            screenshot = self._ctx.capture.grab()

            text = self._ocr.read_from_image(
                screenshot,
                roi=action.roi,
                allowlist=action.allowlist,
                scale=action.scale,
                invert=action.invert,
                binarize=action.binarize,
            )

            # Store in variable
            self._ctx.variables[action.variable_name] = text
            logger.info("ReadText: %s = '%s' (ROI: %s)", action.variable_name, text, action.roi)

        except Exception as e:
            logger.error("ReadText failed: %s", e)

    def _exec_if_text(self, action: IfText, flow: Flow, labels: dict[str, int]) -> None:
        """Execute IfText conditional."""
        # Get variable value
        var_val = str(self._ctx.variables.get(action.variable_name, ""))
        target = action.value
        op = action.operator
        result = False

        try:
            if op == "contains":
                result = target in var_val
            elif op == "equals":
                result = var_val == target
            elif op == "starts_with":
                result = var_val.startswith(target)
            elif op == "ends_with":
                result = var_val.endswith(target)
            elif op == "numeric_gt" or op == "numeric_lt":
                # Clean up string for numeric conversion (remove non-digits if needed, or just try)
                # Simple float conversion
                f_val = float(var_val.replace(",", "").strip())
                f_target = float(target)
                result = f_val > f_target if op == "numeric_gt" else f_val < f_target
        except ValueError:
            logger.warning("IfText: Numeric conversion failed for '%s'", var_val)
            result = False

        logger.info("IfText: '%s' %s '%s' -> %s", var_val, op, target, result)

        branch = action.then_actions if result else action.else_actions

        # Execute branch
        for sub_action in branch:
            # Check stop/pause between sub-actions
            if not self._ctx.wait_if_paused():
                return None

            # Recursive execution? No, flat execution context needed for goto/labels usually
            # But action models support nesting. We can execute purely.
            # Note: Goto inside IfText won't work well unless we flatten the flow.
            # For now, we just execute simple actions.
            self._execute_action(sub_action, flow, labels)

    def _exec_click_image(self, action: ClickImage) -> None:
        """Execute ClickImage with wait."""
        result = self._ctx.wait_for_image(
            action.asset_id,
            timeout_ms=action.timeout_ms,
            appear=True,
            smart_wait=action.smart_wait,
        )
        if not result or not result.found:
            raise RuntimeError(f"Image not found: {action.asset_id}")

        # Click with offset
        x = result.location[0] + action.offset_x
        y = result.location[1] + action.offset_y

        logger.info(
            f"ClickImage '{action.asset_id}' at ({x},{y}) button={action.button} clicks={action.clicks}"
        )

        # Perform clicks
        for i in range(action.clicks):
            if i > 0:
                # Wait interval between clicks
                import time

                time.sleep(action.interval_ms / 1000.0)

            self._ctx.mouse.click(x, y, button=action.button)

    def _exec_wait_image(self, action: WaitImage) -> bool | None:
        """Execute WaitImage action."""
        logger.info(
            "WaitImage: %s (appear=%s, timeout=%dms)",
            action.asset_id,
            action.appear,
            action.timeout_ms,
        )

        if action.appear:
            outcome = self._ctx.waiter.wait_appear(
                action.asset_id,
                timeout_ms=action.timeout_ms,
                poll_ms=action.poll_ms,
                roi_override=action.roi_override,
                smart_wait=action.smart_wait,
            )
        else:
            outcome = self._ctx.waiter.wait_vanish(
                action.asset_id,
                timeout_ms=action.timeout_ms,
                poll_ms=action.poll_ms,
                roi_override=action.roi_override,
                smart_wait=action.smart_wait,
            )

        if outcome.result == WaitResult.SUCCESS:
            if outcome.match:
                self._ctx.last_match = outcome.match
            return None
        elif outcome.result == WaitResult.TIMEOUT:
            logger.warning("WaitImage timeout: %s", action.asset_id)
            return False
        else:
            return False  # Cancelled

    def _exec_click(self, action: Click) -> None:
        """Execute click action."""
        if action.x is not None and action.y is not None:
            x, y = action.x, action.y
        else:
            # Use last match
            x, y = self._ctx.last_match_center()
            if x is None or y is None:
                logger.warning("Click: No coordinates and no match")
                return None

        logger.info(f"Clicking at ({x}, {y}) button={action.button} clicks={action.clicks}")

        # Perform clicks
        for i in range(action.clicks):
            if i > 0:
                # Wait interval between clicks
                import time

                time.sleep(action.interval_ms / 1000.0)

            self._ctx.mouse.click(x, y, button=action.button)
        return None

    def _exec_if_image(
        self,
        action: IfImage,
        flow: Flow,
        labels: dict[str, int],
    ) -> bool | int | None:
        """Execute IfImage conditional."""
        match = self._ctx.matcher.find(action.asset_id, action.roi_override)

        if match:
            logger.info("IfImage: %s FOUND (conf=%.2f)", action.asset_id, match.confidence)
            self._ctx.last_match = match
            branch = action.then_actions
        else:
            logger.info("IfImage: %s NOT FOUND", action.asset_id)
            branch = action.else_actions

        # Execute branch actions inline
        for sub_action in branch:
            if not self._ctx.wait_if_paused():
                return False
            result = self._execute_action(sub_action, flow, labels)
            if result is False:
                return False
            if isinstance(result, int):
                return result  # Propagate Goto

        return None

    def _exec_if_not_image(
        self,
        action: IfNotImage,
        flow: Flow,
        labels: dict[str, int],
    ) -> bool | int | None:
        """Execute IfNotImage conditional (runs when image NOT found)."""
        match = self._ctx.matcher.find(action.asset_id, action.roi_override)

        if match:
            logger.info("IfNotImage: %s FOUND - skipping actions", action.asset_id)
            return None  # Image found, skip then_actions

        logger.info("IfNotImage: %s NOT FOUND - executing actions", action.asset_id)

        # Execute then_actions since image is NOT found
        for sub_action in action.then_actions:
            if not self._ctx.wait_if_paused():
                return False
            result = self._execute_action(sub_action, flow, labels)
            if result is False:
                return False
            if isinstance(result, int):
                return result  # Propagate Goto

        return None

    def _exec_if_all_images(
        self,
        action: IfAllImages,
        flow: Flow,
        labels: dict[str, int],
    ) -> bool | int | None:
        """Execute IfAllImages - AND logic, all images must be found."""
        all_found = True
        found_ids = []

        for asset_id in action.asset_ids:
            match = self._ctx.matcher.find(asset_id)
            if match:
                found_ids.append(asset_id)
                self._ctx.last_match = match
            else:
                all_found = False
                logger.info("IfAllImages: %s NOT FOUND - AND failed", asset_id)
                break

        if all_found:
            logger.info("IfAllImages: ALL found (%s) - executing then_actions", found_ids)
            branch = action.then_actions
        else:
            logger.info("IfAllImages: Not all found - executing else_actions")
            branch = action.else_actions

        for sub_action in branch:
            if not self._ctx.wait_if_paused():
                return False
            result = self._execute_action(sub_action, flow, labels)
            if result is False:
                return False
            if isinstance(result, int):
                return result

        return None

    def _exec_if_any_image(
        self,
        action: IfAnyImage,
        flow: Flow,
        labels: dict[str, int],
    ) -> bool | int | None:
        """Execute IfAnyImage - OR logic, at least one image must be found."""
        any_found = False
        found_id = None

        for asset_id in action.asset_ids:
            match = self._ctx.matcher.find(asset_id)
            if match:
                any_found = True
                found_id = asset_id
                self._ctx.last_match = match
                logger.info("IfAnyImage: %s FOUND - OR satisfied", asset_id)
                break

        if any_found:
            logger.info("IfAnyImage: Found '%s' - executing then_actions", found_id)
            branch = action.then_actions
        else:
            logger.info("IfAnyImage: NONE found - executing else_actions")
            branch = action.else_actions

        for sub_action in branch:
            if not self._ctx.wait_if_paused():
                return False
            result = self._execute_action(sub_action, flow, labels)
            if result is False:
                return False
            if isinstance(result, int):
                return result

        return None

    def _exec_hotkey(self, action: Hotkey) -> None:
        """Execute Hotkey action."""
        logger.info("Hotkey: %s", "+".join(action.keys))
        self._ctx.keyboard.hotkey(action.keys)
        return None

    def _exec_type_text(self, action: TypeText) -> None:
        """Execute TypeText action."""
        logger.info(
            "TypeText: '%s...' (paste=%s)",
            action.text[:20] if len(action.text) > 20 else action.text,
            action.paste_mode,
        )
        self._ctx.keyboard.type_text(action.text, action.paste_mode, action.enter)
        return None

    def _exec_goto(self, action: Goto, labels: dict[str, int]) -> int | None:
        """Execute Goto action."""
        if action.label not in labels:
            logger.error("Goto: Label not found: %s", action.label)
            return None

        target = labels[action.label]
        logger.info("Goto: %s (step %d)", action.label, target)
        return target

    def _exec_run_flow(self, action: RunFlow) -> bool | None:
        """Execute RunFlow action (nested flow call)."""
        logger.info("RunFlow: %s", action.flow_name)

        # Check recursion limit
        if len(self._call_stack) > 10:
            logger.error("RunFlow: Maximum recursion depth exceeded")
            return False

        # Push current position
        self._call_stack.append((self._ctx.current_flow, self._ctx.current_step))

        # Execute nested flow
        success = self.run_flow(action.flow_name)

        # Pop call stack
        if self._call_stack:
            self._call_stack.pop()

        return None if success else False

    def _exec_delay(self, action: Delay) -> None:
        """Execute Delay action."""
        logger.info("Delay: %dms", action.ms)

        # Sleep in small chunks to allow stop/pause
        remaining = action.ms
        chunk = 100  # 100ms chunks

        while remaining > 0:
            if not self._ctx.wait_if_paused():
                return None
            sleep_time = min(chunk, remaining)
            time.sleep(sleep_time / 1000.0)
            remaining -= sleep_time

        return None

    def _exec_click_random(self, action: ClickRandom) -> None:
        """Execute ClickRandom action."""
        import random

        # Calculate random point within ROI
        # Use normal distribution (gaussian) for more human-like "center-bias"
        # but clamp to ROI bounds

        # Center of ROI
        cx = action.roi.x + action.roi.w / 2
        cy = action.roi.y + action.roi.h / 2

        # Standard deviation = 1/6 of width/height (99% points within ROI)
        sigma_x = action.roi.w / 6
        sigma_y = action.roi.h / 6

        # Box-Muller transform or simple gauss
        x = int(random.gauss(cx, sigma_x))
        y = int(random.gauss(cy, sigma_y))

        # Clamp to bounds
        x = max(action.roi.x, min(action.roi.x + action.roi.w, x))
        y = max(action.roi.y, min(action.roi.y + action.roi.h, y))

        logger.info(
            "ClickRandom: (%d, %d) in ROI(x=%d, y=%d, w=%d, h=%d)",
            x,
            y,
            action.roi.x,
            action.roi.y,
            action.roi.w,
            action.roi.h,
        )

        self._ctx.mouse.click(
            x=x,
            y=y,
            button=action.button,
            clicks=action.clicks,
            interval=action.interval_ms / 1000.0,
        )
        return None

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # NEW EXECUTORS (Added to fix missing actions from user guide)
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def _exec_drag(self, action: Drag) -> None:
        """Execute Drag action."""
        logger.info(
            "Drag: (%d, %d) -> (%d, %d) over %dms",
            action.from_x, action.from_y,
            action.to_x, action.to_y,
            action.duration_ms,
        )
        self._ctx.mouse.drag(
            from_x=action.from_x,
            from_y=action.from_y,
            to_x=action.to_x,
            to_y=action.to_y,
            duration=action.duration_ms / 1000.0,
            button=action.button,
        )
        return None

    def _exec_scroll(self, action: Scroll) -> None:
        """Execute Scroll action."""
        x = action.x if action.x is not None else self._ctx.mouse.position()[0]
        y = action.y if action.y is not None else self._ctx.mouse.position()[1]
        logger.info("Scroll: amount=%d at (%d, %d)", action.amount, x, y)
        self._ctx.mouse.scroll(x=x, y=y, amount=action.amount)
        return None

    def _exec_delay_random(self, action: DelayRandom) -> None:
        """Execute DelayRandom action."""
        import random
        delay_ms = random.randint(action.min_ms, action.max_ms)
        logger.info("DelayRandom: %dms (range %d-%d)", delay_ms, action.min_ms, action.max_ms)

        # Sleep in chunks for stop/pause support
        remaining = delay_ms
        chunk = 100
        while remaining > 0:
            if not self._ctx.wait_if_paused():
                return None
            sleep_time = min(chunk, remaining)
            time.sleep(sleep_time / 1000.0)
            remaining -= sleep_time
        return None

    def _exec_loop(self, action: Loop, flow: Flow, labels: dict[str, int]) -> None:
        """Execute Loop action with nested actions."""
        iterations = action.count if action.count is not None else 100000  # Safety limit
        logger.info("Loop: %s iterations", "‚àû" if action.count is None else action.count)

        for i in range(iterations):
            if not self._ctx.wait_if_paused():
                return False
            logger.debug("Loop iteration %d/%s", i + 1, action.count or "‚àû")
            for nested_action in action.actions:
                result = self._dispatch_action(nested_action, flow, labels)
                if result is False:
                    return False
        return None

    def _exec_while_image(self, action: WhileImage, flow: Flow, labels: dict[str, int]) -> None:
        """Execute WhileImage action - repeat while image present/absent."""
        logger.info("WhileImage: %s (while_present=%s)", action.asset_id, action.while_present)

        for i in range(action.max_iterations):
            if not self._ctx.wait_if_paused():
                return False

            # Check if image is present
            found = self._ctx.matcher.find(action.asset_id, roi_override=action.roi_override)
            is_present = found.found if hasattr(found, 'found') else bool(found)

            # Continue loop based on condition
            should_continue = is_present if action.while_present else not is_present
            if not should_continue:
                logger.info("WhileImage: condition no longer met, exiting loop")
                break

            # Execute nested actions
            for nested_action in action.actions:
                result = self._dispatch_action(nested_action, flow, labels)
                if result is False:
                    return False

        return None

    def _exec_wait_pixel(self, action: WaitPixel) -> bool | None:
        """Execute WaitPixel action - wait for pixel color."""
        logger.info(
            "WaitPixel: (%d, %d) color=RGB(%d,%d,%d) appear=%s",
            action.x, action.y,
            action.color.r, action.color.g, action.color.b,
            action.appear,
        )

        start_time = time.time()
        timeout_sec = action.timeout_ms / 1000.0

        while True:
            if not self._ctx.wait_if_paused():
                return False

            # Get pixel color at position
            try:
                img = self._ctx.capture.grab()
                # Access pixel at (x, y) - assumed PIL Image or numpy array
                if hasattr(img, 'getpixel'):
                    r, g, b = img.getpixel((action.x, action.y))[:3]
                else:
                    r, g, b = img[action.y, action.x][:3]

                color_matches = action.color.matches(r, g, b)
                if (action.appear and color_matches) or (not action.appear and not color_matches):
                    logger.info("WaitPixel: condition met")
                    return None
            except Exception as e:
                logger.warning("WaitPixel pixel check failed: %s", e)

            # Check timeout
            if time.time() - start_time > timeout_sec:
                logger.warning("WaitPixel: timeout after %dms", action.timeout_ms)
                return None

            time.sleep(action.poll_ms / 1000.0)

    def _exec_if_pixel(self, action: IfPixel, flow: Flow, labels: dict[str, int]) -> None:
        """Execute IfPixel conditional based on pixel color."""
        # Get pixel color
        try:
            img = self._ctx.capture.grab()
            if hasattr(img, 'getpixel'):
                r, g, b = img.getpixel((action.x, action.y))[:3]
            else:
                r, g, b = img[action.y, action.x][:3]

            color_matches = action.color.matches(r, g, b)
        except Exception as e:
            logger.warning("IfPixel pixel check failed: %s", e)
            color_matches = False

        # Execute appropriate branch
        actions_to_run = action.then_actions if color_matches else action.else_actions
        logger.info("IfPixel: (%d,%d) matched=%s, running %d actions",
                    action.x, action.y, color_matches, len(actions_to_run))

        for nested_action in actions_to_run:
            result = self._dispatch_action(nested_action, flow, labels)
            if result is False:
                return False
        return None

    def _exec_click_until(self, action: ClickUntil) -> bool | None:
        """Execute ClickUntil - click repeatedly until condition met."""
        logger.info(
            "ClickUntil: click=%s until=%s (appear=%s)",
            action.click_asset_id, action.until_asset_id, action.until_appear,
        )

        start_time = time.time()
        timeout_sec = action.timeout_ms / 1000.0
        click_count = 0

        while click_count < action.max_clicks:
            if not self._ctx.wait_if_paused():
                return False

            # Check if target condition is met
            found = self._ctx.matcher.find(action.until_asset_id)
            is_present = found.found if hasattr(found, 'found') else bool(found)
            condition_met = is_present if action.until_appear else not is_present

            if condition_met:
                logger.info("ClickUntil: condition met after %d clicks", click_count)
                return None

            # Find and click the click_asset
            click_result = self._ctx.matcher.find(action.click_asset_id)
            if click_result and (click_result.found if hasattr(click_result, 'found') else bool(click_result)):
                cx, cy = click_result.center if hasattr(click_result, 'center') else (click_result.x, click_result.y)
                self._ctx.mouse.click(x=cx, y=cy, button=action.button)
                click_count += 1
                logger.debug("ClickUntil: clicked %s (%d/%d)", action.click_asset_id, click_count, action.max_clicks)

            # Check timeout
            if time.time() - start_time > timeout_sec:
                logger.warning("ClickUntil: timeout after %dms, %d clicks", action.timeout_ms, click_count)
                return None

            time.sleep(action.click_interval_ms / 1000.0)

        logger.warning("ClickUntil: max clicks reached (%d)", action.max_clicks)
        return None


================================================================================
FILE PATH: core\engine\scope.py
LINES: 269
================================================================================

"""
RetroAuto v2 - Scope Manager

Variable scoping and lookup for RetroScript execution.
Part of RetroScript Phase 9 - Script Execution Engine.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any


@dataclass
class Scope:
    """A single scope level."""

    name: str  # Scope name (e.g., "global", "flow:main")
    variables: dict[str, Any] = field(default_factory=dict)
    parent: Scope | None = None
    is_flow: bool = False  # True if this is a flow scope

    def get(self, name: str) -> tuple[Any, bool]:
        """Get variable value.

        Returns:
            Tuple of (value, found)
        """
        if name in self.variables:
            return self.variables[name], True
        if self.parent:
            return self.parent.get(name)
        return None, False

    def set(self, name: str, value: Any) -> None:
        """Set variable in this scope."""
        self.variables[name] = value

    def update(self, name: str, value: Any) -> bool:
        """Update existing variable, searching up the scope chain.

        Returns:
            True if variable was found and updated
        """
        if name in self.variables:
            self.variables[name] = value
            return True
        if self.parent:
            return self.parent.update(name, value)
        return False

    def has(self, name: str) -> bool:
        """Check if variable exists in scope chain."""
        if name in self.variables:
            return True
        if self.parent:
            return self.parent.has(name)
        return False


class ScopeManager:
    """Manages variable scopes for script execution.

    Usage:
        scope = ScopeManager()
        scope.define("x", 10)
        scope.push("flow:main")
        scope.define("local_var", 20)
        print(scope.get("x"))  # 10 (from global)
        scope.pop()
    """

    def __init__(self) -> None:
        self._global = Scope(name="global")
        self._stack: list[Scope] = [self._global]

    @property
    def current(self) -> Scope:
        """Get current scope."""
        return self._stack[-1]

    @property
    def global_scope(self) -> Scope:
        """Get global scope."""
        return self._global

    def push(self, name: str, is_flow: bool = False) -> Scope:
        """Push a new scope onto the stack.

        Args:
            name: Scope name
            is_flow: Whether this is a flow scope

        Returns:
            The new scope
        """
        new_scope = Scope(
            name=name,
            parent=self.current,
            is_flow=is_flow,
        )
        self._stack.append(new_scope)
        return new_scope

    def pop(self) -> Scope | None:
        """Pop the current scope.

        Returns:
            The popped scope, or None if at global
        """
        if len(self._stack) > 1:
            return self._stack.pop()
        return None

    def define(self, name: str, value: Any) -> None:
        """Define a new variable in current scope."""
        self.current.set(name, value)

    def assign(self, name: str, value: Any) -> bool:
        """Assign to existing variable, or create in current scope.

        Returns:
            True if existing variable was updated
        """
        # Try to update existing
        if self.current.update(name, value):
            return True
        # Create new in current scope
        self.current.set(name, value)
        return False

    def get(self, name: str) -> Any:
        """Get variable value.

        Raises:
            NameError: If variable not found
        """
        value, found = self.current.get(name)
        if not found:
            raise NameError(f"Undefined variable: {name}")
        return value

    def get_or_default(self, name: str, default: Any = None) -> Any:
        """Get variable value or default."""
        value, found = self.current.get(name)
        return value if found else default

    def has(self, name: str) -> bool:
        """Check if variable exists."""
        return self.current.has(name)

    def set_global(self, name: str, value: Any) -> None:
        """Set variable in global scope."""
        self._global.set(name, value)

    def get_global(self, name: str) -> Any:
        """Get variable from global scope."""
        value, found = self._global.get(name)
        if not found:
            raise NameError(f"Undefined global: {name}")
        return value

    def depth(self) -> int:
        """Get current scope depth."""
        return len(self._stack)

    def get_all_locals(self) -> dict[str, Any]:
        """Get all local variables in current scope."""
        return self.current.variables.copy()

    def get_all_globals(self) -> dict[str, Any]:
        """Get all global variables."""
        return self._global.variables.copy()

    def clear_locals(self) -> None:
        """Clear current scope variables."""
        self.current.variables.clear()

    def reset(self) -> None:
        """Reset to initial state."""
        self._global = Scope(name="global")
        self._stack = [self._global]


from core.security.policy import SecurityPolicy  # noqa: E402


class ExecutionContext:
    """Execution context combining scope and control state.

    Provides:
    - Variable scope management
    - Control flow flags (break, continue, return)
    - Flow call stack
    - Security policy (Phase 15)
    """

    def __init__(self) -> None:
        self.scope = ScopeManager()
        self.policy = SecurityPolicy.unsafe()  # Default to unsafe for now
        self.call_depth: int = 0  # Recursion Guard
        self._return_value: Any = None
        self._should_return = False
        self._should_break = False
        self._should_continue = False
        self._call_stack: list[str] = []

    def enter_flow(self, name: str) -> None:
        """Enter a new flow context."""
        self.scope.push(f"flow:{name}", is_flow=True)
        self._call_stack.append(name)

    def exit_flow(self) -> None:
        """Exit current flow context."""
        self.scope.pop()
        if self._call_stack:
            self._call_stack.pop()
        self._should_return = False

    def set_return(self, value: Any = None) -> None:
        """Set return value and flag."""
        self._return_value = value
        self._should_return = True

    def get_return(self) -> Any:
        """Get and clear return value."""
        value = self._return_value
        self._return_value = None
        return value

    def should_return(self) -> bool:
        """Check if should return from current flow."""
        return self._should_return

    def set_break(self) -> None:
        """Set break flag for loop."""
        self._should_break = True

    def clear_break(self) -> bool:
        """Clear and return break flag."""
        was_break = self._should_break
        self._should_break = False
        return was_break

    def should_break(self) -> bool:
        """Check if should break from loop."""
        return self._should_break

    def set_continue(self) -> None:
        """Set continue flag for loop."""
        self._should_continue = True

    def clear_continue(self) -> bool:
        """Clear and return continue flag."""
        was_continue = self._should_continue
        self._should_continue = False
        return was_continue

    def should_continue(self) -> bool:
        """Check if should continue loop."""
        return self._should_continue

    def get_call_stack(self) -> list[str]:
        """Get current call stack."""
        return self._call_stack.copy()

    def current_flow(self) -> str | None:
        """Get current flow name."""
        return self._call_stack[-1] if self._call_stack else None


================================================================================
FILE PATH: core\game\anti_detect.py
LINES: 412
================================================================================

"""
RetroAuto v2 - Anti-Detection

Human-like behavior simulation to avoid detection.
Part of RetroScript Phase 20 - Game-Specific Features.
"""

from __future__ import annotations

import random
import time
from collections.abc import Callable
from dataclasses import dataclass
from typing import Any

# Try to import pyautogui
try:
    import pyautogui

    HAS_PYAUTOGUI = True
except ImportError:
    HAS_PYAUTOGUI = False
    pyautogui = None


@dataclass
class BehaviorProfile:
    """Profile defining human-like behavior patterns."""

    name: str = "default"

    # Timing
    min_delay: float = 0.05  # Minimum delay between actions
    max_delay: float = 0.3  # Maximum delay
    typing_min: float = 0.03  # Minimum typing interval
    typing_max: float = 0.15  # Maximum typing interval

    # Mouse behavior
    mouse_speed_min: float = 0.1  # Minimum mouse move duration
    mouse_speed_max: float = 0.4  # Maximum mouse move duration
    click_hold_min: float = 0.05  # Minimum click hold time
    click_hold_max: float = 0.15  # Maximum click hold time

    # Randomness
    position_variance: int = 3  # Pixel variance for click position
    occasional_pause_chance: float = 0.02  # Chance of random pause
    occasional_pause_min: float = 0.5  # Min pause duration
    occasional_pause_max: float = 2.0  # Max pause duration

    # Mistakes
    typo_chance: float = 0.0  # Chance of making typo (0 = disabled)
    misclick_chance: float = 0.0  # Chance of misclick (0 = disabled)


# Preset profiles
PROFILES = {
    "fast": BehaviorProfile(
        name="fast",
        min_delay=0.02,
        max_delay=0.1,
        mouse_speed_min=0.05,
        mouse_speed_max=0.15,
    ),
    "normal": BehaviorProfile(
        name="normal",
        min_delay=0.05,
        max_delay=0.3,
        mouse_speed_min=0.1,
        mouse_speed_max=0.4,
    ),
    "careful": BehaviorProfile(
        name="careful",
        min_delay=0.1,
        max_delay=0.5,
        mouse_speed_min=0.2,
        mouse_speed_max=0.6,
        occasional_pause_chance=0.05,
    ),
    "human": BehaviorProfile(
        name="human",
        min_delay=0.08,
        max_delay=0.4,
        typing_min=0.05,
        typing_max=0.2,
        mouse_speed_min=0.15,
        mouse_speed_max=0.5,
        position_variance=5,
        occasional_pause_chance=0.03,
        typo_chance=0.01,
    ),
}


class HumanBehavior:
    """Simulate human-like behavior for automation.

    Usage:
        human = HumanBehavior()
        human.click(100, 200)  # Humanized click
        human.type("Hello")    # Humanized typing
    """

    def __init__(self, profile: str | BehaviorProfile = "normal") -> None:
        if isinstance(profile, str):
            self.profile = PROFILES.get(profile, PROFILES["normal"])
        else:
            self.profile = profile

        self._last_action_time = 0.0

    def set_profile(self, profile: str | BehaviorProfile) -> None:
        """Set behavior profile."""
        if isinstance(profile, str):
            self.profile = PROFILES.get(profile, PROFILES["normal"])
        else:
            self.profile = profile

    def random_delay(self, min_d: float | None = None, max_d: float | None = None) -> None:
        """Wait for a random duration.

        Args:
            min_d: Minimum delay (default from profile)
            max_d: Maximum delay (default from profile)
        """
        min_d = min_d or self.profile.min_delay
        max_d = max_d or self.profile.max_delay
        delay = random.uniform(min_d, max_d)
        time.sleep(delay)

    def maybe_pause(self) -> bool:
        """Occasionally take a random pause.

        Returns:
            True if paused
        """
        if random.random() < self.profile.occasional_pause_chance:
            pause = random.uniform(
                self.profile.occasional_pause_min,
                self.profile.occasional_pause_max,
            )
            time.sleep(pause)
            return True
        return False

    def vary_position(self, x: int, y: int) -> tuple[int, int]:
        """Add small random variance to position.

        Args:
            x: Original X
            y: Original Y

        Returns:
            Varied (x, y)
        """
        variance = self.profile.position_variance
        new_x = x + random.randint(-variance, variance)
        new_y = y + random.randint(-variance, variance)
        return (new_x, new_y)

    def click(
        self,
        x: int,
        y: int,
        button: str = "left",
        vary: bool = True,
    ) -> None:
        """Perform a humanized click.

        Args:
            x: X coordinate
            y: Y coordinate
            button: Mouse button
            vary: Whether to vary position
        """
        if not HAS_PYAUTOGUI:
            print(f"[HUMAN] click({x}, {y})")
            return

        # Vary position
        if vary:
            x, y = self.vary_position(x, y)

        # Move with human-like speed
        duration = random.uniform(
            self.profile.mouse_speed_min,
            self.profile.mouse_speed_max,
        )
        pyautogui.moveTo(x, y, duration=duration)

        # Random delay before click
        self.random_delay()

        # Click with hold time
        hold_time = random.uniform(
            self.profile.click_hold_min,
            self.profile.click_hold_max,
        )
        pyautogui.mouseDown(button=button)
        time.sleep(hold_time)
        pyautogui.mouseUp(button=button)

        # Maybe pause
        self.maybe_pause()

    def double_click(self, x: int, y: int, vary: bool = True) -> None:
        """Perform humanized double-click."""
        self.click(x, y, vary=vary)
        time.sleep(random.uniform(0.05, 0.15))
        self.click(x, y, vary=False)

    def drag(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        button: str = "left",
    ) -> None:
        """Perform humanized drag."""
        if not HAS_PYAUTOGUI:
            print(f"[HUMAN] drag({x1}, {y1} -> {x2}, {y2})")
            return

        # Move to start
        duration = random.uniform(
            self.profile.mouse_speed_min,
            self.profile.mouse_speed_max,
        )
        pyautogui.moveTo(x1, y1, duration=duration)
        self.random_delay()

        # Drag to end
        drag_duration = random.uniform(
            self.profile.mouse_speed_min * 2,
            self.profile.mouse_speed_max * 2,
        )
        pyautogui.drag(x2 - x1, y2 - y1, duration=drag_duration, button=button)

    def type(self, text: str, with_typos: bool = False) -> None:
        """Type text with humanized timing.

        Args:
            text: Text to type
            with_typos: Enable random typos
        """
        if not HAS_PYAUTOGUI:
            print(f"[HUMAN] type({text})")
            return

        for _i, char in enumerate(text):
            # Maybe make typo
            if with_typos and random.random() < self.profile.typo_chance:
                # Type wrong char then backspace
                wrong = random.choice("abcdefghijklmnopqrstuvwxyz")
                pyautogui.press(wrong)
                time.sleep(random.uniform(0.1, 0.3))
                pyautogui.press("backspace")
                time.sleep(random.uniform(0.1, 0.2))

            # Type the character
            pyautogui.press(char) if len(char) > 1 else pyautogui.write(char)

            # Random typing delay
            delay = random.uniform(
                self.profile.typing_min,
                self.profile.typing_max,
            )
            time.sleep(delay)

            # Occasional longer pause
            if random.random() < 0.05:
                time.sleep(random.uniform(0.2, 0.5))

    def press(self, key: str, hold: bool = False) -> None:
        """Press key with humanized timing.

        Args:
            key: Key to press
            hold: Whether to hold briefly
        """
        if not HAS_PYAUTOGUI:
            print(f"[HUMAN] press({key})")
            return

        self.random_delay()

        if hold:
            hold_time = random.uniform(0.05, 0.2)
            pyautogui.keyDown(key)
            time.sleep(hold_time)
            pyautogui.keyUp(key)
        else:
            pyautogui.press(key)

    def scroll(self, amount: int, x: int | None = None, y: int | None = None) -> None:
        """Scroll with humanized behavior."""
        if not HAS_PYAUTOGUI:
            print(f"[HUMAN] scroll({amount})")
            return

        if x is not None and y is not None:
            self.click(x, y)
            self.random_delay()

        # Scroll in smaller increments
        direction = 1 if amount > 0 else -1
        remaining = abs(amount)

        while remaining > 0:
            step = min(remaining, random.randint(1, 3))
            pyautogui.scroll(step * direction)
            remaining -= step
            self.random_delay(0.02, 0.1)


class AntiDetection:
    """Anti-detection wrapper combining multiple techniques.

    Usage:
        anti = AntiDetection()
        anti.wrap(my_function)()  # Wrap function with delays

        with anti.guard():
            # Actions within guard get random delays
            pass
    """

    def __init__(self, profile: str = "normal") -> None:
        self.human = HumanBehavior(profile)
        self._enabled = True

    def enable(self) -> None:
        """Enable anti-detection."""
        self._enabled = True

    def disable(self) -> None:
        """Disable anti-detection."""
        self._enabled = False

    def wrap(self, func: Callable[..., Any]) -> Callable[..., Any]:
        """Wrap a function with anti-detection delays.

        Args:
            func: Function to wrap

        Returns:
            Wrapped function
        """

        def wrapped(*args: Any, **kwargs: Any) -> Any:
            if self._enabled:
                self.human.random_delay()
            result = func(*args, **kwargs)
            if self._enabled:
                self.human.maybe_pause()
            return result

        return wrapped

    def guard(self) -> DetectionGuard:
        """Context manager for anti-detection.

        Usage:
            with anti.guard():
                click(100, 200)
                press("a")
        """
        return DetectionGuard(self.human, self._enabled)


class DetectionGuard:
    """Context manager for anti-detection."""

    def __init__(self, human: HumanBehavior, enabled: bool) -> None:
        self._human = human
        self._enabled = enabled

    def __enter__(self) -> DetectionGuard:
        if self._enabled:
            self._human.random_delay()
        return self

    def __exit__(self, *args: Any) -> None:
        if self._enabled:
            self._human.maybe_pause()


# Global instance
_anti: AntiDetection | None = None


def get_anti_detection() -> AntiDetection:
    """Get the default anti-detection instance."""
    global _anti
    if _anti is None:
        _anti = AntiDetection()
    return _anti


def human_click(x: int, y: int, **kwargs: Any) -> None:
    """Perform humanized click."""
    get_anti_detection().human.click(x, y, **kwargs)


def human_type(text: str, **kwargs: Any) -> None:
    """Perform humanized typing."""
    get_anti_detection().human.type(text, **kwargs)


def random_delay(min_d: float = 0.05, max_d: float = 0.3) -> None:
    """Random delay."""
    get_anti_detection().human.random_delay(min_d, max_d)


================================================================================
FILE PATH: core\game\macro.py
LINES: 440
================================================================================

"""
RetroAuto v2 - Macro System

Record and playback mouse/keyboard macros.
Part of RetroScript Phase 20 - Game-Specific Features.
"""

from __future__ import annotations

import json
import time
from collections.abc import Callable
from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path
from threading import Event, Thread
from typing import Any

# Try to import pynput for recording
try:
    from pynput import keyboard, mouse

    HAS_PYNPUT = True
except ImportError:
    HAS_PYNPUT = False
    mouse = None
    keyboard = None

# Try to import pyautogui for playback
try:
    import pyautogui

    HAS_PYAUTOGUI = True
except ImportError:
    HAS_PYAUTOGUI = False
    pyautogui = None


class ActionType(Enum):
    """Types of recordable actions."""

    CLICK = auto()
    MOVE = auto()
    SCROLL = auto()
    KEY_PRESS = auto()
    KEY_RELEASE = auto()
    DELAY = auto()


@dataclass
class MacroAction:
    """A single recorded action."""

    action_type: ActionType
    timestamp: float = 0.0
    x: int = 0
    y: int = 0
    button: str = ""
    key: str = ""
    delta: int = 0  # For scroll

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON."""
        return {
            "type": self.action_type.name,
            "timestamp": self.timestamp,
            "x": self.x,
            "y": self.y,
            "button": self.button,
            "key": self.key,
            "delta": self.delta,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> MacroAction:
        """Create from dictionary."""
        return cls(
            action_type=ActionType[data["type"]],
            timestamp=data.get("timestamp", 0),
            x=data.get("x", 0),
            y=data.get("y", 0),
            button=data.get("button", ""),
            key=data.get("key", ""),
            delta=data.get("delta", 0),
        )


@dataclass
class Macro:
    """A recorded macro."""

    name: str
    actions: list[MacroAction] = field(default_factory=list)
    created_at: float = field(default_factory=time.time)
    description: str = ""
    loop_count: int = 1  # Number of times to play

    @property
    def duration(self) -> float:
        """Get total duration of macro."""
        if not self.actions:
            return 0
        return self.actions[-1].timestamp

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON."""
        return {
            "name": self.name,
            "description": self.description,
            "created_at": self.created_at,
            "loop_count": self.loop_count,
            "actions": [a.to_dict() for a in self.actions],
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> Macro:
        """Create from dictionary."""
        return cls(
            name=data["name"],
            description=data.get("description", ""),
            created_at=data.get("created_at", time.time()),
            loop_count=data.get("loop_count", 1),
            actions=[MacroAction.from_dict(a) for a in data.get("actions", [])],
        )


class MacroRecorder:
    """Record mouse and keyboard actions.

    Usage:
        recorder = MacroRecorder()
        recorder.start()
        # ... user performs actions ...
        macro = recorder.stop()
    """

    def __init__(self) -> None:
        self._recording = False
        self._start_time = 0.0
        self._actions: list[MacroAction] = []
        self._mouse_listener = None
        self._keyboard_listener = None
        self._stop_event = Event()

        # Callbacks
        self.on_action: Callable[[MacroAction], None] | None = None

    def start(self) -> None:
        """Start recording."""
        if self._recording or not HAS_PYNPUT:
            return

        self._recording = True
        self._start_time = time.time()
        self._actions.clear()
        self._stop_event.clear()

        # Start mouse listener
        self._mouse_listener = mouse.Listener(
            on_click=self._on_click,
            on_scroll=self._on_scroll,
        )
        self._mouse_listener.start()

        # Start keyboard listener
        self._keyboard_listener = keyboard.Listener(
            on_press=self._on_key_press,
            on_release=self._on_key_release,
        )
        self._keyboard_listener.start()

    def stop(self, name: str = "Untitled") -> Macro:
        """Stop recording and return macro.

        Args:
            name: Name for the macro

        Returns:
            Recorded Macro
        """
        self._recording = False
        self._stop_event.set()

        if self._mouse_listener:
            self._mouse_listener.stop()
        if self._keyboard_listener:
            self._keyboard_listener.stop()

        return Macro(
            name=name,
            actions=self._actions.copy(),
        )

    def is_recording(self) -> bool:
        """Check if currently recording."""
        return self._recording

    def _add_action(self, action: MacroAction) -> None:
        """Add an action with timestamp."""
        action.timestamp = time.time() - self._start_time
        self._actions.append(action)

        if self.on_action:
            self.on_action(action)

    def _on_click(self, x: int, y: int, button: Any, pressed: bool) -> None:
        """Handle mouse click."""
        if not self._recording or not pressed:
            return

        self._add_action(
            MacroAction(
                action_type=ActionType.CLICK,
                x=x,
                y=y,
                button=button.name if hasattr(button, "name") else str(button),
            )
        )

    def _on_scroll(self, x: int, y: int, dx: int, dy: int) -> None:
        """Handle mouse scroll."""
        if not self._recording:
            return

        self._add_action(
            MacroAction(
                action_type=ActionType.SCROLL,
                x=x,
                y=y,
                delta=dy,
            )
        )

    def _on_key_press(self, key: Any) -> None:
        """Handle key press."""
        if not self._recording:
            return

        key_str = str(key).replace("Key.", "").replace("'", "")

        self._add_action(
            MacroAction(
                action_type=ActionType.KEY_PRESS,
                key=key_str,
            )
        )

    def _on_key_release(self, key: Any) -> None:
        """Handle key release."""
        # We don't typically record key releases
        pass


class MacroPlayer:
    """Play back recorded macros.

    Usage:
        player = MacroPlayer()
        player.play(macro)
    """

    def __init__(self, speed: float = 1.0) -> None:
        self._speed = speed  # 1.0 = normal, 2.0 = double speed
        self._playing = False
        self._stop_event = Event()

        # Callbacks
        self.on_action: Callable[[MacroAction], None] | None = None
        self.on_complete: Callable[[], None] | None = None

    def set_speed(self, speed: float) -> None:
        """Set playback speed."""
        self._speed = max(0.1, min(10.0, speed))

    def play(self, macro: Macro, loop: int | None = None) -> None:
        """Play a macro.

        Args:
            macro: Macro to play
            loop: Override loop count
        """
        if self._playing or not HAS_PYAUTOGUI:
            return

        self._playing = True
        self._stop_event.clear()

        loops = loop or macro.loop_count

        for _i in range(loops):
            if self._stop_event.is_set():
                break

            last_time = 0.0

            for action in macro.actions:
                if self._stop_event.is_set():
                    break

                # Wait for timing
                delay = (action.timestamp - last_time) / self._speed
                if delay > 0:
                    time.sleep(delay)
                last_time = action.timestamp

                # Execute action
                self._execute(action)

                if self.on_action:
                    self.on_action(action)

        self._playing = False

        if self.on_complete:
            self.on_complete()

    def play_async(self, macro: Macro, loop: int | None = None) -> Thread:
        """Play macro in background thread.

        Returns:
            Thread running the playback
        """
        thread = Thread(target=self.play, args=(macro, loop), daemon=True)
        thread.start()
        return thread

    def stop(self) -> None:
        """Stop playback."""
        self._stop_event.set()
        self._playing = False

    def is_playing(self) -> bool:
        """Check if currently playing."""
        return self._playing

    def _execute(self, action: MacroAction) -> None:
        """Execute a single action."""
        if action.action_type == ActionType.CLICK:
            pyautogui.click(action.x, action.y, button=action.button.lower())

        elif action.action_type == ActionType.MOVE:
            pyautogui.moveTo(action.x, action.y)

        elif action.action_type == ActionType.SCROLL:
            pyautogui.scroll(action.delta, action.x, action.y)

        elif action.action_type == ActionType.KEY_PRESS:
            pyautogui.press(action.key)


class MacroManager:
    """Manage macro storage and retrieval.

    Usage:
        manager = MacroManager()
        manager.save(macro)
        loaded = manager.load("my_macro")
    """

    def __init__(self, macros_dir: str | Path = "macros") -> None:
        self.macros_dir = Path(macros_dir)
        self.macros_dir.mkdir(parents=True, exist_ok=True)

    def save(self, macro: Macro) -> Path:
        """Save macro to file.

        Returns:
            Path to saved file
        """
        filename = f"{macro.name}.json"
        filepath = self.macros_dir / filename

        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(macro.to_dict(), f, indent=2)

        return filepath

    def load(self, name: str) -> Macro | None:
        """Load macro from file.

        Args:
            name: Macro name (without extension)

        Returns:
            Loaded Macro or None
        """
        filepath = self.macros_dir / f"{name}.json"
        if not filepath.exists():
            return None

        with open(filepath, encoding="utf-8") as f:
            data = json.load(f)

        return Macro.from_dict(data)

    def list_macros(self) -> list[str]:
        """List all saved macro names."""
        return [f.stem for f in self.macros_dir.glob("*.json")]

    def delete(self, name: str) -> bool:
        """Delete a macro.

        Returns:
            True if deleted
        """
        filepath = self.macros_dir / f"{name}.json"
        if filepath.exists():
            filepath.unlink()
            return True
        return False


# Global instances
_recorder: MacroRecorder | None = None
_player: MacroPlayer | None = None
_manager: MacroManager | None = None


def get_recorder() -> MacroRecorder:
    """Get the default macro recorder."""
    global _recorder
    if _recorder is None:
        _recorder = MacroRecorder()
    return _recorder


def get_player() -> MacroPlayer:
    """Get the default macro player."""
    global _player
    if _player is None:
        _player = MacroPlayer()
    return _player


def get_manager() -> MacroManager:
    """Get the default macro manager."""
    global _manager
    if _manager is None:
        _manager = MacroManager()
    return _manager


================================================================================
FILE PATH: core\game\pixel_detect.py
LINES: 381
================================================================================

"""
RetroAuto v2 - Pixel Detection

Fast color-based pixel detection for game automation.
Part of RetroScript Phase 20 - Game-Specific Features.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any

# Try to import optional dependencies
try:
    import mss
    import numpy as np

    HAS_MSS = True
except ImportError:
    HAS_MSS = False
    mss = None
    np = None

try:
    from PIL import ImageGrab

    HAS_PIL = True
except ImportError:
    HAS_PIL = False
    ImageGrab = None


@dataclass
class Color:
    """RGB color with optional tolerance."""

    r: int
    g: int
    b: int
    tolerance: int = 10

    def matches(self, other: Color) -> bool:
        """Check if colors match within tolerance."""
        return (
            abs(self.r - other.r) <= self.tolerance
            and abs(self.g - other.g) <= self.tolerance
            and abs(self.b - other.b) <= self.tolerance
        )

    @classmethod
    def from_hex(cls, hex_color: str, tolerance: int = 10) -> Color:
        """Create color from hex string like '#FF0000'."""
        hex_color = hex_color.lstrip("#")
        r = int(hex_color[0:2], 16)
        g = int(hex_color[2:4], 16)
        b = int(hex_color[4:6], 16)
        return cls(r, g, b, tolerance)

    @classmethod
    def from_tuple(cls, rgb: tuple[int, int, int], tolerance: int = 10) -> Color:
        """Create color from (r, g, b) tuple."""
        return cls(rgb[0], rgb[1], rgb[2], tolerance)

    def to_hex(self) -> str:
        """Convert to hex string."""
        return f"#{self.r:02x}{self.g:02x}{self.b:02x}"

    def to_tuple(self) -> tuple[int, int, int]:
        """Convert to (r, g, b) tuple."""
        return (self.r, self.g, self.b)


@dataclass
class PixelResult:
    """Result of a pixel check."""

    x: int
    y: int
    color: Color
    matched: bool = True

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "x": self.x,
            "y": self.y,
            "r": self.color.r,
            "g": self.color.g,
            "b": self.color.b,
            "hex": self.color.to_hex(),
            "matched": self.matched,
        }


class PixelChecker:
    """Fast pixel-based detection for games.

    Usage:
        checker = PixelChecker()

        # Get pixel color
        color = checker.get_pixel(100, 200)

        # Check if pixel matches color
        if checker.check_pixel(100, 200, Color(255, 0, 0)):
            print("Red pixel found!")

        # Find pixel with color
        result = checker.find_pixel(Color(255, 0, 0), region=(0, 0, 500, 500))
    """

    def __init__(self) -> None:
        self._screen_cache: Any = None
        self._cache_time: float = 0

    def get_pixel(self, x: int, y: int) -> Color:
        """Get the color of a pixel at position.

        Args:
            x: X coordinate
            y: Y coordinate

        Returns:
            Color at position
        """
        screen = self._capture_screen()
        if screen is None:
            return Color(0, 0, 0)

        # Get pixel value
        try:
            if HAS_MSS and isinstance(screen, np.ndarray):
                # BGR format from mss
                b, g, r = screen[y, x, :3]
                return Color(int(r), int(g), int(b))
            else:
                # PIL format
                r, g, b = screen.getpixel((x, y))[:3]
                return Color(r, g, b)
        except (IndexError, Exception):
            return Color(0, 0, 0)

    def check_pixel(
        self,
        x: int,
        y: int,
        expected: Color | tuple[int, int, int] | str,
        tolerance: int | None = None,
    ) -> bool:
        """Check if pixel matches expected color.

        Args:
            x: X coordinate
            y: Y coordinate
            expected: Expected color
            tolerance: Override color tolerance

        Returns:
            True if pixel matches
        """
        # Convert expected to Color
        if isinstance(expected, str):
            expected = Color.from_hex(expected, tolerance or 10)
        elif isinstance(expected, tuple):
            expected = Color.from_tuple(expected, tolerance or 10)
        elif tolerance is not None:
            expected = Color(expected.r, expected.g, expected.b, tolerance)

        actual = self.get_pixel(x, y)
        return expected.matches(actual)

    def check_pixels(
        self,
        checks: list[tuple[int, int, Color | str]],
        all_match: bool = True,
    ) -> bool:
        """Check multiple pixels at once.

        Args:
            checks: List of (x, y, color) tuples
            all_match: If True, all must match; if False, any match is enough

        Returns:
            True if condition is met
        """
        results = []

        for x, y, expected in checks:
            if isinstance(expected, str):
                expected = Color.from_hex(expected)
            elif isinstance(expected, tuple):
                expected = Color.from_tuple(expected)

            results.append(self.check_pixel(x, y, expected))

        if all_match:
            return all(results)
        else:
            return any(results)

    def find_pixel(
        self,
        target: Color | str,
        region: tuple[int, int, int, int] | None = None,
        step: int = 1,
    ) -> PixelResult | None:
        """Find first pixel matching target color.

        Args:
            target: Target color to find
            region: (x, y, width, height) search region
            step: Pixel step for faster search

        Returns:
            PixelResult if found, None otherwise
        """
        if isinstance(target, str):
            target = Color.from_hex(target)

        screen = self._capture_screen(region)
        if screen is None:
            return None

        # Region offset
        offset_x = region[0] if region else 0
        offset_y = region[1] if region else 0

        # Search for pixel
        try:
            if HAS_MSS and isinstance(screen, np.ndarray):
                h, w = screen.shape[:2]
                for y in range(0, h, step):
                    for x in range(0, w, step):
                        b, g, r = screen[y, x, :3]
                        color = Color(int(r), int(g), int(b))
                        if target.matches(color):
                            return PixelResult(
                                x=x + offset_x,
                                y=y + offset_y,
                                color=color,
                            )
        except Exception:
            pass

        return None

    def find_all_pixels(
        self,
        target: Color | str,
        region: tuple[int, int, int, int] | None = None,
        max_results: int = 100,
        step: int = 1,
    ) -> list[PixelResult]:
        """Find all pixels matching target color.

        Args:
            target: Target color to find
            region: Search region
            max_results: Maximum results to return
            step: Search step

        Returns:
            List of PixelResults
        """
        if isinstance(target, str):
            target = Color.from_hex(target)

        results: list[PixelResult] = []
        screen = self._capture_screen(region)
        if screen is None:
            return results

        offset_x = region[0] if region else 0
        offset_y = region[1] if region else 0

        try:
            if HAS_MSS and isinstance(screen, np.ndarray):
                h, w = screen.shape[:2]
                for y in range(0, h, step):
                    for x in range(0, w, step):
                        if len(results) >= max_results:
                            break
                        b, g, r = screen[y, x, :3]
                        color = Color(int(r), int(g), int(b))
                        if target.matches(color):
                            results.append(
                                PixelResult(
                                    x=x + offset_x,
                                    y=y + offset_y,
                                    color=color,
                                )
                            )
        except Exception:
            pass

        return results

    def wait_for_pixel(
        self,
        x: int,
        y: int,
        expected: Color | str,
        timeout: float = 10.0,
        interval: float = 0.1,
    ) -> bool:
        """Wait for pixel to match expected color.

        Args:
            x: X coordinate
            y: Y coordinate
            expected: Expected color
            timeout: Maximum wait time
            interval: Check interval

        Returns:
            True if pixel matched within timeout
        """
        import time

        if isinstance(expected, str):
            expected = Color.from_hex(expected)

        start = time.time()
        while time.time() - start < timeout:
            if self.check_pixel(x, y, expected):
                return True
            time.sleep(interval)

        return False

    def _capture_screen(
        self,
        region: tuple[int, int, int, int] | None = None,
    ) -> Any:
        """Capture screen or region."""
        if HAS_MSS:
            with mss.mss() as sct:
                if region:
                    x, y, w, h = region
                    monitor = {"left": x, "top": y, "width": w, "height": h}
                else:
                    monitor = sct.monitors[1]

                screenshot = sct.grab(monitor)
                return np.array(screenshot)

        elif HAS_PIL:
            if region:
                x, y, w, h = region
                return ImageGrab.grab(bbox=(x, y, x + w, y + h))
            return ImageGrab.grab()

        return None


# Global instance
_checker: PixelChecker | None = None


def get_checker() -> PixelChecker:
    """Get the default pixel checker."""
    global _checker
    if _checker is None:
        _checker = PixelChecker()
    return _checker


# Convenience functions
def get_pixel(x: int, y: int) -> Color:
    """Get pixel color at position."""
    return get_checker().get_pixel(x, y)


def check_pixel(x: int, y: int, color: Color | str) -> bool:
    """Check if pixel matches color."""
    return get_checker().check_pixel(x, y, color)


def find_pixel(color: Color | str, region: tuple | None = None) -> PixelResult | None:
    """Find first pixel matching color."""
    return get_checker().find_pixel(color, region)


================================================================================
FILE PATH: core\graph\__init__.py
LINES: 4
================================================================================

# Graph module init
from core.graph.converter import auto_layout_graph, generate_node_id, graph_to_list, list_to_graph

__all__ = ["list_to_graph", "graph_to_list", "auto_layout_graph", "generate_node_id"]


================================================================================
FILE PATH: core\graph\converter.py
LINES: 130
================================================================================

"""
RetroAuto v2 - Graph Conversion Utilities

Phase 4: Data Model Migration
- Convert list <-> graph
- Auto-layout for list-to-graph conversion
- UUID generation
"""

import uuid

from core.models import Action, FlowGraph, GraphConnection, GraphNode
from infra import get_logger

logger = get_logger("GraphConverter")


def list_to_graph(actions: list[Action]) -> FlowGraph:
    """
    Convert a linear action list to a graph structure.

    Uses auto-layout to position nodes in a vertical flow.
    """
    nodes = []
    connections = []

    # Auto-layout settings
    start_x = 0
    start_y = 0
    spacing_y = 100

    node_ids = []

    # Create nodes
    for i, action in enumerate(actions):
        node_id = str(uuid.uuid4())
        node = GraphNode(id=node_id, action=action, x=start_x, y=start_y + (i * spacing_y))
        nodes.append(node)
        node_ids.append(node_id)

    # Create linear connections (each node to next)
    for i in range(len(node_ids) - 1):
        connection = GraphConnection(
            from_node=node_ids[i],
            from_socket="exec_out",
            to_node=node_ids[i + 1],
            to_socket="exec_in",
        )
        connections.append(connection)

    return FlowGraph(nodes=nodes, connections=connections)


def graph_to_list(graph: FlowGraph) -> list[Action]:
    """
    Convert a graph to a linear action list.

    Performs topological sort to determine execution order.
    For simple linear graphs, this is straightforward.
    For complex graphs with branches, uses depth-first traversal.
    """
    if not graph.nodes:
        return []

    # Build adjacency map
    node_map = {node.id: node for node in graph.nodes}
    outgoing = {node.id: [] for node in graph.nodes}

    for conn in graph.connections:
        if conn.from_socket == "exec_out":  # Only follow exec flow
            outgoing[conn.from_node].append(conn.to_node)

    # Find start node (node with no incoming exec connections)
    incoming_counts = {node.id: 0 for node in graph.nodes}
    for conn in graph.connections:
        if conn.from_socket == "exec_out":
            incoming_counts[conn.to_node] += 1

    start_nodes = [nid for nid, count in incoming_counts.items() if count == 0]

    if not start_nodes:
        # Fallback: use first node by position
        logger.warning("No clear start node found, using topmost node")
        start_nodes = [min(graph.nodes, key=lambda n: n.y).id]

    # DFS traversal
    visited = set()
    result = []

    def visit(node_id: str):
        if node_id in visited:
            return
        visited.add(node_id)

        # Add this node's action
        if node_id in node_map:
            result.append(node_map[node_id].action)

        # Visit children
        for child_id in outgoing.get(node_id, []):
            visit(child_id)

    # Start from each start node
    for start_id in start_nodes:
        visit(start_id)

    return result


def auto_layout_graph(graph: FlowGraph, algorithm: str = "vertical") -> FlowGraph:
    """
    Auto-arrange nodes in the graph.

    Algorithms:
    - vertical: Simple top-to-bottom flow
    - hierarchical: Layered layout (future)
    """
    if algorithm == "vertical":
        # Simple vertical layout
        spacing = 100
        for i, node in enumerate(graph.nodes):
            node.x = 0
            node.y = i * spacing

    return graph


def generate_node_id() -> str:
    """Generate a unique node ID."""
    return str(uuid.uuid4())


================================================================================
FILE PATH: core\graph\walker.py
LINES: 150
================================================================================

"""
RetroAuto v2 - Graph Execution Walker

Phase 5: Execution Engine
- Traverse graph following exec connections
- Handle branching (IfImage true/false paths)
- Maintain execution order
"""

from collections.abc import Callable
from typing import Any

from core.models import Action, FlowGraph, GraphConnection, GraphNode
from infra import get_logger

logger = get_logger("GraphWalker")


class GraphWalker:
    """
    Walks through a flow graph and executes nodes in order.

    Follows execution flow connections (exec_out -> exec_in).
    Supports branching via conditional nodes.
    """

    def __init__(self, graph: FlowGraph):
        self.graph = graph

        # Build lookup maps
        self.node_map = {node.id: node for node in graph.nodes}

        # Build adjacency map (outgoing connections from each node)
        self.outgoing: dict[str, list[GraphConnection]] = {node.id: [] for node in graph.nodes}
        for conn in graph.connections:
            if conn.from_node in self.outgoing:
                self.outgoing[conn.from_node].append(conn)

        # Track visited nodes (for loop detection)
        self.visited = set()
        self.execution_count = {}  # Track how many times each node executed

    def find_start_node(self) -> GraphNode | None:
        """
        Find the start node (node with no incoming exec connections).
        """
        # Count incoming exec connections
        incoming_counts = {node.id: 0 for node in self.graph.nodes}

        for conn in self.graph.connections:
            if conn.to_socket == "exec_in":  # Only count exec flow
                incoming_counts[conn.to_node] += 1

        # Find nodes with no incoming connections
        start_candidates = [nid for nid, count in incoming_counts.items() if count == 0]

        if not start_candidates:
            logger.warning("No clear start node found in graph")
            return None

        if len(start_candidates) > 1:
            # Multiple start nodes - pick the topmost one
            logger.warning(f"Multiple start nodes found ({len(start_candidates)}), using topmost")
            start_candidates.sort(key=lambda nid: self.node_map[nid].y)

        return self.node_map[start_candidates[0]]

    def get_next_node(self, current_id: str, branch_result: Any = None) -> GraphNode | None:
        """
        Get the next node to execute based on current node's output connections.

        For regular nodes: follows 'exec_out' connection
        For conditional nodes (IfImage, IfText): follows 'true_out' or 'false_out' based on result

        Args:
            current_id: Current node ID
            branch_result: Result of conditional check (True/False) for branching nodes
        """
        connections = self.outgoing.get(current_id, [])

        # Filter to exec flow connections
        exec_connections = [
            c for c in connections if c.from_socket in ("exec_out", "true_out", "false_out")
        ]

        if not exec_connections:
            return None  # End of flow

        # Handle branching
        if branch_result is not None:
            # This is a conditional node
            target_socket = "true_out" if branch_result else "false_out"
            for conn in exec_connections:
                if conn.from_socket == target_socket:
                    return self.node_map.get(conn.to_node)

            logger.warning(f"No {target_socket} connection found for node {current_id}")
            return None

        # Regular flow - just take the first exec connection
        if len(exec_connections) > 1:
            logger.warning(f"Multiple exec outputs from node {current_id}, taking first")

        conn = exec_connections[0]
        return self.node_map.get(conn.to_node)

    def execute_graph(self, action_executor: Callable[[Action], Any], max_iterations: int = 10000):
        """
        Execute the entire graph.

        Args:
            action_executor: Function that executes an action and returns result
            max_iterations: Safety limit to prevent infinite loops
        """
        start_node = self.find_start_node()

        if not start_node:
            logger.error("Cannot execute graph: no start node found")
            return

        current_node = start_node
        iteration_count = 0

        while current_node and iteration_count < max_iterations:
            iteration_count += 1

            # Track execution
            self.execution_count[current_node.id] = self.execution_count.get(current_node.id, 0) + 1

            # Detect infinite loops (node executed too many times)
            if self.execution_count[current_node.id] > 1000:
                logger.error(f"Infinite loop detected at node {current_node.id}")
                break

            logger.debug(f"Executing node {current_node.id}: {type(current_node.action).__name__}")

            # Execute the action
            try:
                result = action_executor(current_node.action)
            except Exception as e:
                logger.error(f"Error executing node {current_node.id}: {e}")
                break

            # Get next node
            current_node = self.get_next_node(current_node.id, branch_result=result)

        if iteration_count >= max_iterations:
            logger.error("Execution stopped: max iterations reached (possible infinite loop)")

        logger.info(f"Graph execution complete. Executed {iteration_count} nodes.")


================================================================================
FILE PATH: core\lsp\server.py
LINES: 582
================================================================================

"""
RetroAuto v2 - Language Server Protocol

LSP implementation for RetroScript IDE integration.
Part of RetroScript Phase 12 - LSP.
"""

from __future__ import annotations

import json
import re
import sys
from collections.abc import Callable
from dataclasses import dataclass
from enum import IntEnum
from typing import Any

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# LSP Protocol Types
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class MessageType(IntEnum):
    """LSP message types."""

    ERROR = 1
    WARNING = 2
    INFO = 3
    LOG = 4


class DiagnosticSeverity(IntEnum):
    """LSP diagnostic severity."""

    ERROR = 1
    WARNING = 2
    INFORMATION = 3
    HINT = 4


class CompletionItemKind(IntEnum):
    """LSP completion item kinds."""

    TEXT = 1
    METHOD = 2
    FUNCTION = 3
    CONSTRUCTOR = 4
    FIELD = 5
    VARIABLE = 6
    CLASS = 7
    INTERFACE = 8
    MODULE = 9
    PROPERTY = 10
    KEYWORD = 14
    SNIPPET = 15


@dataclass
class Position:
    """LSP position (0-indexed)."""

    line: int
    character: int

    def to_dict(self) -> dict[str, int]:
        return {"line": self.line, "character": self.character}


@dataclass
class Range:
    """LSP range."""

    start: Position
    end: Position

    def to_dict(self) -> dict[str, Any]:
        return {"start": self.start.to_dict(), "end": self.end.to_dict()}


@dataclass
class Location:
    """LSP location."""

    uri: str
    range: Range

    def to_dict(self) -> dict[str, Any]:
        return {"uri": self.uri, "range": self.range.to_dict()}


@dataclass
class Diagnostic:
    """LSP diagnostic."""

    range: Range
    message: str
    severity: DiagnosticSeverity = DiagnosticSeverity.ERROR
    source: str = "retroscript"

    def to_dict(self) -> dict[str, Any]:
        return {
            "range": self.range.to_dict(),
            "message": self.message,
            "severity": self.severity.value,
            "source": self.source,
        }


@dataclass
class CompletionItem:
    """LSP completion item."""

    label: str
    kind: CompletionItemKind = CompletionItemKind.TEXT
    detail: str = ""
    documentation: str = ""
    insert_text: str = ""

    def to_dict(self) -> dict[str, Any]:
        result: dict[str, Any] = {"label": self.label, "kind": self.kind.value}
        if self.detail:
            result["detail"] = self.detail
        if self.documentation:
            result["documentation"] = self.documentation
        if self.insert_text:
            result["insertText"] = self.insert_text
        return result


@dataclass
class Hover:
    """LSP hover result."""

    contents: str
    range: Range | None = None

    def to_dict(self) -> dict[str, Any]:
        result: dict[str, Any] = {"contents": {"kind": "markdown", "value": self.contents}}
        if self.range:
            result["range"] = self.range.to_dict()
        return result


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Document Management
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


@dataclass
class TextDocument:
    """A text document being edited."""

    uri: str
    text: str
    version: int = 0
    language_id: str = "retroscript"

    def get_line(self, line: int) -> str:
        """Get a specific line."""
        lines = self.text.split("\n")
        if 0 <= line < len(lines):
            return lines[line]
        return ""

    def get_word_at(self, position: Position) -> str:
        """Get word at position."""
        line = self.get_line(position.line)
        if not line:
            return ""

        # Find word boundaries
        start = position.character
        end = position.character

        while start > 0 and re.match(r"[\w$@]", line[start - 1]):
            start -= 1

        while end < len(line) and re.match(r"[\w$@]", line[end]):
            end += 1

        return line[start:end]


class DocumentStore:
    """Store for open documents."""

    def __init__(self) -> None:
        self._documents: dict[str, TextDocument] = {}

    def open(self, uri: str, text: str, version: int = 0) -> TextDocument:
        """Open a document."""
        doc = TextDocument(uri=uri, text=text, version=version)
        self._documents[uri] = doc
        return doc

    def update(self, uri: str, text: str, version: int) -> TextDocument | None:
        """Update a document."""
        if uri in self._documents:
            self._documents[uri].text = text
            self._documents[uri].version = version
            return self._documents[uri]
        return None

    def close(self, uri: str) -> None:
        """Close a document."""
        self._documents.pop(uri, None)

    def get(self, uri: str) -> TextDocument | None:
        """Get a document."""
        return self._documents.get(uri)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Language Server
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class RetroScriptLanguageServer:
    """Language Server for RetroScript.

    Usage:
        server = RetroScriptLanguageServer()
        server.run()  # Reads from stdin, writes to stdout
    """

    def __init__(self) -> None:
        self.documents = DocumentStore()
        self._initialized = False
        self._shutdown = False

        # Symbol cache
        self._flows: dict[str, Location] = {}
        self._variables: dict[str, Location] = {}

    def run(self) -> None:
        """Run the language server (stdio mode)."""
        while not self._shutdown:
            try:
                message = self._read_message()
                if message:
                    response = self._handle_message(message)
                    if response:
                        self._write_message(response)
            except Exception as e:
                self._log(f"Error: {e}")
                break

    def _read_message(self) -> dict[str, Any] | None:
        """Read a JSON-RPC message from stdin."""
        # Read headers
        headers: dict[str, str] = {}
        while True:
            line = sys.stdin.readline()
            if not line or line == "\r\n" or line == "\n":
                break
            if ":" in line:
                key, value = line.split(":", 1)
                headers[key.strip()] = value.strip()

        # Read content
        length = int(headers.get("Content-Length", 0))
        if length:
            content = sys.stdin.read(length)
            return json.loads(content)

        return None

    def _write_message(self, message: dict[str, Any]) -> None:
        """Write a JSON-RPC message to stdout."""
        content = json.dumps(message)
        header = f"Content-Length: {len(content)}\r\n\r\n"
        sys.stdout.write(header + content)
        sys.stdout.flush()

    def _handle_message(self, message: dict[str, Any]) -> dict[str, Any] | None:
        """Handle incoming message."""
        method = message.get("method", "")
        params = message.get("params", {})
        msg_id = message.get("id")

        # Dispatch to handlers
        handlers: dict[str, Callable[..., Any]] = {
            "initialize": self._handle_initialize,
            "initialized": lambda _: None,
            "shutdown": self._handle_shutdown,
            "exit": self._handle_exit,
            "textDocument/didOpen": self._handle_did_open,
            "textDocument/didChange": self._handle_did_change,
            "textDocument/didClose": self._handle_did_close,
            "textDocument/hover": self._handle_hover,
            "textDocument/completion": self._handle_completion,
            "textDocument/definition": self._handle_definition,
            "textDocument/references": self._handle_references,
            "textDocument/formatting": self._handle_formatting,
        }

        handler = handlers.get(method)
        if handler:
            result = handler(params)
            if msg_id is not None:
                return {
                    "jsonrpc": "2.0",
                    "id": msg_id,
                    "result": result,
                }
        elif msg_id is not None:
            return {
                "jsonrpc": "2.0",
                "id": msg_id,
                "error": {"code": -32601, "message": f"Method not found: {method}"},
            }

        return None

    def _handle_initialize(self, params: dict[str, Any]) -> dict[str, Any]:
        """Handle initialize request."""
        self._initialized = True
        return {
            "capabilities": {
                "textDocumentSync": 1,  # Full sync
                "completionProvider": {"triggerCharacters": [".", "$", "@"]},
                "hoverProvider": True,
                "definitionProvider": True,
                "referencesProvider": True,
                "documentFormattingProvider": True,
            }
        }

    def _handle_shutdown(self, params: dict[str, Any]) -> None:
        """Handle shutdown request."""
        self._shutdown = True
        return None

    def _handle_exit(self, params: dict[str, Any]) -> None:
        """Handle exit notification."""
        sys.exit(0)

    def _handle_did_open(self, params: dict[str, Any]) -> None:
        """Handle textDocument/didOpen."""
        doc = params.get("textDocument", {})
        uri = doc.get("uri", "")
        text = doc.get("text", "")
        version = doc.get("version", 0)

        self.documents.open(uri, text, version)
        self._analyze_document(uri)

    def _handle_did_change(self, params: dict[str, Any]) -> None:
        """Handle textDocument/didChange."""
        doc = params.get("textDocument", {})
        uri = doc.get("uri", "")
        version = doc.get("version", 0)

        changes = params.get("contentChanges", [])
        if changes:
            text = changes[-1].get("text", "")
            self.documents.update(uri, text, version)
            self._analyze_document(uri)

    def _handle_did_close(self, params: dict[str, Any]) -> None:
        """Handle textDocument/didClose."""
        doc = params.get("textDocument", {})
        uri = doc.get("uri", "")
        self.documents.close(uri)

    def _handle_hover(self, params: dict[str, Any]) -> dict[str, Any] | None:
        """Handle textDocument/hover."""
        uri = params.get("textDocument", {}).get("uri", "")
        pos = params.get("position", {})
        position = Position(pos.get("line", 0), pos.get("character", 0))

        doc = self.documents.get(uri)
        if not doc:
            return None

        word = doc.get_word_at(position)
        if not word:
            return None

        # Check for hover info
        hover_info = self._get_hover_info(word)
        if hover_info:
            return Hover(contents=hover_info).to_dict()

        return None

    def _handle_completion(self, params: dict[str, Any]) -> list[dict[str, Any]]:
        """Handle textDocument/completion."""
        uri = params.get("textDocument", {}).get("uri", "")
        pos = params.get("position", {})
        position = Position(pos.get("line", 0), pos.get("character", 0))

        doc = self.documents.get(uri)
        if not doc:
            return []

        line = doc.get_line(position.line)
        prefix = line[: position.character].split()[-1] if line else ""

        return self._get_completions(prefix)

    def _handle_definition(self, params: dict[str, Any]) -> list[dict[str, Any]]:
        """Handle textDocument/definition."""
        uri = params.get("textDocument", {}).get("uri", "")
        pos = params.get("position", {})
        position = Position(pos.get("line", 0), pos.get("character", 0))

        doc = self.documents.get(uri)
        if not doc:
            return []

        word = doc.get_word_at(position)
        if not word:
            return []

        # Look up definition
        if word in self._flows:
            return [self._flows[word].to_dict()]

        return []

    def _handle_references(self, params: dict[str, Any]) -> list[dict[str, Any]]:
        """Handle textDocument/references."""
        uri = params.get("textDocument", {}).get("uri", "")
        pos = params.get("position", {})
        position = Position(pos.get("line", 0), pos.get("character", 0))

        doc = self.documents.get(uri)
        if not doc:
            return []

        word = doc.get_word_at(position)
        if not word:
            return []

        return self._find_references(uri, word)

    def _handle_formatting(self, params: dict[str, Any]) -> list[dict[str, Any]]:
        """Handle textDocument/formatting."""
        uri = params.get("textDocument", {}).get("uri", "")
        doc = self.documents.get(uri)
        if not doc:
            return []

        # Use the formatter
        try:
            from app.ide.formatter import CodeFormatter

            formatter = CodeFormatter()
            formatted = formatter.format(doc.text)

            lines = doc.text.count("\n")
            return [
                {
                    "range": Range(
                        Position(0, 0),
                        Position(lines, len(doc.get_line(lines))),
                    ).to_dict(),
                    "newText": formatted,
                }
            ]
        except Exception:
            return []

    def _analyze_document(self, uri: str) -> None:
        """Analyze document for symbols and diagnostics."""
        doc = self.documents.get(uri)
        if not doc:
            return

        # Find flow definitions
        for i, line in enumerate(doc.text.split("\n")):
            match = re.match(r"flow\s+(\w+)", line)
            if match:
                name = match.group(1)
                self._flows[name] = Location(
                    uri=uri,
                    range=Range(Position(i, 0), Position(i, len(line))),
                )

    def _get_hover_info(self, word: str) -> str | None:
        """Get hover information for a word."""
        # Built-in functions
        builtins = {
            "find": "```retroscript\nfind(target, options?)\n```\nFind an image on screen.",
            "click": "```retroscript\nclick(x, y)\n```\nClick at the specified position.",
            "wait": "```retroscript\nwait(duration)\n```\nWait for the specified duration.",
            "log": "```retroscript\nlog(message)\n```\nLog a message to console.",
            "sleep": "```retroscript\nsleep(ms)\n```\nSleep for milliseconds.",
        }

        if word in builtins:
            return builtins[word]

        # Keywords
        keywords = {
            "flow": "Define a new flow (function)",
            "let": "Declare a variable",
            "if": "Conditional statement",
            "while": "While loop",
            "for": "For loop",
            "return": "Return from flow",
        }

        if word in keywords:
            return f"**{word}** - {keywords[word]}"

        # Check if it's a known flow
        if word in self._flows:
            return f"**flow {word}**"

        return None

    def _get_completions(self, prefix: str) -> list[dict[str, Any]]:
        """Get completion items."""
        items: list[CompletionItem] = []

        # Keywords
        keywords = ["flow", "let", "if", "else", "while", "for", "return", "try", "catch"]
        for kw in keywords:
            if kw.startswith(prefix):
                items.append(CompletionItem(kw, CompletionItemKind.KEYWORD))

        # Built-ins
        builtins = ["find", "click", "wait", "log", "sleep", "type", "press"]
        for bi in builtins:
            if bi.startswith(prefix):
                items.append(CompletionItem(bi, CompletionItemKind.FUNCTION))

        # Flows
        for name in self._flows:
            if name.startswith(prefix):
                items.append(CompletionItem(name, CompletionItemKind.METHOD))

        return [item.to_dict() for item in items]

    def _find_references(self, uri: str, word: str) -> list[dict[str, Any]]:
        """Find all references to a symbol."""
        references: list[Location] = []

        for doc_uri, doc in self.documents._documents.items():
            for i, line in enumerate(doc.text.split("\n")):
                for match in re.finditer(rf"\b{re.escape(word)}\b", line):
                    references.append(
                        Location(
                            uri=doc_uri,
                            range=Range(
                                Position(i, match.start()),
                                Position(i, match.end()),
                            ),
                        )
                    )

        return [ref.to_dict() for ref in references]

    def _log(self, message: str) -> None:
        """Log a message."""
        sys.stderr.write(f"[LSP] {message}\n")
        sys.stderr.flush()

    def _publish_diagnostics(self, uri: str, diagnostics: list[Diagnostic]) -> None:
        """Publish diagnostics to client."""
        self._write_message(
            {
                "jsonrpc": "2.0",
                "method": "textDocument/publishDiagnostics",
                "params": {
                    "uri": uri,
                    "diagnostics": [d.to_dict() for d in diagnostics],
                },
            }
        )


def main() -> None:
    """Entry point for language server."""
    server = RetroScriptLanguageServer()
    server.run()


if __name__ == "__main__":
    main()


================================================================================
FILE PATH: core\network\http_client.py
LINES: 243
================================================================================

"""
RetroAuto v2 - HTTP Client

HTTP request utilities for RetroScript.
Part of RetroScript Phase 16 - Network Features.
"""

from __future__ import annotations

import json
from dataclasses import dataclass, field
from typing import Any

# Try to import requests
try:
    import requests

    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
    requests = None


@dataclass
class HttpResponse:
    """HTTP response wrapper."""

    status_code: int
    headers: dict[str, str] = field(default_factory=dict)
    body: bytes = b""
    text: str = ""
    json_data: Any = None
    error: str | None = None
    elapsed_ms: float = 0

    @property
    def ok(self) -> bool:
        """Check if request was successful (2xx)."""
        return 200 <= self.status_code < 300

    def json(self) -> Any:
        """Get JSON data."""
        if self.json_data is not None:
            return self.json_data
        try:
            self.json_data = json.loads(self.text)
            return self.json_data
        except json.JSONDecodeError:
            return None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for script access."""
        return {
            "status": self.status_code,
            "ok": self.ok,
            "text": self.text,
            "json": self.json(),
            "headers": self.headers,
            "elapsed_ms": self.elapsed_ms,
            "error": self.error,
        }


class HttpClient:
    """HTTP client for RetroScript.

    Usage:
        client = HttpClient()
        response = client.get("https://api.example.com/data")
        if response.ok:
            data = response.json()
    """

    def __init__(
        self,
        base_url: str = "",
        timeout: float = 30.0,
        headers: dict[str, str] | None = None,
    ) -> None:
        self.base_url = base_url.rstrip("/")
        self.timeout = timeout
        self.default_headers = headers or {}

        if not HAS_REQUESTS:
            print("[WARN] requests library not installed. Using stub mode.")

    def get(
        self,
        url: str,
        params: dict[str, Any] | None = None,
        headers: dict[str, str] | None = None,
    ) -> HttpResponse:
        """Perform GET request.

        Args:
            url: URL or path (if base_url set)
            params: Query parameters
            headers: Additional headers

        Returns:
            HttpResponse
        """
        return self._request("GET", url, params=params, headers=headers)

    def post(
        self,
        url: str,
        data: dict[str, Any] | None = None,
        json_data: Any = None,
        headers: dict[str, str] | None = None,
    ) -> HttpResponse:
        """Perform POST request.

        Args:
            url: URL or path
            data: Form data
            json_data: JSON data
            headers: Additional headers

        Returns:
            HttpResponse
        """
        return self._request("POST", url, data=data, json_data=json_data, headers=headers)

    def put(
        self,
        url: str,
        data: dict[str, Any] | None = None,
        json_data: Any = None,
        headers: dict[str, str] | None = None,
    ) -> HttpResponse:
        """Perform PUT request."""
        return self._request("PUT", url, data=data, json_data=json_data, headers=headers)

    def delete(
        self,
        url: str,
        headers: dict[str, str] | None = None,
    ) -> HttpResponse:
        """Perform DELETE request."""
        return self._request("DELETE", url, headers=headers)

    def patch(
        self,
        url: str,
        data: dict[str, Any] | None = None,
        json_data: Any = None,
        headers: dict[str, str] | None = None,
    ) -> HttpResponse:
        """Perform PATCH request."""
        return self._request("PATCH", url, data=data, json_data=json_data, headers=headers)

    def _request(
        self,
        method: str,
        url: str,
        params: dict[str, Any] | None = None,
        data: dict[str, Any] | None = None,
        json_data: Any = None,
        headers: dict[str, str] | None = None,
    ) -> HttpResponse:
        """Perform HTTP request."""
        # Build full URL
        if not url.startswith(("http://", "https://")):
            url = f"{self.base_url}/{url.lstrip('/')}"

        # Merge headers
        request_headers = {**self.default_headers}
        if headers:
            request_headers.update(headers)

        if not HAS_REQUESTS:
            return self._stub_request(method, url)

        try:
            response = requests.request(
                method=method,
                url=url,
                params=params,
                data=data,
                json=json_data,
                headers=request_headers,
                timeout=self.timeout,
            )

            return HttpResponse(
                status_code=response.status_code,
                headers=dict(response.headers),
                body=response.content,
                text=response.text,
                elapsed_ms=response.elapsed.total_seconds() * 1000,
            )

        except requests.exceptions.Timeout:
            return HttpResponse(status_code=0, error="Request timeout")
        except requests.exceptions.ConnectionError:
            return HttpResponse(status_code=0, error="Connection error")
        except Exception as e:
            return HttpResponse(status_code=0, error=str(e))

    def _stub_request(self, method: str, url: str) -> HttpResponse:
        """Stub request for when requests library is not available."""
        print(f"[STUB] {method} {url}")
        return HttpResponse(
            status_code=200,
            text='{"stub": true}',
        )


# Convenience functions
_default_client: HttpClient | None = None


def get_client() -> HttpClient:
    """Get the default HTTP client."""
    global _default_client
    if _default_client is None:
        _default_client = HttpClient()
    return _default_client


def fetch(url: str, params: dict[str, Any] | None = None) -> HttpResponse:
    """Convenience GET request."""
    return get_client().get(url, params=params)


def post(
    url: str,
    data: dict[str, Any] | None = None,
    json_data: Any = None,
) -> HttpResponse:
    """Convenience POST request."""
    return get_client().post(url, data=data, json_data=json_data)


def put(url: str, json_data: Any = None) -> HttpResponse:
    """Convenience PUT request."""
    return get_client().put(url, json_data=json_data)


def delete(url: str) -> HttpResponse:
    """Convenience DELETE request."""
    return get_client().delete(url)


================================================================================
FILE PATH: core\network\remote.py
LINES: 304
================================================================================

"""
RetroAuto v2 - Remote Control API

REST API for remote script control.
Part of RetroScript Phase 16 - Network Features.
"""

from __future__ import annotations

import json
import threading
import time
from collections.abc import Callable
from dataclasses import dataclass, field
from enum import Enum
from http.server import BaseHTTPRequestHandler, HTTPServer
from typing import Any
from urllib.parse import urlparse


class ScriptState(Enum):
    """Script execution states."""

    IDLE = "idle"
    RUNNING = "running"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"


@dataclass
class ScriptStatus:
    """Current script status."""

    state: ScriptState = ScriptState.IDLE
    script_name: str = ""
    started_at: float = 0
    elapsed: float = 0
    current_flow: str = ""
    error: str | None = None
    variables: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "state": self.state.value,
            "script_name": self.script_name,
            "started_at": self.started_at,
            "elapsed": self.elapsed,
            "current_flow": self.current_flow,
            "error": self.error,
            "variables": self.variables,
        }


class RemoteAPIHandler(BaseHTTPRequestHandler):
    """HTTP request handler for remote control API."""

    # Class-level references
    controller: RemoteController | None = None

    def log_message(self, format: str, *args: Any) -> None:
        """Suppress default logging."""
        pass

    def _send_json(self, data: Any, status: int = 200) -> None:
        """Send JSON response."""
        self.send_response(status)
        self.send_header("Content-Type", "application/json")
        self.send_header("Access-Control-Allow-Origin", "*")
        self.end_headers()
        self.wfile.write(json.dumps(data).encode("utf-8"))

    def _get_body(self) -> dict[str, Any]:
        """Get request body as JSON."""
        try:
            length = int(self.headers.get("Content-Length", 0))
            if length:
                body = self.rfile.read(length)
                return json.loads(body.decode("utf-8"))
        except Exception:
            pass
        return {}

    def do_OPTIONS(self) -> None:
        """Handle CORS preflight."""
        self.send_response(200)
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        self.send_header("Access-Control-Allow-Headers", "Content-Type")
        self.end_headers()

    def do_GET(self) -> None:
        """Handle GET requests."""
        path = urlparse(self.path).path

        if path == "/api/status":
            self._handle_status()
        elif path == "/api/scripts":
            self._handle_list_scripts()
        elif path == "/api/health":
            self._send_json({"status": "ok", "time": time.time()})
        else:
            self._send_json({"error": "Not found"}, 404)

    def do_POST(self) -> None:
        """Handle POST requests."""
        # Security Check
        if self.controller and not self.controller.check_auth(self.headers.get("Authorization")):
            self._send_json({"error": "Unauthorized"}, 401)
            return

        path = urlparse(self.path).path
        body = self._get_body()

        if path == "/api/start":
            self._handle_start(body)
        elif path == "/api/stop":
            self._handle_stop()
        elif path == "/api/pause":
            self._handle_pause()
        elif path == "/api/resume":
            self._handle_resume()
        elif path == "/api/execute":
            # Execution protection
            if self.controller and not self.controller.enable_execution:
                self._send_json({"error": "Remote execution disabled"}, 403)
                return
            self._handle_execute(body)
        else:
            self._send_json({"error": "Not found"}, 404)

    # ... handlers ...


class RemoteController:
    """Remote control server for RetroScript.

    Usage:
        controller = RemoteController(port=8080, auth_token="secret")
        # By default binds to localhost only
    """

    def __init__(
        self,
        host: str = "127.0.0.1",  # P0 Fix: Bind only to localhost
        port: int = 8080,
        auth_token: str | None = None,  # P0 Fix: Auth token
        enable_execution: bool = False,  # P0 Fix: Disable eval by default
    ) -> None:
        self.host = host
        self.port = port
        self.auth_token = auth_token
        self.enable_execution = enable_execution

        self._server: HTTPServer | None = None
        self._thread: threading.Thread | None = None
        self._status = ScriptStatus()
        self._scripts_dir = "scripts"

        # Callbacks
        self.on_start: Callable[[str], None] | None = None
        self.on_stop: Callable[[], None] | None = None
        self.on_pause: Callable[[], None] | None = None
        self.on_execute: Callable[[str], Any] | None = None

    def check_auth(self, header: str | None) -> bool:
        """Check authorization header."""
        if not self.auth_token:
            return True  # No auth required/configured

        if not header:
            return False

        parts = header.split()
        if len(parts) == 2 and parts[0].lower() == "bearer":
            return parts[1] == self.auth_token

        return False

    @property
    def is_running(self) -> bool:
        """Check if server is running."""
        return self._server is not None

    def start(self) -> bool:
        """Start the remote control server.

        Returns:
            True if started successfully
        """
        if self._server:
            return True

        try:
            # Set controller reference
            RemoteAPIHandler.controller = self

            self._server = HTTPServer((self.host, self.port), RemoteAPIHandler)
            self._thread = threading.Thread(target=self._serve, daemon=True)
            self._thread.start()

            print(f"[INFO] Remote API started at http://{self.host}:{self.port}/api/")
            return True

        except Exception as e:
            print(f"[ERROR] Failed to start remote API: {e}")
            return False

    def stop(self) -> None:
        """Stop the server."""
        if self._server:
            self._server.shutdown()
            self._server = None

    def _serve(self) -> None:
        """Server loop."""
        if self._server:
            self._server.serve_forever()

    def get_status(self) -> ScriptStatus:
        """Get current script status."""
        if self._status.state == ScriptState.RUNNING:
            self._status.elapsed = time.time() - self._status.started_at
        return self._status

    def set_status(self, **kwargs: Any) -> None:
        """Update status fields."""
        for key, value in kwargs.items():
            if hasattr(self._status, key):
                setattr(self._status, key, value)

    def list_scripts(self) -> list[str]:
        """List available scripts."""
        from pathlib import Path

        scripts_path = Path(self._scripts_dir)
        if not scripts_path.exists():
            return []

        return [f.stem for f in scripts_path.glob("*.retro")]

    def start_script(self, name: str) -> bool:
        """Start a script by name."""
        self._status.state = ScriptState.RUNNING
        self._status.script_name = name
        self._status.started_at = time.time()
        self._status.error = None

        if self.on_start:
            self.on_start(name)

        return True

    def stop_script(self) -> None:
        """Stop current script."""
        self._status.state = ScriptState.STOPPED
        self._status.elapsed = time.time() - self._status.started_at

        if self.on_stop:
            self.on_stop()

    def pause_script(self) -> None:
        """Pause current script."""
        self._status.state = ScriptState.PAUSED

        if self.on_pause:
            self.on_pause()

    def resume_script(self) -> None:
        """Resume paused script."""
        self._status.state = ScriptState.RUNNING

    def execute_code(self, code: str) -> Any:
        """Execute inline code."""
        if self.on_execute:
            return self.on_execute(code)
        return None


# Global instance
_controller: RemoteController | None = None


def get_controller() -> RemoteController:
    """Get the default remote controller."""
    global _controller
    if _controller is None:
        _controller = RemoteController()
    return _controller


def start_server(port: int = 8080) -> RemoteController:
    """Start the remote control server."""
    controller = get_controller()
    controller.port = port
    controller.start()
    return controller


def stop_server() -> None:
    """Stop the remote control server."""
    if _controller:
        _controller.stop()


================================================================================
FILE PATH: core\network\websocket.py
LINES: 344
================================================================================

"""
RetroAuto v2 - WebSocket Client

WebSocket communication for real-time features.
Part of RetroScript Phase 16 - Network Features.
"""

from __future__ import annotations

import contextlib
import json
import queue
import threading
import time
from collections.abc import Callable
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Any

# Try to import websocket-client
try:
    import websocket

    HAS_WEBSOCKET = True
except ImportError:
    HAS_WEBSOCKET = False
    websocket = None


class ConnectionState(Enum):
    """WebSocket connection states."""

    DISCONNECTED = auto()
    CONNECTING = auto()
    CONNECTED = auto()
    RECONNECTING = auto()
    ERROR = auto()


@dataclass
class WebSocketMessage:
    """A WebSocket message."""

    data: str | bytes
    is_binary: bool = False
    timestamp: float = field(default_factory=time.time)

    def json(self) -> Any:
        """Parse as JSON."""
        if isinstance(self.data, bytes):
            return json.loads(self.data.decode("utf-8"))
        return json.loads(self.data)


class WebSocketClient:
    """WebSocket client for RetroScript.

    Usage:
        ws = WebSocketClient("wss://example.com/socket")
        ws.on_message = lambda msg: print(f"Received: {msg.data}")
        ws.connect()
        ws.send({"type": "hello"})
    """

    def __init__(
        self,
        url: str,
        auto_reconnect: bool = True,
        reconnect_delay: float = 5.0,
    ) -> None:
        self.url = url
        self.auto_reconnect = auto_reconnect
        self.reconnect_delay = reconnect_delay

        self._ws = None
        self._state = ConnectionState.DISCONNECTED
        self._thread: threading.Thread | None = None
        self._stop_event = threading.Event()
        self._message_queue: queue.Queue[WebSocketMessage] = queue.Queue()

        # Callbacks
        self.on_open: Callable[[], None] | None = None
        self.on_message: Callable[[WebSocketMessage], None] | None = None
        self.on_error: Callable[[str], None] | None = None
        self.on_close: Callable[[], None] | None = None

        if not HAS_WEBSOCKET:
            print("[WARN] websocket-client not installed. Using stub mode.")

    @property
    def state(self) -> ConnectionState:
        """Get current connection state."""
        return self._state

    @property
    def is_connected(self) -> bool:
        """Check if connected."""
        return self._state == ConnectionState.CONNECTED

    def connect(self) -> bool:
        """Connect to WebSocket server.

        Returns:
            True if connection started
        """
        if self._state == ConnectionState.CONNECTED:
            return True

        if not HAS_WEBSOCKET:
            self._state = ConnectionState.CONNECTED
            return True

        self._state = ConnectionState.CONNECTING
        self._stop_event.clear()

        # Start connection thread
        self._thread = threading.Thread(target=self._run, daemon=True)
        self._thread.start()

        return True

    def disconnect(self) -> None:
        """Disconnect from server."""
        self._stop_event.set()
        self.auto_reconnect = False

        if self._ws:
            with contextlib.suppress(Exception):
                self._ws.close()

        self._state = ConnectionState.DISCONNECTED

        if self._thread:
            self._thread.join(timeout=2.0)

    def send(self, data: str | dict | bytes) -> bool:
        """Send data to server.

        Args:
            data: String, dict (JSON), or bytes

        Returns:
            True if sent
        """
        if not self.is_connected:
            return False

        if not HAS_WEBSOCKET or not self._ws:
            print(f"[STUB] WebSocket send: {data}")
            return True

        try:
            if isinstance(data, dict):
                data = json.dumps(data)
            if isinstance(data, bytes):
                self._ws.send(data, opcode=websocket.ABNF.OPCODE_BINARY)
            else:
                self._ws.send(data)
            return True
        except Exception:
            return False

    def send_json(self, data: Any) -> bool:
        """Send JSON data."""
        return self.send(json.dumps(data))

    def receive(self, timeout: float = 1.0) -> WebSocketMessage | None:
        """Receive a message from the queue.

        Args:
            timeout: Max wait time

        Returns:
            Message or None
        """
        try:
            return self._message_queue.get(timeout=timeout)
        except queue.Empty:
            return None

    def _run(self) -> None:
        """WebSocket connection loop."""
        while not self._stop_event.is_set():
            try:
                self._ws = websocket.WebSocketApp(
                    self.url,
                    on_open=self._on_open,
                    on_message=self._on_message,
                    on_error=self._on_error,
                    on_close=self._on_close,
                )

                self._ws.run_forever()

                # Handle reconnection
                if self.auto_reconnect and not self._stop_event.is_set():
                    self._state = ConnectionState.RECONNECTING
                    time.sleep(self.reconnect_delay)
                else:
                    break

            except Exception as e:
                self._state = ConnectionState.ERROR
                if self.on_error:
                    self.on_error(str(e))

                if self.auto_reconnect and not self._stop_event.is_set():
                    time.sleep(self.reconnect_delay)
                else:
                    break

    def _on_open(self, ws) -> None:
        """Handle connection open."""
        self._state = ConnectionState.CONNECTED
        if self.on_open:
            self.on_open()

    def _on_message(self, ws, message) -> None:
        """Handle incoming message."""
        msg = WebSocketMessage(
            data=message,
            is_binary=isinstance(message, bytes),
        )

        # Add to queue
        self._message_queue.put(msg)

        # Call callback
        if self.on_message:
            self.on_message(msg)

    def _on_error(self, ws, error) -> None:
        """Handle error."""
        self._state = ConnectionState.ERROR
        if self.on_error:
            self.on_error(str(error))

    def _on_close(self, ws, close_status_code, close_msg) -> None:
        """Handle connection close."""
        self._state = ConnectionState.DISCONNECTED
        if self.on_close:
            self.on_close()


class WebSocketServer:
    """Simple WebSocket server for remote control.

    Usage:
        server = WebSocketServer(port=8765)
        server.on_message = lambda client, msg: server.broadcast(msg)
        server.start()
    """

    def __init__(self, host: str = "0.0.0.0", port: int = 8765) -> None:
        self.host = host
        self.port = port
        self._clients: list[Any] = []
        self._running = False
        self._thread: threading.Thread | None = None

        # Callbacks
        self.on_client_connect: Callable[[Any], None] | None = None
        self.on_client_disconnect: Callable[[Any], None] | None = None
        self.on_message: Callable[[Any, WebSocketMessage], None] | None = None

    @property
    def is_running(self) -> bool:
        """Check if server is running."""
        return self._running

    @property
    def client_count(self) -> int:
        """Get number of connected clients."""
        return len(self._clients)

    def start(self) -> bool:
        """Start the server.

        Returns:
            True if started
        """
        if self._running:
            return True

        # Server requires asyncio - simplified implementation
        self._running = True
        print(f"[INFO] WebSocket server started on ws://{self.host}:{self.port}")
        return True

    def stop(self) -> None:
        """Stop the server."""
        self._running = False

    def broadcast(self, data: str | dict) -> None:
        """Send message to all clients."""
        if isinstance(data, dict):
            data = json.dumps(data)

        for client in self._clients:
            with contextlib.suppress(Exception):
                client.send(data)

    def send_to(self, client: Any, data: str | dict) -> bool:
        """Send message to specific client."""
        if isinstance(data, dict):
            data = json.dumps(data)

        try:
            client.send(data)
            return True
        except Exception:
            return False


# Convenience functions
_connections: dict[str, WebSocketClient] = {}


def connect(url: str, name: str = "default") -> WebSocketClient:
    """Create and connect a WebSocket client.

    Args:
        url: WebSocket URL
        name: Connection name for later reference

    Returns:
        WebSocketClient instance
    """
    client = WebSocketClient(url)
    client.connect()
    _connections[name] = client
    return client


def get_connection(name: str = "default") -> WebSocketClient | None:
    """Get an existing connection by name."""
    return _connections.get(name)


def disconnect_all() -> None:
    """Disconnect all connections."""
    for client in _connections.values():
        client.disconnect()
    _connections.clear()


================================================================================
FILE PATH: core\package\manager.py
LINES: 180
================================================================================

"""
RetroAuto v2 - Package Manager

Main interface for managing RetroScript packages.
Part of RetroScript Phase 13 - Package Management.
"""

from __future__ import annotations

import shutil
import subprocess
from pathlib import Path

from .manifest import Dependency, Manifest, create_default
from .resolver import DependencyResolver


class PackageManager:
    """RetroScript Package Manager (`retro` package tools)."""

    def __init__(self, root_dir: str | Path = ".") -> None:
        self.root_dir = Path(root_dir).resolve()
        self.packages_dir = self.root_dir / "packages"
        self.manifest_path = self.root_dir / "retro.toml"

        self.resolver = DependencyResolver()

    def init(self, name: str) -> None:
        """Initialize a new package."""
        if self.manifest_path.exists():
            print(f"Package already exists at {self.root_dir}")
            return

        manifest = create_default(name)
        manifest.save(self.manifest_path)
        print(f"Initialized package '{name}' in {self.root_dir}")
        self._create_structure()

    def install(self) -> None:
        """Install all dependencies from manifest."""
        if not self.manifest_path.exists():
            print("No retro.toml found.")
            return

        manifest = Manifest.load(self.manifest_path)
        print(f"Installing dependencies for {manifest.package.name}...")

        self.packages_dir.mkdir(exist_ok=True)

        # Install dependencies
        self._install_list(manifest.dependencies)
        self._install_list(manifest.dev_dependencies, dev=True)

        print("Done.")

    def add(self, name: str, version: str = "*", dev: bool = False, git: str = "") -> None:
        """Add a dependency."""
        if not self.manifest_path.exists():
            print("No retro.toml found.")
            return

        manifest = Manifest.load(self.manifest_path)
        manifest.add_dependency(name, version, dev, git)
        manifest.save(self.manifest_path)

        print(f"Added {name} ({version})")
        self.install()

    def remove(self, name: str) -> None:
        """Remove a dependency."""
        if not self.manifest_path.exists():
            return

        manifest = Manifest.load(self.manifest_path)

        if name in manifest.dependencies:
            del manifest.dependencies[name]
            print(f"Removed {name}")
        elif name in manifest.dev_dependencies:
            del manifest.dev_dependencies[name]
            print(f"Removed {name} (dev)")
        else:
            print(f"Package {name} not found.")
            return

        manifest.save(self.manifest_path)
        self._remove_package_dir(name)

    def _install_list(self, dependencies: dict[str, Dependency], dev: bool = False) -> None:
        """Install a list of dependencies."""
        for name, dep in dependencies.items():
            print(f"  - {name} ({dep.version_req})...")

            if dep.source == "git":
                self._install_git(name, dep.path, dep.git_ref)
            elif dep.source == "local":
                self._install_local(name, dep.path)
            else:
                self._install_registry(name, dep.version_req)

    def _install_git(self, name: str, url: str, ref: str) -> None:
        """Install from Git."""
        target_dir = self.packages_dir / name

        if target_dir.exists():
            # In a real PM, we'd check if it's correct/update it
            return

        try:
            cmd = ["git", "clone", "--depth", "1", url, str(target_dir)]
            if ref:
                cmd = ["git", "clone", "--branch", ref, "--depth", "1", url, str(target_dir)]

            subprocess.run(cmd, check=True, capture_output=True)
        except subprocess.CalledProcessError as e:
            print(f"Failed to clone {name}: {e}")

    def _install_local(self, name: str, path: str) -> None:
        """Install local path (symlink)."""
        target_dir = self.packages_dir / name
        src_path = Path(path).resolve()

        if not src_path.exists():
            print(f"Local path not found: {src_path}")
            return

        if target_dir.exists() or target_dir.is_symlink():
            if target_dir.resolve() == src_path:
                return
            if target_dir.is_symlink():
                target_dir.unlink()
            else:
                shutil.rmtree(target_dir)

        try:
            target_dir.symlink_to(src_path)
        except OSError as e:
            print(f"Failed to link {name}: {e}")

    def _install_registry(self, name: str, version_req: str) -> None:
        """Install from registry (Mock)."""
        # For now, just create a placeholder
        target_dir = self.packages_dir / name
        if target_dir.exists():
            return

        target_dir.mkdir(parents=True)
        manifest = create_default(name)
        manifest.package.description = "Installed from registry (mock)"
        manifest.save(target_dir / "retro.toml")

    def _remove_package_dir(self, name: str) -> None:
        """Remove package directory."""
        target_dir = self.packages_dir / name
        if target_dir.exists() or target_dir.is_symlink():
            if target_dir.is_symlink():
                target_dir.unlink()
            else:
                shutil.rmtree(target_dir)

    def _create_structure(self) -> None:
        """Create package structure."""
        (self.root_dir / "src").mkdir(exist_ok=True)
        (self.root_dir / "tests").mkdir(exist_ok=True)

        main_file = self.root_dir / "src/main.retro"
        if not main_file.exists():
            with open(main_file, "w") as f:
                f.write('flow main() {\n    log("Hello, RetroScript!");\n}\n')


# Global instance
_manager: PackageManager | None = None


def get_manager() -> PackageManager:
    global _manager
    if _manager is None:
        _manager = PackageManager()
    return _manager


================================================================================
FILE PATH: core\package\manifest.py
LINES: 186
================================================================================

"""
RetroAuto v2 - Package Manifest

Structure and parsing for retro.toml package manifests.
Part of RetroScript Phase 13 - Package Management.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

import tomli
import tomli_w


@dataclass
class PackageMetadata:
    """Metadata for a RetroScript package."""

    name: str
    version: str
    description: str = ""
    authors: list[str] = field(default_factory=list)
    license: str = "MIT"
    repository: str = ""
    keywords: list[str] = field(default_factory=list)
    entry_point: str = "main.retro"

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "name": self.name,
            "version": self.version,
            "description": self.description,
            "authors": self.authors,
            "license": self.license,
            "repository": self.repository,
            "keywords": self.keywords,
            "entry_point": self.entry_point,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> PackageMetadata:
        """Create from dictionary."""
        return cls(
            name=data.get("name", "unnamed"),
            version=data.get("version", "0.1.0"),
            description=data.get("description", ""),
            authors=data.get("authors", []),
            license=data.get("license", "MIT"),
            repository=data.get("repository", ""),
            keywords=data.get("keywords", []),
            entry_point=data.get("entry_point", "main.retro"),
        )


@dataclass
class Dependency:
    """A package dependency."""

    name: str
    version_req: str  # e.g. "^1.0.0", ">=1.2.0"
    source: str = "registry"  # registry, git, local
    path: str = ""  # for local/git dependencies
    git_ref: str = ""  # branch/tag/commit

    def to_dict(self) -> str | dict[str, Any]:
        """Convert to dictionary or string (if simple version)."""
        if self.source == "registry":
            return self.version_req

        result = {"version": self.version_req}
        if self.source == "git":
            result["git"] = self.path
            if self.git_ref:
                result["rev"] = self.git_ref
        elif self.source == "local":
            result["path"] = self.path

        return result

    @classmethod
    def from_entry(cls, name: str, entry: str | dict[str, Any]) -> Dependency:
        """Create from TOML entry."""
        if isinstance(entry, str):
            return cls(name=name, version_req=entry)

        version = entry.get("version", "*")

        if "git" in entry:
            return cls(
                name=name,
                version_req=version,
                source="git",
                path=entry["git"],
                git_ref=entry.get("rev", ""),
            )
        elif "path" in entry:
            return cls(
                name=name,
                version_req=version,
                source="local",
                path=entry["path"],
            )

        return cls(name=name, version_req=version)


@dataclass
class Manifest:
    """Complete package manifest (retro.toml)."""

    package: PackageMetadata
    dependencies: dict[str, Dependency]
    dev_dependencies: dict[str, Dependency]

    @classmethod
    def load(cls, path: str | Path) -> Manifest:
        """Load manifest from file."""
        path = Path(path)
        if not path.exists():
            raise FileNotFoundError(f"Manifest not found: {path}")

        with open(path, "rb") as f:
            data = tomli.load(f)

        package_data = data.get("package", {})
        deps_data = data.get("dependencies", {})
        dev_deps_data = data.get("dev-dependencies", {})

        return cls(
            package=PackageMetadata.from_dict(package_data),
            dependencies={k: Dependency.from_entry(k, v) for k, v in deps_data.items()},
            dev_dependencies={k: Dependency.from_entry(k, v) for k, v in dev_deps_data.items()},
        )

    def save(self, path: str | Path) -> None:
        """Save manifest to file."""
        data = {
            "package": self.package.to_dict(),
            "dependencies": {dep.name: dep.to_dict() for dep in self.dependencies.values()},
            "dev-dependencies": {dep.name: dep.to_dict() for dep in self.dev_dependencies.values()},
        }

        with open(path, "wb") as f:
            tomli_w.dump(data, f)

    def add_dependency(
        self,
        name: str,
        version: str = "^0.1.0",
        dev: bool = False,
        git: str = "",
        path: str = "",
    ) -> None:
        """Add a dependency."""
        source = "registry"
        src_path = ""

        if git:
            source = "git"
            src_path = git
        elif path:
            source = "local"
            src_path = path

        dep = Dependency(
            name=name,
            version_req=version,
            source=source,
            path=src_path,
        )

        target = self.dev_dependencies if dev else self.dependencies
        target[name] = dep


def create_default(name: str) -> Manifest:
    """Create a default manifest."""
    return Manifest(
        package=PackageMetadata(name=name, version="0.1.0"),
        dependencies={},
        dev_dependencies={},
    )


================================================================================
FILE PATH: core\package\resolver.py
LINES: 185
================================================================================

"""
RetroAuto v2 - Dependency Resolver

Semantic version checking and dependency resolution.
Part of RetroScript Phase 13 - Package Management.
"""

from __future__ import annotations

import re
from dataclasses import dataclass


@dataclass
class Version:
    """Semantic version (Major.Minor.Patch)."""

    major: int
    minor: int
    patch: int
    pre_release: str = ""
    build: str = ""

    def __str__(self) -> str:
        s = f"{self.major}.{self.minor}.{self.patch}"
        if self.pre_release:
            s += f"-{self.pre_release}"
        if self.build:
            s += f"+{self.build}"
        return s

    def __lt__(self, other: Version) -> bool:
        if self.major != other.major:
            return self.major < other.major
        if self.minor != other.minor:
            return self.minor < other.minor
        if self.patch != other.patch:
            return self.patch < other.patch
        return False  # Simplified pre-release comparison

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Version):
            return False
        return (
            self.major == other.major
            and self.minor == other.minor
            and self.patch == other.patch
            and self.pre_release == other.pre_release
        )

    @classmethod
    def parse(cls, version_str: str) -> Version:
        """Parse semantic version string."""
        # Simple regex for SemVer
        match = re.match(
            r"^(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z-.]+))?(?:\+([0-9A-Za-z-.]+))?$",
            version_str.strip(),
        )
        if not match:
            raise ValueError(f"Invalid version: {version_str}")

        return cls(
            major=int(match.group(1)),
            minor=int(match.group(2)),
            patch=int(match.group(3)),
            pre_release=match.group(4) or "",
            build=match.group(5) or "",
        )


class VersionReq:
    """Version requirement (e.g. ^1.2.0, >=1.0, *)."""

    def __init__(self, req_str: str) -> None:
        self.req_str = req_str
        self.kind = "exact"
        self.version: Version | None = None

        self._parse()

    def _parse(self) -> None:
        s = self.req_str.strip()
        if s == "*":
            self.kind = "any"
            return

        if s.startswith("^"):
            self.kind = "caret"
            self.version = Version.parse(s[1:])
        elif s.startswith("~"):
            self.kind = "tilde"
            self.version = Version.parse(s[1:])
        elif s.startswith(">="):
            self.kind = "gte"
            self.version = Version.parse(s[2:])
        elif s.startswith(">"):
            self.kind = "gt"
            self.version = Version.parse(s[1:])
        elif s.startswith("<="):
            self.kind = "lte"
            self.version = Version.parse(s[2:])
        elif s.startswith("<"):
            self.kind = "lt"
            self.version = Version.parse(s[1:])
        else:
            self.kind = "exact"
            self.version = Version.parse(s)

    def matches(self, version: Version) -> bool:
        """Check if version matches requirement."""
        if self.kind == "any":
            return True

        if not self.version:
            return False

        v = self.version

        if self.kind == "exact":
            return version == v

        elif self.kind == "caret":
            # ^1.2.3 := >=1.2.3 <2.0.0
            if v.major != 0:
                return (version.major == v.major) and (version >= v)
            elif v.minor != 0:
                # ^0.2.3 := >=0.2.3 <0.3.0
                return (version.major == 0) and (version.minor == v.minor) and (version >= v)
            else:
                # ^0.0.3 := 0.0.3
                return version == v

        elif self.kind == "tilde":
            # ~1.2.3 := >=1.2.3 <1.3.0
            return version.major == v.major and version.minor == v.minor and version >= v

        elif self.kind == "gte":
            return version >= v

        elif self.kind == "gt":
            # Since we implemented only <, create proper > logic
            return not (version < v) and version != v

        elif self.kind == "lte":
            return version < v or version == v

        elif self.kind == "lt":
            return version < v

        return False


class DependencyResolver:
    """Dependency resolution logic."""

    def resolve(self, dependencies: dict[str, str]) -> dict[str, Version]:
        """Resolve dependencies (simplified).

        In a real implementation, this would build a graph and handle transitive dependencies.
        For now, we just validate versions.
        """
        resolved = {}

        for name, req_str in dependencies.items():
            # Mock resolution: just pick the required version if exact/caret
            # In real system: query registry, find best match
            req = VersionReq(req_str)
            if req.version:
                resolved[name] = req.version
            else:
                # Fallback for * or unknown
                resolved[name] = Version(0, 0, 0)

        return resolved


# Convenience
def check_version(req: str, version: str) -> bool:
    """Check if version string matches requirement."""
    try:
        r = VersionReq(req)
        v = Version.parse(version)
        return r.matches(v)
    except ValueError:
        return False


================================================================================
FILE PATH: core\plugins\plugin_system.py
LINES: 203
================================================================================

"""
RetroAuto v2 - Plugin System

Plugin infrastructure for extending RetroScript functionality.
Part of RetroScript Phase 4 - Visual IDE + Plugins.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from collections.abc import Callable
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    pass


class PluginEvent(Enum):
    """Events that plugins can hook into."""

    # Lifecycle events
    ON_LOAD = auto()  # Plugin loaded
    ON_UNLOAD = auto()  # Plugin unloaded

    # Script events
    BEFORE_PARSE = auto()  # Before parsing script
    AFTER_PARSE = auto()  # After parsing script
    BEFORE_RUN = auto()  # Before running script
    AFTER_RUN = auto()  # After running script

    # Execution events
    ON_STEP = auto()  # Each step execution
    ON_ERROR = auto()  # Error occurred
    ON_SUCCESS = auto()  # Script completed successfully

    # IDE events
    ON_FILE_OPEN = auto()  # File opened in IDE
    ON_FILE_SAVE = auto()  # File saved in IDE
    ON_CURSOR_CHANGE = auto()  # Cursor position changed


@dataclass
class PluginInfo:
    """Plugin metadata."""

    name: str
    version: str
    author: str = "Unknown"
    description: str = ""
    dependencies: list[str] = field(default_factory=list)


class Plugin(ABC):
    """Base class for all plugins.

    To create a plugin:
    1. Subclass this class
    2. Implement get_info() and on_load()
    3. Register hooks in on_load()

    Example:
        class MyPlugin(Plugin):
            def get_info(self) -> PluginInfo:
                return PluginInfo(
                    name="my-plugin",
                    version="1.0.0",
                    description="My awesome plugin"
                )

            def on_load(self, registry: PluginRegistry) -> None:
                registry.add_hook(PluginEvent.BEFORE_RUN, self.before_run)

            def before_run(self, script: Program) -> None:
                print(f"Running script with {len(script.flows)} flows")
    """

    @abstractmethod
    def get_info(self) -> PluginInfo:
        """Return plugin metadata."""
        ...

    @abstractmethod
    def on_load(self, registry: PluginRegistry) -> None:
        """Called when plugin is loaded. Register hooks here."""
        ...

    def on_unload(self) -> None:  # noqa: B027
        """Called when plugin is unloaded. Clean up resources here.

        Override this method in subclasses to perform cleanup.
        """
        ...


class PluginRegistry:
    """Registry for managing plugins and their hooks.

    Usage:
        registry = PluginRegistry()
        registry.load_plugin(MyPlugin())
        registry.trigger(PluginEvent.BEFORE_RUN, script=program)
    """

    def __init__(self) -> None:
        self._plugins: dict[str, Plugin] = {}
        self._hooks: dict[PluginEvent, list[Callable[..., Any]]] = {
            event: [] for event in PluginEvent
        }

    def load_plugin(self, plugin: Plugin) -> bool:
        """Load a plugin.

        Returns:
            True if loaded successfully, False otherwise
        """
        try:
            info = plugin.get_info()

            # Check if already loaded
            if info.name in self._plugins:
                return False

            # Check dependencies
            for dep in info.dependencies:
                if dep not in self._plugins:
                    raise PluginError(f"Missing dependency: {dep}")

            # Store plugin
            self._plugins[info.name] = plugin

            # Let plugin register hooks
            plugin.on_load(self)

            # Trigger load event
            self.trigger(PluginEvent.ON_LOAD, plugin=plugin)

            return True

        except Exception as e:
            raise PluginError(f"Failed to load plugin: {e}") from e

    def unload_plugin(self, name: str) -> bool:
        """Unload a plugin by name.

        Returns:
            True if unloaded successfully, False otherwise
        """
        if name not in self._plugins:
            return False

        plugin = self._plugins[name]

        # Trigger unload event first
        self.trigger(PluginEvent.ON_UNLOAD, plugin=plugin)

        # Call cleanup
        plugin.on_unload()

        # Remove from registry
        del self._plugins[name]

        return True

    def add_hook(self, event: PluginEvent, callback: Callable[..., Any]) -> None:
        """Register a hook for an event."""
        self._hooks[event].append(callback)

    def remove_hook(self, event: PluginEvent, callback: Callable[..., Any]) -> None:
        """Remove a hook from an event."""
        if callback in self._hooks[event]:
            self._hooks[event].remove(callback)

    def trigger(self, event: PluginEvent, **kwargs: Any) -> list[Any]:
        """Trigger an event and call all registered hooks.

        Returns:
            List of return values from all hooks
        """
        results = []
        for hook in self._hooks[event]:
            try:
                result = hook(**kwargs)
                results.append(result)
            except Exception as e:
                # Log but don't crash on hook errors
                print(f"Hook error: {e}")
        return results

    def get_plugin(self, name: str) -> Plugin | None:
        """Get a loaded plugin by name."""
        return self._plugins.get(name)

    def list_plugins(self) -> list[PluginInfo]:
        """List all loaded plugins."""
        return [p.get_info() for p in self._plugins.values()]


class PluginError(Exception):
    """Error during plugin operations."""

    pass


================================================================================
FILE PATH: core\runtime\hot_reload.py
LINES: 241
================================================================================

"""
RetroAuto v2 - Hot Reload

Live code updates without restarting scripts.
Part of RetroScript Phase 8 - Runtime + Distribution.
"""

from __future__ import annotations

import hashlib
import time
from collections.abc import Callable
from dataclasses import dataclass
from pathlib import Path
from threading import Event, Thread
from typing import Any


@dataclass
class WatchedFile:
    """A file being watched for changes."""

    path: Path
    last_hash: str = ""
    last_modified: float = 0.0


@dataclass
class ReloadEvent:
    """Event fired when a file changes."""

    path: Path
    event_type: str  # "modified", "created", "deleted"
    timestamp: float


class FileWatcher:
    """Watch files for changes.

    Usage:
        watcher = FileWatcher()
        watcher.add("script.retro")
        watcher.on_change = lambda e: print(f"Changed: {e.path}")
        watcher.start()
    """

    def __init__(self, poll_interval: float = 0.5) -> None:
        self._files: dict[str, WatchedFile] = {}
        self._poll_interval = poll_interval
        self._running = False
        self._stop_event = Event()
        self._thread: Thread | None = None

        # Callbacks
        self.on_change: Callable[[ReloadEvent], None] | None = None

    def add(self, path: str | Path) -> None:
        """Add a file to watch."""
        path = Path(path)
        if not path.exists():
            return

        file_hash = self._get_file_hash(path)
        self._files[str(path)] = WatchedFile(
            path=path,
            last_hash=file_hash,
            last_modified=path.stat().st_mtime,
        )

    def remove(self, path: str | Path) -> None:
        """Remove a file from watching."""
        path_str = str(Path(path))
        if path_str in self._files:
            del self._files[path_str]

    def add_directory(self, directory: str | Path, pattern: str = "*.retro") -> None:
        """Add all matching files in a directory."""
        dir_path = Path(directory)
        for file_path in dir_path.glob(pattern):
            self.add(file_path)

    def start(self) -> None:
        """Start watching for changes."""
        if self._running:
            return

        self._running = True
        self._stop_event.clear()
        self._thread = Thread(target=self._watch_loop, daemon=True)
        self._thread.start()

    def stop(self) -> None:
        """Stop watching for changes."""
        self._running = False
        self._stop_event.set()
        if self._thread:
            self._thread.join(timeout=2.0)
            self._thread = None

    def _watch_loop(self) -> None:
        """Main watch loop running in background thread."""
        while self._running and not self._stop_event.is_set():
            self._check_files()
            self._stop_event.wait(self._poll_interval)

    def _check_files(self) -> None:
        """Check all watched files for changes."""
        for path_str, watched in list(self._files.items()):
            try:
                if not watched.path.exists():
                    # File deleted
                    self._fire_event(watched.path, "deleted")
                    del self._files[path_str]
                    continue

                current_mtime = watched.path.stat().st_mtime
                if current_mtime > watched.last_modified:
                    # File modified - verify with hash
                    current_hash = self._get_file_hash(watched.path)
                    if current_hash != watched.last_hash:
                        watched.last_hash = current_hash
                        watched.last_modified = current_mtime
                        self._fire_event(watched.path, "modified")

            except Exception:
                pass  # Ignore file access errors

    def _fire_event(self, path: Path, event_type: str) -> None:
        """Fire a change event."""
        if self.on_change:
            event = ReloadEvent(
                path=path,
                event_type=event_type,
                timestamp=time.time(),
            )
            self.on_change(event)

    def _get_file_hash(self, path: Path) -> str:
        """Get hash of file contents."""
        try:
            content = path.read_bytes()
            return hashlib.md5(content).hexdigest()
        except Exception:
            return ""


class HotReloader:
    """Hot reload manager for RetroScript.

    Usage:
        reloader = HotReloader()
        reloader.watch("main.retro")
        reloader.on_reload = lambda path: print(f"Reloaded: {path}")
        reloader.start()
    """

    def __init__(self) -> None:
        self._watcher = FileWatcher()
        self._watcher.on_change = self._handle_change
        self._state: dict[str, Any] = {}  # Preserved state between reloads
        self._reload_count = 0

        # Callbacks
        self.on_reload: Callable[[Path], None] | None = None
        self.on_error: Callable[[Path, Exception], None] | None = None
        self.before_reload: Callable[[Path], dict[str, Any] | None] | None = None
        self.after_reload: Callable[[Path, dict[str, Any] | None], None] | None = None

    def watch(self, path: str | Path) -> None:
        """Add a file to watch for changes."""
        self._watcher.add(path)

    def watch_directory(self, directory: str | Path, pattern: str = "*.retro") -> None:
        """Watch all matching files in a directory."""
        self._watcher.add_directory(directory, pattern)

    def start(self) -> None:
        """Start hot reload watching."""
        self._watcher.start()

    def stop(self) -> None:
        """Stop hot reload watching."""
        self._watcher.stop()

    def get_state(self) -> dict[str, Any]:
        """Get preserved state."""
        return self._state.copy()

    def set_state(self, key: str, value: Any) -> None:
        """Set state to preserve across reloads."""
        self._state[key] = value

    def get_reload_count(self) -> int:
        """Get total reload count."""
        return self._reload_count

    def _handle_change(self, event: ReloadEvent) -> None:
        """Handle file change event."""
        if event.event_type != "modified":
            return

        try:
            # Save state before reload
            saved_state = None
            if self.before_reload:
                saved_state = self.before_reload(event.path)

            # Perform reload
            self._reload_count += 1

            # Notify
            if self.on_reload:
                self.on_reload(event.path)

            # Restore state after reload
            if self.after_reload:
                self.after_reload(event.path, saved_state)

        except Exception as e:
            if self.on_error:
                self.on_error(event.path, e)


def watch_and_reload(
    path: str | Path,
    on_reload: Callable[[Path], None],
) -> HotReloader:
    """Convenience function to start watching a file.

    Args:
        path: File to watch
        on_reload: Callback when file changes

    Returns:
        HotReloader instance
    """
    reloader = HotReloader()
    reloader.watch(path)
    reloader.on_reload = on_reload
    reloader.start()
    return reloader


================================================================================
FILE PATH: core\runtime\profiler.py
LINES: 264
================================================================================

"""
RetroAuto v2 - Script Profiler

Performance timing and bottleneck detection for RetroScript.
Part of RetroScript Phase 8 - Runtime + Distribution.
"""

from __future__ import annotations

import time
from collections import defaultdict
from collections.abc import Callable
from dataclasses import dataclass, field
from typing import Any


@dataclass
class TimingEntry:
    """A single timing measurement."""

    name: str
    start_time: float
    end_time: float = 0.0
    children: list[TimingEntry] = field(default_factory=list)

    @property
    def duration(self) -> float:
        """Get duration in milliseconds."""
        return (self.end_time - self.start_time) * 1000

    @property
    def self_time(self) -> float:
        """Get self-time excluding children."""
        child_time = sum(c.duration for c in self.children)
        return self.duration - child_time


@dataclass
class ProfileStats:
    """Aggregated statistics for a profiled item."""

    name: str
    call_count: int = 0
    total_time: float = 0.0  # ms
    min_time: float = float("inf")
    max_time: float = 0.0
    avg_time: float = 0.0

    def update(self, duration: float) -> None:
        """Update stats with new measurement."""
        self.call_count += 1
        self.total_time += duration
        self.min_time = min(self.min_time, duration)
        self.max_time = max(self.max_time, duration)
        self.avg_time = self.total_time / self.call_count


class Profiler:
    """Script profiler for performance analysis.

    Usage:
        profiler = Profiler()

        with profiler.measure("my_operation"):
            do_something()

        # Or manually
        profiler.start("operation")
        do_something()
        profiler.stop("operation")

        report = profiler.get_report()
    """

    def __init__(self) -> None:
        self._entries: list[TimingEntry] = []
        self._stack: list[TimingEntry] = []
        self._stats: dict[str, ProfileStats] = defaultdict(lambda: ProfileStats(name=""))
        self._enabled = True
        self._start_time = 0.0

    def enable(self) -> None:
        """Enable profiling."""
        self._enabled = True

    def disable(self) -> None:
        """Disable profiling."""
        self._enabled = False

    def reset(self) -> None:
        """Reset all profiling data."""
        self._entries.clear()
        self._stack.clear()
        self._stats.clear()
        self._start_time = time.perf_counter()

    def start(self, name: str) -> None:
        """Start timing a named section."""
        if not self._enabled:
            return

        entry = TimingEntry(name=name, start_time=time.perf_counter())

        if self._stack:
            self._stack[-1].children.append(entry)
        else:
            self._entries.append(entry)

        self._stack.append(entry)

    def stop(self, name: str | None = None) -> float:
        """Stop timing the current or named section.

        Returns:
            Duration in milliseconds
        """
        if not self._enabled or not self._stack:
            return 0.0

        entry = self._stack.pop()
        entry.end_time = time.perf_counter()

        # Verify name matches if provided
        if name and entry.name != name:
            # Push back and report error
            self._stack.append(entry)
            return 0.0

        # Update stats
        stats = self._stats[entry.name]
        stats.name = entry.name
        stats.update(entry.duration)

        return entry.duration

    def measure(self, name: str) -> ProfileContext:
        """Context manager for measuring a section.

        Usage:
            with profiler.measure("operation"):
                do_something()
        """
        return ProfileContext(self, name)

    def get_stats(self, name: str) -> ProfileStats | None:
        """Get statistics for a named item."""
        return self._stats.get(name)

    def get_all_stats(self) -> dict[str, ProfileStats]:
        """Get all collected statistics."""
        return dict(self._stats)

    def get_hotspots(self, top_n: int = 10) -> list[ProfileStats]:
        """Get the top N hotspots by total time."""
        sorted_stats = sorted(
            self._stats.values(),
            key=lambda s: s.total_time,
            reverse=True,
        )
        return sorted_stats[:top_n]

    def get_report(self) -> str:
        """Generate a human-readable profile report."""
        lines: list[str] = []
        lines.append("=" * 60)
        lines.append("PROFILE REPORT")
        lines.append("=" * 60)

        if not self._stats:
            lines.append("No profiling data collected.")
            return "\n".join(lines)

        # Summary
        total_time = sum(s.total_time for s in self._stats.values())
        total_calls = sum(s.call_count for s in self._stats.values())
        lines.append(f"Total time: {total_time:.2f}ms")
        lines.append(f"Total calls: {total_calls}")
        lines.append("")

        # Top hotspots
        lines.append("TOP HOTSPOTS:")
        lines.append("-" * 60)
        lines.append(f"{'Name':<30} {'Calls':>8} {'Total':>10} {'Avg':>10}")
        lines.append("-" * 60)

        for stats in self.get_hotspots():
            pct = (stats.total_time / total_time * 100) if total_time else 0
            lines.append(
                f"{stats.name:<30} "
                f"{stats.call_count:>8} "
                f"{stats.total_time:>9.2f}ms "
                f"{stats.avg_time:>9.2f}ms "
                f"({pct:.1f}%)"
            )

        lines.append("=" * 60)
        return "\n".join(lines)

    def get_flame_data(self) -> list[dict[str, Any]]:
        """Get data suitable for flame graph visualization."""

        def entry_to_dict(entry: TimingEntry, depth: int = 0) -> dict[str, Any]:
            return {
                "name": entry.name,
                "duration": entry.duration,
                "self_time": entry.self_time,
                "depth": depth,
                "children": [entry_to_dict(c, depth + 1) for c in entry.children],
            }

        return [entry_to_dict(e) for e in self._entries]


class ProfileContext:
    """Context manager for profiling a code section."""

    def __init__(self, profiler: Profiler, name: str) -> None:
        self._profiler = profiler
        self._name = name

    def __enter__(self) -> ProfileContext:
        self._profiler.start(self._name)
        return self

    def __exit__(self, *args: Any) -> None:
        self._profiler.stop(self._name)


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Decorators for function profiling
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

_default_profiler = Profiler()


def profile(name: str | None = None) -> Callable:
    """Decorator to profile a function.

    Usage:
        @profile("my_function")
        def my_function():
            ...

        # Or use function name
        @profile()
        def my_function():
            ...
    """

    def decorator(func: Callable) -> Callable:
        func_name = name or func.__name__

        def wrapper(*args: Any, **kwargs: Any) -> Any:
            with _default_profiler.measure(func_name):
                return func(*args, **kwargs)

        return wrapper

    return decorator


def get_profiler() -> Profiler:
    """Get the default profiler instance."""
    return _default_profiler


================================================================================
FILE PATH: core\script\__init__.py
LINES: 1
================================================================================

"""RetroAuto v2 - Script IO package."""


================================================================================
FILE PATH: core\script\io.py
LINES: 155
================================================================================

"""
RetroAuto v2 - Script YAML IO

Load and save scripts with validation and clear error messages.
"""

from pathlib import Path
from typing import Any

from pydantic import ValidationError
from ruamel.yaml import YAML

from core.models import Script
from infra import get_logger

logger = get_logger("ScriptIO")

# Configure ruamel.yaml for round-trip preservation
yaml = YAML()
yaml.preserve_quotes = True
yaml.default_flow_style = False


class ScriptLoadError(Exception):
    """Error loading script."""

    def __init__(self, message: str, errors: list[str] | None = None) -> None:
        super().__init__(message)
        self.errors = errors or []


class ScriptSaveError(Exception):
    """Error saving script."""

    pass


def load_script(path: Path | str) -> Script:
    """
    Load and validate a script from YAML file.

    Args:
        path: Path to script.yaml

    Returns:
        Validated Script object

    Raises:
        ScriptLoadError: If file not found, invalid YAML, or validation fails
    """
    path = Path(path)

    if not path.exists():
        raise ScriptLoadError(f"File not found: {path}")

    try:
        with open(path, encoding="utf-8") as f:
            data = yaml.load(f)
    except Exception as e:
        raise ScriptLoadError(f"Invalid YAML: {e}") from e

    if data is None:
        data = {}

    try:
        script = Script.model_validate(data)
    except ValidationError as e:
        errors = []
        for err in e.errors():
            loc = ".".join(str(x) for x in err["loc"])
            msg = err["msg"]
            errors.append(f"{loc}: {msg}")
        raise ScriptLoadError("Validation failed", errors) from None

    # Validate references
    ref_errors = script.validate_references()
    if ref_errors:
        raise ScriptLoadError("Invalid references", ref_errors)

    logger.info(
        "Loaded script: %s (%d assets, %d flows)", path.name, len(script.assets), len(script.flows)
    )
    return script


def save_script(script: Script, path: Path | str) -> None:
    """
    Save script to YAML file.

    Args:
        script: Script to save
        path: Destination path

    Raises:
        ScriptSaveError: If write fails
    """
    path = Path(path)

    # Ensure parent directory exists
    path.parent.mkdir(parents=True, exist_ok=True)

    try:
        # Convert to dict - don't exclude defaults to preserve discriminator 'action' field
        data = script.model_dump(mode="json")

        with open(path, "w", encoding="utf-8") as f:
            yaml.dump(data, f)

        logger.info("Saved script: %s", path)
    except Exception as e:
        raise ScriptSaveError(f"Failed to save: {e}") from e


def create_empty_script(name: str = "Untitled") -> Script:
    """Create a new empty script with default flow."""
    from core.models import Flow

    return Script(
        name=name,
        flows=[Flow(name="main", actions=[])],
        main_flow="main",
    )


def load_script_dict(data: dict[str, Any]) -> Script:
    """
    Load script from dictionary (for programmatic creation).

    Args:
        data: Script data dictionary

    Returns:
        Validated Script object
    """
    try:
        script = Script.model_validate(data)
    except ValidationError as e:
        errors = [f"{'.'.join(str(x) for x in err['loc'])}: {err['msg']}" for err in e.errors()]
        raise ScriptLoadError("Validation failed", errors) from None

    ref_errors = script.validate_references()
    if ref_errors:
        raise ScriptLoadError("Invalid references", ref_errors)

    return script


def script_to_yaml_string(script: Script) -> str:
    """Convert script to YAML string."""
    import io

    data = script.model_dump(mode="json")
    stream = io.StringIO()
    yaml.dump(data, stream)
    return stream.getvalue()


================================================================================
FILE PATH: core\security\policy.py
LINES: 86
================================================================================

"""
RetroAuto v2 - Security Sandbox

Defines permissions and security policy for script execution.
Part of RetroScript Phase 15 - Security.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Flag, auto


class Permission(Flag):
    """Security permissions for RetroScript."""

    NONE = 0

    # Filesystem
    FS_READ = auto()
    FS_WRITE = auto()
    FS_DELETE = auto()
    FS_ALL = FS_READ | FS_WRITE | FS_DELETE

    # Network
    NET_HTTP = auto()
    NET_WEBSOCKET = auto()
    NET_ALL = NET_HTTP | NET_WEBSOCKET

    # System
    SHELL_EXEC = auto()  # Run external commands
    ENV_READ = auto()  # Read environment variables

    # Input/Output
    INPUT_CONTROL = auto()  # Mouse/Keyboard simulation
    SCREEN_READ = auto()  # Take screenshots

    # Meta
    UNSAFE = FS_ALL | NET_ALL | SHELL_EXEC | ENV_READ | INPUT_CONTROL | SCREEN_READ


class SecurityViolation(Exception):
    """Raised when a script attempts an unauthorized action."""

    pass


@dataclass
class SecurityPolicy:
    """Policy enforcing permissions for the runtime."""

    permissions: Permission = Permission.NONE
    allowed_domains: set[str] = field(default_factory=set)
    allowed_paths: set[str] = field(default_factory=set)
    max_execution_time_sec: float = 0  # 0 = unlimited
    max_memory_mb: int = 0  # 0 = unlimited

    @classmethod
    def default(cls) -> SecurityPolicy:
        """Default policy (Safe mode)."""
        return cls(permissions=Permission.NONE)

    @classmethod
    def unsafe(cls) -> SecurityPolicy:
        """Unsafe policy (Development mode)."""
        return cls(permissions=Permission.UNSAFE)

    def check(self, permission: Permission) -> None:
        """Check if permission is granted."""
        if not (self.permissions & permission):
            raise SecurityViolation(f"Permission denied: {permission.name}")

    def check_network(self, url: str) -> None:
        """Check if network access to URL is allowed."""
        self.check(Permission.NET_HTTP)
        # In a real implementation, we would check allowed_domains here
        # For now, simplistic check
        pass

    def check_fs(self, path: str, write: bool = False) -> None:
        """Check if filesystem access is allowed."""
        if write:
            self.check(Permission.FS_WRITE)
        else:
            self.check(Permission.FS_READ)
        # Filter by allowed_paths if restricted


================================================================================
FILE PATH: core\testing\runner.py
LINES: 580
================================================================================

"""
RetroAuto v2 - Test Runner

Test discovery, execution, and reporting for RetroScript.
Part of RetroScript Phase 11 - Test Runner.
"""

from __future__ import annotations

import time
from collections.abc import Callable
from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path
from typing import Any
from xml.etree import ElementTree as ET


class TestStatus(Enum):
    """Test result status."""

    PASSED = auto()
    FAILED = auto()
    SKIPPED = auto()
    ERROR = auto()


@dataclass
class TestCase:
    """A single test case."""

    name: str
    file: str = ""
    line: int = 0
    status: TestStatus = TestStatus.PASSED
    duration: float = 0.0
    message: str = ""
    error: str | None = None


@dataclass
class TestSuite:
    """Collection of test cases."""

    name: str
    tests: list[TestCase] = field(default_factory=list)
    start_time: float = 0.0
    end_time: float = 0.0

    @property
    def total(self) -> int:
        return len(self.tests)

    @property
    def passed(self) -> int:
        return sum(1 for t in self.tests if t.status == TestStatus.PASSED)

    @property
    def failed(self) -> int:
        return sum(1 for t in self.tests if t.status == TestStatus.FAILED)

    @property
    def skipped(self) -> int:
        return sum(1 for t in self.tests if t.status == TestStatus.SKIPPED)

    @property
    def errors(self) -> int:
        return sum(1 for t in self.tests if t.status == TestStatus.ERROR)

    @property
    def duration(self) -> float:
        return self.end_time - self.start_time


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Mock System
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


@dataclass
class MockCall:
    """Record of a mock function call."""

    name: str
    args: tuple[Any, ...]
    kwargs: dict[str, Any]
    timestamp: float


class MockRegistry:
    """Registry for mock functions.

    Usage:
        mocks = MockRegistry()
        mocks.register("find", lambda target: {"x": 100, "y": 100})
        result = mocks.call("find", "button.png")
    """

    def __init__(self) -> None:
        self._mocks: dict[str, Callable[..., Any]] = {}
        self._calls: list[MockCall] = []
        self._return_values: dict[str, Any] = {}

    def register(self, name: str, func: Callable[..., Any] | None = None) -> None:
        """Register a mock function.

        Args:
            name: Function name to mock
            func: Mock implementation (optional)
        """
        self._mocks[name] = func or (lambda *a, **kw: None)

    def set_return(self, name: str, value: Any) -> None:
        """Set return value for a mock.

        Args:
            name: Function name
            value: Value to return
        """
        self._return_values[name] = value
        self._mocks[name] = lambda *a, **kw: value

    def is_mocked(self, name: str) -> bool:
        """Check if function is mocked."""
        return name in self._mocks

    def call(self, name: str, *args: Any, **kwargs: Any) -> Any:
        """Call a mock function.

        Args:
            name: Function name
            *args: Positional arguments
            **kwargs: Keyword arguments

        Returns:
            Mock return value
        """
        # Record call
        self._calls.append(
            MockCall(
                name=name,
                args=args,
                kwargs=kwargs,
                timestamp=time.time(),
            )
        )

        # Return fixed value if set
        if name in self._return_values:
            return self._return_values[name]

        # Call mock implementation
        if name in self._mocks:
            return self._mocks[name](*args, **kwargs)

        return None

    def get_calls(self, name: str | None = None) -> list[MockCall]:
        """Get recorded calls.

        Args:
            name: Filter by function name (optional)

        Returns:
            List of mock calls
        """
        if name:
            return [c for c in self._calls if c.name == name]
        return self._calls.copy()

    def call_count(self, name: str) -> int:
        """Get number of calls to a function."""
        return sum(1 for c in self._calls if c.name == name)

    def was_called(self, name: str) -> bool:
        """Check if function was called."""
        return any(c.name == name for c in self._calls)

    def was_called_with(self, name: str, *args: Any, **kwargs: Any) -> bool:
        """Check if function was called with specific arguments."""
        for call in self._calls:
            if call.name == name and call.args == args and call.kwargs == kwargs:
                return True
        return False

    def reset(self) -> None:
        """Reset all mocks and call history."""
        self._mocks.clear()
        self._calls.clear()
        self._return_values.clear()


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Assertions
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class AssertionError(Exception):
    """Test assertion failure."""

    def __init__(self, message: str, expected: Any = None, actual: Any = None) -> None:
        self.expected = expected
        self.actual = actual
        super().__init__(message)


def assert_true(condition: Any, message: str = "") -> None:
    """Assert that condition is truthy."""
    if not condition:
        raise AssertionError(message or "Expected truthy value", True, condition)


def assert_false(condition: Any, message: str = "") -> None:
    """Assert that condition is falsy."""
    if condition:
        raise AssertionError(message or "Expected falsy value", False, condition)


def assert_equal(expected: Any, actual: Any, message: str = "") -> None:
    """Assert that values are equal."""
    if expected != actual:
        raise AssertionError(
            message or f"Expected {expected!r}, got {actual!r}",
            expected,
            actual,
        )


def assert_not_equal(expected: Any, actual: Any, message: str = "") -> None:
    """Assert that values are not equal."""
    if expected == actual:
        raise AssertionError(
            message or f"Expected value different from {expected!r}",
            f"not {expected!r}",
            actual,
        )


def assert_null(value: Any, message: str = "") -> None:
    """Assert that value is null/None."""
    if value is not None:
        raise AssertionError(message or f"Expected null, got {value!r}", None, value)


def assert_not_null(value: Any, message: str = "") -> None:
    """Assert that value is not null/None."""
    if value is None:
        raise AssertionError(message or "Expected non-null value", "not null", None)


def assert_in(item: Any, container: Any, message: str = "") -> None:
    """Assert that item is in container."""
    if item not in container:
        raise AssertionError(
            message or f"Expected {item!r} in {container!r}",
            f"{item} in container",
            f"{item} not in container",
        )


def assert_not_in(item: Any, container: Any, message: str = "") -> None:
    """Assert that item is not in container."""
    if item in container:
        raise AssertionError(
            message or f"Expected {item!r} not in {container!r}",
            f"{item} not in container",
            f"{item} in container",
        )


def assert_greater(value: Any, threshold: Any, message: str = "") -> None:
    """Assert that value > threshold."""
    if not value > threshold:
        raise AssertionError(
            message or f"Expected {value!r} > {threshold!r}",
            f">{threshold}",
            value,
        )


def assert_less(value: Any, threshold: Any, message: str = "") -> None:
    """Assert that value < threshold."""
    if not value < threshold:
        raise AssertionError(
            message or f"Expected {value!r} < {threshold!r}",
            f"<{threshold}",
            value,
        )


def assert_type(value: Any, expected_type: type, message: str = "") -> None:
    """Assert that value is of expected type."""
    if not isinstance(value, expected_type):
        raise AssertionError(
            message or f"Expected type {expected_type.__name__}, got {type(value).__name__}",
            expected_type.__name__,
            type(value).__name__,
        )


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Test Runner
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


class TestRunner:
    """Test runner for RetroScript tests.

    Usage:
        runner = TestRunner()
        suite = runner.run_file("tests/test_combat.retro")
        print(runner.format_results(suite))
    """

    def __init__(self) -> None:
        self.mocks = MockRegistry()
        self._suites: list[TestSuite] = []

    def discover(self, path: str | Path, pattern: str = "*_test.retro") -> list[Path]:
        """Discover test files.

        Args:
            path: Directory to search
            pattern: File pattern to match

        Returns:
            List of test file paths
        """
        path = Path(path)
        if path.is_file():
            return [path]

        files: list[Path] = []
        files.extend(path.glob(f"**/{pattern}"))
        files.extend(path.glob("**/test_*.retro"))
        return sorted(set(files))

    def run_file(self, path: str | Path) -> TestSuite:
        """Run tests in a single file.

        Args:
            path: Path to test file

        Returns:
            TestSuite with results
        """
        path = Path(path)
        suite = TestSuite(name=path.stem)
        suite.start_time = time.time()

        try:
            source = path.read_text(encoding="utf-8")
            tests = self._extract_tests(source, str(path))

            for test in tests:
                result = self._run_test(test, source)
                suite.tests.append(result)

        except Exception as e:
            suite.tests.append(
                TestCase(
                    name="<file>",
                    file=str(path),
                    status=TestStatus.ERROR,
                    error=str(e),
                )
            )

        suite.end_time = time.time()
        self._suites.append(suite)
        return suite

    def run_all(self, path: str | Path, pattern: str = "*_test.retro") -> list[TestSuite]:
        """Run all tests in a directory.

        Args:
            path: Directory path
            pattern: File pattern

        Returns:
            List of TestSuites
        """
        files = self.discover(path, pattern)
        suites = []
        for file in files:
            suite = self.run_file(file)
            suites.append(suite)
        return suites

    def _extract_tests(self, source: str, file: str) -> list[dict[str, Any]]:
        """Extract @test blocks from source."""
        import re

        tests = []
        pattern = r'@test\s+"([^"]+)"\s*\{([^}]*)\}'

        for match in re.finditer(pattern, source, re.MULTILINE | re.DOTALL):
            name = match.group(1)
            body = match.group(2)
            line = source[: match.start()].count("\n") + 1

            tests.append(
                {
                    "name": name,
                    "body": body,
                    "line": line,
                    "file": file,
                }
            )

        return tests

    def _run_test(self, test: dict[str, Any], source: str) -> TestCase:
        """Run a single test."""
        start = time.time()
        result = TestCase(
            name=test["name"],
            file=test["file"],
            line=test["line"],
        )

        try:
            # Reset mocks for each test
            self.mocks.reset()

            # Execute test body
            # TODO: Integrate with interpreter
            # For now, just mark as passed
            result.status = TestStatus.PASSED

        except AssertionError as e:
            result.status = TestStatus.FAILED
            result.message = str(e)

        except Exception as e:
            result.status = TestStatus.ERROR
            result.error = str(e)

        result.duration = time.time() - start
        return result

    def format_results(self, suite: TestSuite) -> str:
        """Format test results for console."""
        lines = []
        lines.append(f"\n{'='*60}")
        lines.append(f"Test Suite: {suite.name}")
        lines.append(f"{'='*60}\n")

        for test in suite.tests:
            status_icon = {
                TestStatus.PASSED: "‚úì",
                TestStatus.FAILED: "‚úó",
                TestStatus.SKIPPED: "‚óã",
                TestStatus.ERROR: "!",
            }.get(test.status, "?")

            lines.append(f"  {status_icon} {test.name} ({test.duration:.3f}s)")

            if test.message:
                lines.append(f"      {test.message}")
            if test.error:
                lines.append(f"      Error: {test.error}")

        lines.append(f"\n{'-'*60}")
        lines.append(
            f"Total: {suite.total} | "
            f"Passed: {suite.passed} | "
            f"Failed: {suite.failed} | "
            f"Errors: {suite.errors} | "
            f"Skipped: {suite.skipped}"
        )
        lines.append(f"Duration: {suite.duration:.3f}s")
        lines.append(f"{'='*60}\n")

        return "\n".join(lines)

    def to_junit_xml(self, suites: list[TestSuite]) -> str:
        """Generate JUnit XML report."""
        root = ET.Element("testsuites")

        for suite in suites:
            suite_elem = ET.SubElement(root, "testsuite")
            suite_elem.set("name", suite.name)
            suite_elem.set("tests", str(suite.total))
            suite_elem.set("failures", str(suite.failed))
            suite_elem.set("errors", str(suite.errors))
            suite_elem.set("time", f"{suite.duration:.3f}")

            for test in suite.tests:
                test_elem = ET.SubElement(suite_elem, "testcase")
                test_elem.set("name", test.name)
                test_elem.set("time", f"{test.duration:.3f}")

                if test.status == TestStatus.FAILED:
                    failure = ET.SubElement(test_elem, "failure")
                    failure.set("message", test.message)

                elif test.status == TestStatus.ERROR:
                    error = ET.SubElement(test_elem, "error")
                    error.set("message", test.error or "Unknown error")

                elif test.status == TestStatus.SKIPPED:
                    ET.SubElement(test_elem, "skipped")

        return ET.tostring(root, encoding="unicode")

    def to_html(self, suites: list[TestSuite]) -> str:
        """Generate HTML report."""
        total_tests = sum(s.total for s in suites)
        total_passed = sum(s.passed for s in suites)
        total_failed = sum(s.failed for s in suites)
        total_errors = sum(s.errors for s in suites)

        html = f"""<!DOCTYPE html>
<html>
<head>
    <title>RetroScript Test Report</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, sans-serif; margin: 40px; }}
        .summary {{ background: #f5f5f5; padding: 20px; border-radius: 8px; margin-bottom: 20px; }}
        .passed {{ color: #22c55e; }}
        .failed {{ color: #ef4444; }}
        .error {{ color: #f59e0b; }}
        .suite {{ border: 1px solid #ddd; border-radius: 8px; margin-bottom: 20px; overflow: hidden; }}
        .suite-header {{ background: #f0f0f0; padding: 15px; font-weight: bold; }}
        .test {{ padding: 10px 15px; border-top: 1px solid #eee; }}
        .test.passed {{ border-left: 4px solid #22c55e; }}
        .test.failed {{ border-left: 4px solid #ef4444; }}
        .test.error {{ border-left: 4px solid #f59e0b; }}
        .message {{ color: #666; font-size: 0.9em; margin-top: 5px; }}
    </style>
</head>
<body>
    <h1>RetroScript Test Report</h1>
    <div class="summary">
        <strong>Total:</strong> {total_tests} |
        <span class="passed">Passed: {total_passed}</span> |
        <span class="failed">Failed: {total_failed}</span> |
        <span class="error">Errors: {total_errors}</span>
    </div>
"""
        for suite in suites:
            html += f"""
    <div class="suite">
        <div class="suite-header">{suite.name} ({suite.total} tests)</div>
"""
            for test in suite.tests:
                status = test.status.name.lower()
                icon = "‚úì" if test.status == TestStatus.PASSED else "‚úó"
                html += f"""
        <div class="test {status}">
            {icon} {test.name} <span style="color:#999">({test.duration:.3f}s)</span>
"""
                if test.message:
                    html += f'            <div class="message">{test.message}</div>\n'
                if test.error:
                    html += f'            <div class="message">Error: {test.error}</div>\n'
                html += "        </div>\n"

            html += "    </div>\n"

        html += """
</body>
</html>"""
        return html


# Convenience function
def run_tests(path: str | Path) -> TestSuite:
    """Run tests in a file or directory."""
    runner = TestRunner()
    if Path(path).is_file():
        return runner.run_file(path)
    else:
        suites = runner.run_all(path)
        # Return combined suite
        combined = TestSuite(name=str(path))
        for s in suites:
            combined.tests.extend(s.tests)
        return combined


================================================================================
FILE PATH: core\validation\__init__.py
LINES: 4
================================================================================

# Validation module
from core.validation.assets import get_referenced_assets, validate_assets

__all__ = ["validate_assets", "get_referenced_assets"]


================================================================================
FILE PATH: core\validation\assets.py
LINES: 73
================================================================================

"""
Asset validation utilities.

Validates that all assets referenced by a script exist before execution.
"""

from pathlib import Path

from core.models import Action, Flow, Script
from infra import get_logger

logger = get_logger("AssetValidator")


def get_referenced_assets(flow: Flow) -> set[str]:
    """Extract all asset IDs referenced by a flow."""
    assets = set()

    def scan_actions(actions: list[Action]):
        for action in actions:
            # Check if action has asset_id field
            if hasattr(action, "asset_id") and action.asset_id:
                assets.add(action.asset_id)

            # Recursively scan nested actions
            if hasattr(action, "then_actions"):
                scan_actions(action.then_actions)
            if hasattr(action, "else_actions"):
                scan_actions(action.else_actions)
            if hasattr(action, "do_actions") and action.do_actions:
                scan_actions(action.do_actions)

    scan_actions(flow.actions)
    return assets


def validate_assets(script: Script, assets_dir: Path) -> tuple[bool, list[str]]:
    """
    Validate all assets referenced by script exist.

    Returns:
        (all_valid, missing_assets)
    """
    missing = []

    # Collect all referenced assets
    all_assets = set()
    for flow in script.flows:
        all_assets.update(get_referenced_assets(flow))

    # Also check interrupt rules
    for rule in script.interrupts:
        if rule.when_image:
            all_assets.add(rule.when_image)
        if rule.do_actions:
            # Scan actions in interrupt
            for action in rule.do_actions:
                if hasattr(action, "asset_id") and action.asset_id:
                    all_assets.add(action.asset_id)

    # Check each asset exists
    for asset_id in all_assets:
        asset_path = assets_dir / f"{asset_id}.png"
        if not asset_path.exists():
            missing.append(asset_id)
            logger.warning(f"Missing asset: {asset_id} (expected: {asset_path})")

    if missing:
        logger.error(f"Found {len(missing)} missing assets: {', '.join(missing)}")
        return False, missing

    logger.info(f"All {len(all_assets)} assets validated successfully")
    return True, []


================================================================================
FILE PATH: core\vision\hasher.py
LINES: 71
================================================================================

"""
Image Hashing Module
Part of "Titan Light" Phase 3 (Flight Recorder).

Provides methods to calculate perceptual hashes (aHash/pHash) of images
to detect if the screen content has changed effectively.
"""

import cv2
import numpy as np
from PIL import Image


def calculate_phash(image: Image.Image | np.ndarray) -> int:
    """
    Calculate Perceptual Hash (pHash) of an image.
    Robust against minor changes (noise, slight color shifts).

    Args:
        image: PIL Image or numpy array (BGR/RGB)

    Returns:
        64-bit integer hash
    """
    # Convert PIL to numpy if needed
    if isinstance(image, Image.Image):
        image = np.array(image)
        # Convert RGB to BGR for cv2 consistency if needed,
        # but for grayscale conversion it largely doesn't matter
        # as long as we use the right conversion code.
        # PIL is RGB.
        image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
    elif isinstance(image, np.ndarray):
        if len(image.shape) == 3:
            # Assuming BGR from cv2 standard or screen capture
            image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # 1. Resize to 32x32
    img_resized = cv2.resize(image, (32, 32), interpolation=cv2.INTER_AREA)

    # 2. Compute DCT
    float_img = np.float32(img_resized)
    dct = cv2.dct(float_img)

    # 3. Take top-left 8x8 (low frequencies)
    # Skipping DC component (0,0) usually recommended for robustness against brightness
    dct_low_freq = dct[0:8, 0:8]

    # 4. Compute average (excluding DC)
    avg = (np.sum(dct_low_freq) - dct_low_freq[0, 0]) / 63

    # 5. Compute hash
    hash_val = 0
    idx = 0
    for i in range(8):
        for j in range(8):
            val = 1 if dct_low_freq[i, j] > avg else 0
            hash_val |= val << idx
            idx += 1

    return hash_val


def hamming_distance(hash1: int, hash2: int) -> int:
    """
    Calculate Hamming distance between two 64-bit hashes.
    Unchanged screen ~ distance 0-2
    Significant change > 5
    """
    x = hash1 ^ hash2
    return bin(x).count("1")


================================================================================
FILE PATH: core\vision\input.py
LINES: 412
================================================================================

"""
RetroAuto v2 - Input Automation

Mouse and keyboard automation for RetroScript.
Part of RetroScript Phase 10 - Image Recognition.
"""

from __future__ import annotations

import random
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any

# Try to import optional dependencies
try:
    import pyautogui

    pyautogui.FAILSAFE = True
    pyautogui.PAUSE = 0.05
    HAS_PYAUTOGUI = True
except ImportError:
    HAS_PYAUTOGUI = False
    pyautogui = None


class MouseButton(Enum):
    """Mouse button types."""

    LEFT = "left"
    RIGHT = "right"
    MIDDLE = "middle"


@dataclass
class Point:
    """A 2D point."""

    x: int
    y: int

    def offset(self, dx: int, dy: int) -> Point:
        """Return new point with offset."""
        return Point(self.x + dx, self.y + dy)


class MouseController:
    """Mouse automation controller.

    Usage:
        mouse = MouseController()
        mouse.click(100, 200)
        mouse.moveto(300, 400)
    """

    def __init__(self, humanize: bool = True) -> None:
        self.humanize = humanize  # Add human-like delays
        self._position = Point(0, 0)

        if not HAS_PYAUTOGUI:
            print("[WARN] PyAutoGUI not installed. Using stub mode.")

    def click(
        self,
        x: int | None = None,
        y: int | None = None,
        button: str | MouseButton = MouseButton.LEFT,
        clicks: int = 1,
        interval: float = 0.1,
    ) -> None:
        """Click at position.

        Args:
            x: X coordinate (None = current position)
            y: Y coordinate (None = current position)
            button: Mouse button
            clicks: Number of clicks
            interval: Interval between clicks
        """
        if isinstance(button, MouseButton):
            button = button.value

        if not HAS_PYAUTOGUI:
            print(f"[STUB] click({x}, {y}, button={button}, clicks={clicks})")
            return

        if x is not None and y is not None:
            if self.humanize:
                self._move_humanized(x, y)
            else:
                pyautogui.moveTo(x, y)

        pyautogui.click(button=button, clicks=clicks, interval=interval)
        self._update_position()

    def moveto(self, x: int, y: int, duration: float = 0.0) -> None:
        """Move mouse to position.

        Args:
            x: Target X
            y: Target Y
            duration: Movement duration
        """
        if not HAS_PYAUTOGUI:
            print(f"[STUB] moveto({x}, {y})")
            return

        if self.humanize and duration == 0:
            self._move_humanized(x, y)
        else:
            pyautogui.moveTo(x, y, duration=duration)

        self._update_position()

    def move(self, dx: int, dy: int, duration: float = 0.0) -> None:
        """Move mouse relative to current position."""
        if not HAS_PYAUTOGUI:
            print(f"[STUB] move({dx}, {dy})")
            return

        pyautogui.move(dx, dy, duration=duration)
        self._update_position()

    def drag(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        button: str = "left",
        duration: float = 0.5,
    ) -> None:
        """Drag from one point to another."""
        if not HAS_PYAUTOGUI:
            print(f"[STUB] drag({x1}, {y1}, {x2}, {y2})")
            return

        pyautogui.moveTo(x1, y1)
        pyautogui.drag(x2 - x1, y2 - y1, duration=duration, button=button)
        self._update_position()

    def scroll(self, amount: int, x: int | None = None, y: int | None = None) -> None:
        """Scroll the mouse wheel.

        Args:
            amount: Scroll amount (positive = up, negative = down)
            x: X position (optional)
            y: Y position (optional)
        """
        if not HAS_PYAUTOGUI:
            print(f"[STUB] scroll({amount})")
            return

        if x is not None and y is not None:
            pyautogui.moveTo(x, y)

        pyautogui.scroll(amount)

    def position(self) -> Point:
        """Get current mouse position."""
        if not HAS_PYAUTOGUI:
            return self._position

        pos = pyautogui.position()
        self._position = Point(pos.x, pos.y)
        return self._position

    def _move_humanized(self, x: int, y: int) -> None:
        """Move with human-like motion using Cubic Bezier curves."""
        # Get start position
        start = self.position()
        start_x, start_y = start.x, start.y

        # Distance check
        dist = ((x - start_x) ** 2 + (y - start_y) ** 2) ** 0.5
        if dist < 5:
            pyautogui.moveTo(x, y)
            return

        # Randomize control points for Bezier curve
        # Curve should not be a straight line
        offset = min(dist * 0.2, 100)
        c1_x = start_x + (x - start_x) * 0.3 + random.randint(int(-offset), int(offset))
        c1_y = start_y + (y - start_y) * 0.3 + random.randint(int(-offset), int(offset))
        c2_x = start_x + (x - start_x) * 0.7 + random.randint(int(-offset), int(offset))
        c2_y = start_y + (y - start_y) * 0.7 + random.randint(int(-offset), int(offset))

        # Steps calculation based on distance (more steps = smoother)
        steps = int(max(20, dist / 15))

        # Duration based on Fitts' Law approximation
        base_speed = random.uniform(0.3, 0.6)  # Pixel per sec factor
        duration = max(0.2, min(1.5, dist / 1000 * base_speed + random.uniform(0.1, 0.3)))

        # Move along curve
        start_time = time.time()
        for i in range(1, steps + 1):
            t = i / steps

            # Easing function (easeOutQuad) for natural deceleration
            # t = t * (2 - t)

            # Cubic Bezier formula
            curr_x = (
                (1 - t) ** 3 * start_x
                + 3 * (1 - t) ** 2 * t * c1_x
                + 3 * (1 - t) * t**2 * c2_x
                + t**3 * x
            )
            curr_y = (
                (1 - t) ** 3 * start_y
                + 3 * (1 - t) ** 2 * t * c1_y
                + 3 * (1 - t) * t**2 * c2_y
                + t**3 * y
            )

            # PyAutoGUI handles the actual move event
            # Use 0 duration for instant steps, minimal sleep manually
            pyautogui.moveTo(int(curr_x), int(curr_y), _pause=False)

            # Variable sleep to simulate velocity changes
            elapsed = time.time() - start_time
            remaining = duration - elapsed
            if remaining > 0:
                time.sleep(remaining / (steps - i + 1))

        # Final jitter correction (humans rarely land perfectly on pixel 0)
        final_x = x + random.randint(-1, 1)
        final_y = y + random.randint(-1, 1)
        pyautogui.moveTo(final_x, final_y, duration=0.05)

    def _update_position(self) -> None:
        """Update cached position."""
        if HAS_PYAUTOGUI:
            pos = pyautogui.position()
            self._position = Point(pos.x, pos.y)


class KeyboardController:
    """Keyboard automation controller.

    Usage:
        kb = KeyboardController()
        kb.type("Hello, world!")
        kb.press("enter")
        kb.hotkey("ctrl", "c")
    """

    def __init__(self, type_delay: float = 0.05) -> None:
        self.type_delay = type_delay

        if not HAS_PYAUTOGUI:
            print("[WARN] PyAutoGUI not installed. Using stub mode.")

    def type(self, text: str, interval: float | None = None) -> None:
        """Type text with optional interval between keys.

        Args:
            text: Text to type
            interval: Delay between keystrokes
        """
        if not HAS_PYAUTOGUI:
            print(f"[STUB] type({text})")
            return

        interval = interval or self.type_delay
        pyautogui.write(text, interval=interval)

    def press(self, key: str, presses: int = 1, interval: float = 0.1) -> None:
        """Press a key.

        Args:
            key: Key name (e.g., 'enter', 'tab', 'a')
            presses: Number of times to press
            interval: Interval between presses
        """
        if not HAS_PYAUTOGUI:
            print(f"[STUB] press({key})")
            return

        pyautogui.press(key, presses=presses, interval=interval)

    def hotkey(self, *keys: str) -> None:
        """Press a key combination.

        Args:
            keys: Keys to press together (e.g., 'ctrl', 'c')
        """
        if not HAS_PYAUTOGUI:
            print(f"[STUB] hotkey({keys})")
            return

        pyautogui.hotkey(*keys)

    def keydown(self, key: str) -> None:
        """Hold a key down."""
        if not HAS_PYAUTOGUI:
            print(f"[STUB] keydown({key})")
            return

        pyautogui.keyDown(key)

    def keyup(self, key: str) -> None:
        """Release a held key."""
        if not HAS_PYAUTOGUI:
            print(f"[STUB] keyup({key})")
            return

        pyautogui.keyUp(key)

    def hold(self, key: str, duration: float = 0.5) -> None:
        """Hold a key for a duration.

        Args:
            key: Key to hold
            duration: Hold duration in seconds
        """
        if not HAS_PYAUTOGUI:
            print(f"[STUB] hold({key}, {duration})")
            return

        pyautogui.keyDown(key)
        time.sleep(duration)
        pyautogui.keyUp(key)


class InputController:
    """Combined mouse and keyboard controller.

    Usage:
        input = InputController()
        input.click(100, 200)
        input.type("Hello")
        input.hotkey("ctrl", "s")
    """

    def __init__(self, humanize: bool = True, type_delay: float = 0.05) -> None:
        self.mouse = MouseController(humanize=humanize)
        self.keyboard = KeyboardController(type_delay=type_delay)

    # Mouse methods
    def click(self, x: int | None = None, y: int | None = None, **kwargs: Any) -> None:
        """Click at position."""
        self.mouse.click(x, y, **kwargs)

    def moveto(self, x: int, y: int, **kwargs: Any) -> None:
        """Move mouse to position."""
        self.mouse.moveto(x, y, **kwargs)

    def drag(self, x1: int, y1: int, x2: int, y2: int, **kwargs: Any) -> None:
        """Drag from one point to another."""
        self.mouse.drag(x1, y1, x2, y2, **kwargs)

    def scroll(self, amount: int, **kwargs: Any) -> None:
        """Scroll mouse wheel."""
        self.mouse.scroll(amount, **kwargs)

    # Keyboard methods
    def type(self, text: str, **kwargs: Any) -> None:
        """Type text."""
        self.keyboard.type(text, **kwargs)

    def press(self, key: str, **kwargs: Any) -> None:
        """Press a key."""
        self.keyboard.press(key, **kwargs)

    def hotkey(self, *keys: str) -> None:
        """Press key combination."""
        self.keyboard.hotkey(*keys)

    def position(self) -> Point:
        """Get mouse position."""
        return self.mouse.position()


# Global controller instance
_default_controller: InputController | None = None


def get_controller() -> InputController:
    """Get the default input controller."""
    global _default_controller
    if _default_controller is None:
        _default_controller = InputController()
    return _default_controller


# Convenience functions
def click(x: int | None = None, y: int | None = None, **kwargs: Any) -> None:
    """Click at position."""
    get_controller().click(x, y, **kwargs)


def moveto(x: int, y: int, **kwargs: Any) -> None:
    """Move mouse to position."""
    get_controller().moveto(x, y, **kwargs)


def type_text(text: str, **kwargs: Any) -> None:
    """Type text."""
    get_controller().type(text, **kwargs)


def press(key: str, **kwargs: Any) -> None:
    """Press a key."""
    get_controller().press(key, **kwargs)


def hotkey(*keys: str) -> None:
    """Press key combination."""
    get_controller().hotkey(*keys)


================================================================================
FILE PATH: core\vision\matcher.py
LINES: 732
================================================================================

"""
RetroAuto v2 - Image Recognition

Template matching and image detection for automation.
Part of RetroScript Phase 10 - Image Recognition.
"""

from __future__ import annotations

import time
from dataclasses import dataclass
from enum import Enum, auto
from pathlib import Path
from typing import Any

# Try to import optional dependencies
try:
    import cv2
    import numpy as np

    HAS_CV2 = True
except ImportError:
    HAS_CV2 = False
    cv2 = None
    np = None

try:
    import mss

    HAS_MSS = True
except ImportError:
    HAS_MSS = False
    mss = None


class MatchMethod(Enum):
    """Template matching methods."""

    CCOEFF = auto()  # cv2.TM_CCOEFF_NORMED
    CCORR = auto()  # cv2.TM_CCORR_NORMED
    SQDIFF = auto()  # cv2.TM_SQDIFF_NORMED


class ResultType(Enum):
    """Types of match results."""

    FOUND = "Found"
    NOT_FOUND = "NotFound"
    TIMEOUT = "Timeout"
    ERROR = "Error"


@dataclass
class MatchResult:
    """Result of an image match operation."""

    result_type: ResultType
    x: int = 0
    y: int = 0
    width: int = 0
    height: int = 0
    score: float = 0.0
    scale: float = 1.0
    error_message: str | None = None

    @property
    def found(self) -> bool:
        """Check if match was found."""
        return self.result_type == ResultType.FOUND

    @property
    def center(self) -> tuple[int, int]:
        """Get center point of match."""
        return (self.x + self.width // 2, self.y + self.height // 2)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for script access."""
        return {
            "type": self.result_type.value,
            "x": self.x,
            "y": self.y,
            "width": self.width,
            "height": self.height,
            "score": self.score,
            "scale": self.scale,
            "found": self.found,
            "center_x": self.center[0],
            "center_y": self.center[1],
        }

    @classmethod
    def found_at(
        cls,
        x: int,
        y: int,
        width: int = 0,
        height: int = 0,
        score: float = 1.0,
        scale: float = 1.0,
    ) -> MatchResult:
        """Create a Found result."""
        return cls(
            result_type=ResultType.FOUND,
            x=x,
            y=y,
            width=width,
            height=height,
            score=score,
            scale=scale,
        )

    @classmethod
    def not_found(cls) -> MatchResult:
        """Create a NotFound result."""
        return cls(result_type=ResultType.NOT_FOUND)

    @classmethod
    def timeout(cls) -> MatchResult:
        """Create a Timeout result."""
        return cls(result_type=ResultType.TIMEOUT)

    @classmethod
    def error(cls, message: str) -> MatchResult:
        """Create an Error result."""
        return cls(result_type=ResultType.ERROR, error_message=message)


@dataclass
class ROI:
    """Region of Interest for searching."""

    x: int
    y: int
    width: int
    height: int

    def contains(self, x: int, y: int) -> bool:
        """Check if point is in ROI."""
        return self.x <= x < self.x + self.width and self.y <= y < self.y + self.height

    def to_tuple(self) -> tuple[int, int, int, int]:
        """Convert to tuple (x, y, w, h)."""
        return (self.x, self.y, self.width, self.height)


class ImageCache:
    """LRU cache for loaded images with TTL expiry for 24/7 operation."""

    def __init__(self, max_size: int = 50, ttl_seconds: int = 300) -> None:
        # path -> (image, mtime, last_access_time)
        self._cache: dict[str, tuple[Any, float, float]] = {}
        self._max_size = max_size
        self._ttl = ttl_seconds  # Expire entries not accessed for this long

        # Start background cleanup thread
        self._cleanup_started = False

    def _start_cleanup_thread(self) -> None:
        """Start background cleanup thread (lazy init)."""
        if self._cleanup_started:
            return
        self._cleanup_started = True

        import threading
        def cleanup_loop():
            import time
            while True:
                time.sleep(60)  # Cleanup every 60s
                self._cleanup_expired()

        thread = threading.Thread(target=cleanup_loop, daemon=True)
        thread.start()

    def _cleanup_expired(self) -> None:
        """Remove entries that haven't been accessed recently."""
        import time
        now = time.time()
        expired_keys = [
            path for path, (_, _, last_access) in self._cache.items()
            if now - last_access > self._ttl
        ]
        for key in expired_keys:
            del self._cache[key]

        if expired_keys:
            from infra import get_logger
            get_logger("ImageCache").debug(
                "Cleaned up %d expired cache entries", len(expired_keys)
            )

    def get(self, path: str) -> Any | None:
        """Get image from cache if still valid."""
        if path not in self._cache:
            return None

        image, cached_mtime, _ = self._cache[path]

        # Check if file was modified
        try:
            current_mtime = Path(path).stat().st_mtime
            if current_mtime > cached_mtime:
                # File changed, invalidate
                del self._cache[path]
                return None
        except OSError:
            return None

        # Update last access time
        import time
        self._cache[path] = (image, cached_mtime, time.time())

        return image

    def put(self, path: str, image: Any) -> None:
        """Add image to cache."""
        # Start cleanup thread on first put
        self._start_cleanup_thread()

        if len(self._cache) >= self._max_size:
            # Remove least recently accessed
            oldest = min(self._cache.keys(), key=lambda k: self._cache[k][2])
            del self._cache[oldest]

        try:
            mtime = Path(path).stat().st_mtime
        except OSError:
            mtime = 0.0

        import time
        self._cache[path] = (image, mtime, time.time())

    def clear(self) -> None:
        """Clear the cache."""
        self._cache.clear()


class ImageMatcher:
    """Template matching engine for image detection.

    Usage:
        matcher = ImageMatcher()
        result = matcher.find("button.png")
        if result.found:
            print(f"Found at {result.x}, {result.y}")
    """

    def __init__(
        self,
        assets_dir: str | Path = "assets",
        confidence: float = 0.8,
        method: MatchMethod = MatchMethod.CCOEFF,
    ) -> None:
        self.assets_dir = Path(assets_dir)
        self.confidence = confidence
        self.method = method
        self._cache = ImageCache()
        self._screen_capture: Any = None

        if not HAS_CV2:
            print("[WARN] OpenCV not installed. Using stub mode.")

    def find(
        self,
        template: str | Path,
        roi: ROI | tuple[int, int, int, int] | None = None,
        confidence: float | None = None,
        grayscale: bool = True,
        adaptive: bool = True,
    ) -> MatchResult:
        """Find template on screen.

        Args:
            template: Path to template image
            roi: Region of interest to search in
            confidence: Override default confidence
            grayscale: Convert to grayscale for matching

        Returns:
            MatchResult with position if found
        """
        if not HAS_CV2:
            return self._stub_find(str(template))

        confidence = confidence or self.confidence

        # Load template
        template_img = self._load_image(template)
        if template_img is None:
            return MatchResult.error(f"Template not found: {template}")

        # Capture screen
        screen = self._capture_screen(roi)
        if screen is None:
            return MatchResult.error("Failed to capture screen")

        if grayscale and len(template_img.shape) == 3:
            template_img = cv2.cvtColor(template_img, cv2.COLOR_BGR2GRAY)
        if grayscale and len(screen.shape) == 3:
            screen = cv2.cvtColor(screen, cv2.COLOR_BGR2GRAY)

        # Perform template matching
        result = self._match(screen, template_img, confidence)

        # Adaptive Fallback
        if not result.found and adaptive and confidence > 0.6:
            # Try reducing confidence in steps
            for fallback_conf in [
                c * 0.05 for c in range(int(confidence * 20) - 1, 11, -1)
            ]:  # e.g., 0.75, 0.70... 0.60
                fallback_result = self._match(screen, template_img, fallback_conf)
                if fallback_result.found:
                    result = fallback_result
                    result.error_message = f"Matched with degraded confidence: {fallback_conf:.2f}"
                    break

        # Adjust coordinates for ROI
        if result.found and roi:
            if isinstance(roi, tuple):
                roi = ROI(*roi)
            result.x += roi.x
            result.y += roi.y

        return result

    def find_all(
        self,
        template: str | Path,
        roi: ROI | tuple[int, int, int, int] | None = None,
        confidence: float | None = None,
        max_results: int = 10,
    ) -> list[MatchResult]:
        """Find all occurrences of template.

        Args:
            template: Path to template image
            roi: Region of interest
            confidence: Minimum confidence
            max_results: Maximum number of results

        Returns:
            List of MatchResults
        """
        if not HAS_CV2:
            return [self._stub_find(str(template))]

        confidence = confidence or self.confidence
        results: list[MatchResult] = []

        template_img = self._load_image(template)
        if template_img is None:
            return [MatchResult.error(f"Template not found: {template}")]

        screen = self._capture_screen(roi)
        if screen is None:
            return [MatchResult.error("Failed to capture screen")]

        # Convert to grayscale
        if len(template_img.shape) == 3:
            template_img = cv2.cvtColor(template_img, cv2.COLOR_BGR2GRAY)
        if len(screen.shape) == 3:
            screen = cv2.cvtColor(screen, cv2.COLOR_BGR2GRAY)

        # Match
        match_result = cv2.matchTemplate(
            screen,
            template_img,
            self._get_cv2_method(),
        )

        h, w = template_img.shape[:2]

        # Find all locations above threshold
        if self.method == MatchMethod.SQDIFF:
            locations = np.where(match_result <= 1 - confidence)
        else:
            locations = np.where(match_result >= confidence)

        for pt in zip(*locations[::-1], strict=False):
            if len(results) >= max_results:
                break

            x, y = int(pt[0]), int(pt[1])
            score = float(match_result[y, x])

            if self.method == MatchMethod.SQDIFF:
                score = 1 - score

            # Adjust for ROI
            if roi:
                if isinstance(roi, tuple):
                    roi = ROI(*roi)
                x += roi.x
                y += roi.y

            results.append(MatchResult.found_at(x, y, w, h, score))

        if not results:
            results.append(MatchResult.not_found())

        return results

    def find_multiscale(
        self,
        template: str | Path,
        scales: list[float] | None = None,
        roi: ROI | None = None,
        confidence: float | None = None,
    ) -> MatchResult:
        """Find template at multiple scales.

        Args:
            template: Path to template
            scales: List of scales to try (default: 0.5 to 1.5)
            roi: Region of interest
            confidence: Minimum confidence

        Returns:
            Best MatchResult across scales
        """
        if not HAS_CV2:
            return self._stub_find(str(template))

        scales = scales or [0.5, 0.75, 1.0, 1.25, 1.5]
        confidence = confidence or self.confidence

        template_img = self._load_image(template)
        if template_img is None:
            return MatchResult.error(f"Template not found: {template}")

        screen = self._capture_screen(roi)
        if screen is None:
            return MatchResult.error("Failed to capture screen")

        best_result = MatchResult.not_found()

        for scale in scales:
            # Resize template
            scaled = cv2.resize(
                template_img,
                None,
                fx=scale,
                fy=scale,
                interpolation=cv2.INTER_AREA,
            )

            # Skip if scaled template is larger than screen
            if scaled.shape[0] > screen.shape[0] or scaled.shape[1] > screen.shape[1]:
                continue

            result = self._match(screen, scaled, confidence)
            result.scale = scale

            if result.found and result.score > best_result.score:
                best_result = result

        # Adjust for ROI
        if best_result.found and roi:
            best_result.x += roi.x
            best_result.y += roi.y

        return best_result

    def wait(
        self,
        template: str | Path,
        timeout: float = 10.0,
        interval: float = 0.5,
        **kwargs: Any,
    ) -> MatchResult:
        """Wait for template to appear.

        Args:
            template: Path to template
            timeout: Maximum wait time in seconds
            interval: Check interval in seconds
            **kwargs: Additional args for find()

        Returns:
            MatchResult (FOUND, NOT_FOUND, or TIMEOUT)
        """
        start = time.time()

        while time.time() - start < timeout:
            result = self.find(template, **kwargs)
            if result.found:
                return result
            time.sleep(interval)

        return MatchResult.timeout()

    def _load_image(self, path: str | Path) -> Any | None:
        """Load image from file with caching."""
        path = Path(path)

        # Try relative to assets_dir
        if not path.is_absolute():
            path = self.assets_dir / path

        path_str = str(path)

        # Check cache
        cached = self._cache.get(path_str)
        if cached is not None:
            return cached

        # Load from disk
        if not path.exists():
            return None

        img = cv2.imread(path_str)
        if img is not None:
            self._cache.put(path_str, img)

        return img

    def _capture_screen(self, roi: ROI | tuple | None = None) -> Any | None:
        """Capture screen or region."""
        if not HAS_MSS:
            # Fallback: try PIL
            try:
                from PIL import ImageGrab

                screen = ImageGrab.grab()
                screen = np.array(screen)
                screen = cv2.cvtColor(screen, cv2.COLOR_RGB2BGR)

                if roi:
                    if isinstance(roi, tuple):
                        roi = ROI(*roi)
                    screen = screen[
                        roi.y : roi.y + roi.height,
                        roi.x : roi.x + roi.width,
                    ]

                return screen
            except Exception:
                return None

        with mss.mss() as sct:
            if roi:
                if isinstance(roi, tuple):
                    roi = ROI(*roi)
                monitor = {
                    "left": roi.x,
                    "top": roi.y,
                    "width": roi.width,
                    "height": roi.height,
                }
            else:
                monitor = sct.monitors[1]  # Primary monitor

            screenshot = sct.grab(monitor)
            return np.array(screenshot)[:, :, :3]  # Remove alpha

    def _match(
        self,
        screen: Any,
        template: Any,
        confidence: float,
    ) -> MatchResult:
        """Perform template matching."""
        # Ensure same number of channels
        if len(template.shape) != len(screen.shape):
            if len(template.shape) == 3:
                template = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)
            if len(screen.shape) == 3:
                screen = cv2.cvtColor(screen, cv2.COLOR_BGR2GRAY)

        result = cv2.matchTemplate(screen, template, self._get_cv2_method())

        if self.method == MatchMethod.SQDIFF:
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
            score = 1 - min_val
            loc = min_loc
        else:
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
            score = max_val
            loc = max_loc

        h, w = template.shape[:2]

        if score >= confidence:
            return MatchResult.found_at(loc[0], loc[1], w, h, score)
        else:
            return MatchResult.not_found()

    def _get_cv2_method(self) -> int:
        """Get OpenCV method constant."""
        methods = {
            MatchMethod.CCOEFF: cv2.TM_CCOEFF_NORMED,
            MatchMethod.CCORR: cv2.TM_CCORR_NORMED,
            MatchMethod.SQDIFF: cv2.TM_SQDIFF_NORMED,
        }
        return methods.get(self.method, cv2.TM_CCOEFF_NORMED)

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # Phase 3: Multi-threaded Matching
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    def find_any(
        self,
        templates: list[str | Path],
        roi: ROI | tuple[int, int, int, int] | None = None,
        confidence: float | None = None,
        max_workers: int = 4,
    ) -> tuple[MatchResult, str | None]:
        """Find any of multiple templates in parallel.

        Returns as soon as first match is found.
        Uses ThreadPoolExecutor for parallel execution.

        Args:
            templates: List of template paths to search
            roi: Region of interest
            confidence: Minimum confidence
            max_workers: Maximum parallel threads

        Returns:
            Tuple of (MatchResult, matched_template_name) or (NotFound, None)
        """
        from concurrent.futures import ThreadPoolExecutor, as_completed

        def search_template(template: str | Path) -> tuple[MatchResult, str]:
            result = self.find(template, roi=roi, confidence=confidence)
            return result, str(template)

        with ThreadPoolExecutor(max_workers=max_workers) as pool:
            futures = {pool.submit(search_template, t): t for t in templates}

            for future in as_completed(futures):
                try:
                    result, template_name = future.result()
                    if result.found:
                        # Cancel remaining futures
                        for f in futures:
                            f.cancel()
                        return result, template_name
                except Exception:
                    pass

        return MatchResult.not_found(), None

    def find_first(
        self,
        templates: list[str | Path],
        roi: ROI | tuple[int, int, int, int] | None = None,
        confidence: float | None = None,
    ) -> tuple[MatchResult, str | None]:
        """Find first matching template (sequential, priority order).

        Searches templates in order and returns on first match.
        Use when template priority matters.

        Args:
            templates: List of template paths in priority order
            roi: Region of interest
            confidence: Minimum confidence

        Returns:
            Tuple of (MatchResult, matched_template_name) or (NotFound, None)
        """
        for template in templates:
            result = self.find(template, roi=roi, confidence=confidence)
            if result.found:
                return result, str(template)
        return MatchResult.not_found(), None

    def find_all_templates(
        self,
        templates: list[str | Path],
        roi: ROI | tuple[int, int, int, int] | None = None,
        confidence: float | None = None,
        max_workers: int = 4,
    ) -> dict[str, MatchResult]:
        """Find all templates in parallel.

        Searches all templates and returns results for each.

        Args:
            templates: List of template paths
            roi: Region of interest
            confidence: Minimum confidence
            max_workers: Maximum parallel threads

        Returns:
            Dict mapping template name to MatchResult
        """
        from concurrent.futures import ThreadPoolExecutor, as_completed

        results: dict[str, MatchResult] = {}

        def search_template(template: str | Path) -> tuple[str, MatchResult]:
            result = self.find(template, roi=roi, confidence=confidence)
            return str(template), result

        with ThreadPoolExecutor(max_workers=max_workers) as pool:
            futures = [pool.submit(search_template, t) for t in templates]
            for future in as_completed(futures):
                try:
                    template_name, result = future.result()
                    results[template_name] = result
                except Exception as e:
                    pass

        return results

    def _stub_find(self, template: str) -> MatchResult:
        """Stub find for when OpenCV is not available."""
        print(f"[STUB] find({template})")
        return MatchResult.found_at(100, 100, 50, 50, 0.95)


# Global matcher instance
_default_matcher: ImageMatcher | None = None


def get_matcher() -> ImageMatcher:
    """Get the default image matcher."""
    global _default_matcher
    if _default_matcher is None:
        _default_matcher = ImageMatcher()
    return _default_matcher


def find(template: str, **kwargs: Any) -> MatchResult:
    """Convenience function to find image."""
    return get_matcher().find(template, **kwargs)


def wait(template: str, timeout: float = 10.0, **kwargs: Any) -> MatchResult:
    """Convenience function to wait for image."""
    return get_matcher().wait(template, timeout, **kwargs)


================================================================================
FILE PATH: core\vision\ocr.py
LINES: 152
================================================================================

"""
OCR Module for Text Recognition.
Wraps pytesseract/Tesseract-OCR.
"""

import logging
import os

from PIL import Image

# Try to import pytesseract
try:
    import pytesseract

    HAS_TESSERACT = True
except ImportError:
    HAS_TESSERACT = False

from core.models import ROI

logger = logging.getLogger(__name__)


class TextReader:
    """
    OCR Reader using Tesseract.
    """

    def __init__(self) -> None:
        self.available = HAS_TESSERACT
        if not self.available:
            logger.warning("pytesseract not installed. OCR features will be disabled.")

        # Check for Tesseract binary in common Windows paths if not in PATH
        if HAS_TESSERACT:
            try:
                # Simple check if "tesseract" command is available
                # If shutil.which("tesseract") is None, we might need to look for it.
                # For now, we trust the user has Tesseract in PATH or we set a default.

                # Common defaults for Windows
                known_paths = [
                    r"C:\Program Files\Tesseract-OCR\tesseract.exe",
                    r"C:\Program Files (x86)\Tesseract-OCR\tesseract.exe",
                    os.path.expandvars(r"%LOCALAPPDATA%\Programs\Tesseract-OCR\tesseract.exe"),
                ]

                # Only set if not already set (default is 'tesseract')
                cmd = pytesseract.pytesseract.tesseract_cmd
                if cmd == "tesseract":
                    import shutil

                    if not shutil.which("tesseract"):
                        for p in known_paths:
                            if os.path.exists(p):
                                pytesseract.pytesseract.tesseract_cmd = p
                                logger.info(f"Set Tesseract path to: {p}")
                                break
            except Exception as e:
                logger.warning(f"Error configuring Tesseract: {e}")

    def read_from_file(self, image_path: str, roi: ROI | None = None, allowlist: str = "") -> str:
        """Read text from an image file."""
        if not self.available:
            logger.error("OCR not available (pytesseract missing)")
            return ""

        try:
            img = Image.open(image_path)
            # Convert ROI object to dictionary for the new read_from_image signature
            roi_dict = {"x": roi.x, "y": roi.y, "w": roi.w, "h": roi.h} if roi else None
            return self.read_from_image(img, allowlist=allowlist, roi=roi_dict)
        except Exception as e:
            logger.error(f"OCR File Error: {e}")
            return ""

    def read_from_image(
        self, image: Image.Image, allowlist: str | None = None, roi: dict | None = None
    ) -> str:
        """
        Extract text from image with robust error handling.

        Args:
            image: PIL Image to read from
            allowlist: Characters to allow (e.g., "0123456789" for numbers only)
            roi: Region of interest {"x": int, "y": int, "w": int, "h": int}

        Returns:
            Extracted text, or empty string on failure
        """
        if not self.available:
            logger.warning("OCR not available - cannot read text")
            return ""

        try:
            # Validate image
            if image is None or image.size[0] == 0 or image.size[1] == 0:
                logger.error("Invalid image: None or zero size")
                return ""

            # Apply ROI if specified
            if roi:
                # Validate ROI bounds
                img_width, img_height = image.size
                x, y, w, h = roi["x"], roi["y"], roi["w"], roi["h"]

                if x < 0 or y < 0 or w <= 0 or h <= 0:
                    logger.error(f"Invalid ROI coordinates: {roi}")
                    return ""

                if x + w > img_width or y + h > img_height:
                    logger.warning(
                        f"ROI {roi} exceeds image bounds ({img_width}x{img_height}), "
                        f"clamping to valid region"
                    )
                    # Clamp to valid region
                    w = min(w, img_width - x)
                    h = min(h, img_height - y)

                # Crop to ROI
                try:
                    image = image.crop((x, y, x + w, y + h))
                except Exception as e:
                    logger.error(f"Failed to crop ROI {roi}: {e}")
                    return ""

            # Convert to grayscale for better OCR
            try:
                if image.mode != "L":
                    image = image.convert("L")
            except Exception as e:
                logger.warning(f"Failed to convert to grayscale: {e}, using original")

            # Build config
            config_opts = ["--psm 6"]  # Assume uniform block of text
            if allowlist:
                # Tesseract 4/5 uses multiple engines, some allowlist features behave differently
                # But generally -c tessedit_char_whitelist=... works
                config_opts.append(f"-c tessedit_char_whitelist={allowlist}")

            config_str = " ".join(config_opts)

            text = pytesseract.image_to_string(image, config=config_str)
            return text.strip()

        except Exception as e:
            logger.error(f"OCR Execution Error: {e}")
            # If tesseract not found, it raises TesseractNotFoundError
            if "tesseract is not installed" in str(e).lower() or "not found" in str(e).lower():
                self.available = False
                logger.critical("Tesseract binary not found! Please install Tesseract-OCR.")
            return ""


================================================================================
FILE PATH: infra\__init__.py
LINES: 21
================================================================================

"""RetroAuto v2 - Infrastructure module."""

from infra.autosave import AutosaveManager
from infra.config import AppConfig, ProjectConfig, get_config, set_config
from infra.hotkeys import HotkeyManager
from infra.logging import get_logger, log_emitter, setup_logging
from infra.profiler import PerformanceProfiler, get_profiler

__all__ = [
    "setup_logging",
    "get_logger",
    "log_emitter",
    "get_config",
    "set_config",
    "AppConfig",
    "ProjectConfig",
    "HotkeyManager",
    "AutosaveManager",
    "PerformanceProfiler",
    "get_profiler",
]


================================================================================
FILE PATH: infra\autosave.py
LINES: 134
================================================================================

"""
RetroAuto v2 - Autosave Manager

Automatic backup saves with configurable interval.
"""

import threading
import time
from collections.abc import Callable
from pathlib import Path

from infra.logging import get_logger

logger = get_logger("Autosave")


class AutosaveManager:
    """
    Manages automatic saving of script at regular intervals.

    Features:
    - Configurable interval (default 60s)
    - Backup rotation (keep last N backups)
    - Only saves if changes detected
    - Thread-safe
    """

    def __init__(
        self,
        interval_seconds: int = 60,
        max_backups: int = 5,
    ) -> None:
        """
        Initialize autosave manager.

        Args:
            interval_seconds: Save interval in seconds
            max_backups: Maximum backup files to keep
        """
        self._interval = interval_seconds
        self._max_backups = max_backups
        self._thread: threading.Thread | None = None
        self._running = False
        self._dirty = False
        self._save_callback: Callable[[], bool] | None = None
        self._backup_dir: Path | None = None

    def start(
        self,
        save_callback: Callable[[], bool],
        backup_dir: Path,
    ) -> None:
        """
        Start autosave thread.

        Args:
            save_callback: Function that performs save, returns True on success
            backup_dir: Directory for backup files
        """
        if self._running:
            return

        self._save_callback = save_callback
        self._backup_dir = backup_dir
        self._running = True
        self._thread = threading.Thread(target=self._autosave_loop, daemon=True)
        self._thread.start()
        logger.info("Autosave started (interval=%ds)", self._interval)

    def stop(self) -> None:
        """Stop autosave thread."""
        self._running = False
        if self._thread:
            self._thread.join(timeout=2.0)
            self._thread = None
        logger.info("Autosave stopped")

    def mark_dirty(self) -> None:
        """Mark that changes need to be saved."""
        self._dirty = True

    def mark_clean(self) -> None:
        """Mark that no changes need to be saved."""
        self._dirty = False

    def _autosave_loop(self) -> None:
        """Background autosave loop."""
        while self._running:
            time.sleep(self._interval)

            if not self._running:
                break

            if self._dirty and self._save_callback:
                try:
                    self._create_backup()
                    if self._save_callback():
                        self._dirty = False
                        logger.info("Autosave completed")
                except Exception as e:
                    logger.exception("Autosave failed: %s", e)

    def _create_backup(self) -> None:
        """Create backup before saving."""
        if not self._backup_dir:
            return

        backup_dir = self._backup_dir / "backups"
        backup_dir.mkdir(parents=True, exist_ok=True)

        # Get existing backups
        backups = sorted(backup_dir.glob("script_*.yaml"))

        # Rotate if needed
        while len(backups) >= self._max_backups:
            oldest = backups.pop(0)
            try:
                oldest.unlink()
                logger.debug("Removed old backup: %s", oldest.name)
            except Exception:
                pass

        # Create new backup name
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        backup_name = f"script_{timestamp}.yaml"

        # Copy current script to backup
        script_path = self._backup_dir / "script.yaml"
        if script_path.exists():
            import shutil

            backup_path = backup_dir / backup_name
            shutil.copy(script_path, backup_path)
            logger.debug("Created backup: %s", backup_name)


================================================================================
FILE PATH: infra\config.py
LINES: 67
================================================================================

"""
RetroAuto v2 - Configuration management.
"""

from pathlib import Path
from typing import Any

from pydantic import BaseModel, Field


class AppConfig(BaseModel):
    """Application-wide configuration."""

    # Paths
    log_dir: Path = Field(default_factory=lambda: Path.home() / ".retroauto" / "logs")
    projects_dir: Path = Field(default_factory=lambda: Path.home() / ".retroauto" / "projects")

    # Vision defaults
    default_threshold: float = Field(default=0.8, ge=0.0, le=1.0)
    default_poll_ms: int = Field(default=100, ge=10)
    default_timeout_ms: int = Field(default=10000, ge=0)
    grayscale_matching: bool = True

    # Input defaults
    paste_mode: bool = True  # Use clipboard for Vietnamese support
    click_interval_ms: int = Field(default=80, ge=0)

    # Engine defaults
    interrupt_poll_ms: int = Field(default=200, ge=50)
    backoff_max_ms: int = Field(default=1000, ge=100)

    # Hotkeys
    hotkey_start: str = "F5"
    hotkey_stop: str = "F6"
    hotkey_pause: str = "F7"

    model_config = {"validate_assignment": True}


class ProjectConfig(BaseModel):
    """Per-project configuration stored in script.yaml."""

    name: str = "Untitled"
    version: str = "1.0"
    author: str = ""
    description: str = ""

    # Override app defaults
    overrides: dict[str, Any] = Field(default_factory=dict)


# Global config instance
_config: AppConfig | None = None


def get_config() -> AppConfig:
    """Get global app config (lazy initialized)."""
    global _config
    if _config is None:
        _config = AppConfig()
    return _config


def set_config(config: AppConfig) -> None:
    """Set global app config."""
    global _config
    _config = config


================================================================================
FILE PATH: infra\crash_handler.py
LINES: 190
================================================================================

"""
Global Crash Handler
Pillar 2 of "Titan Light" Robustness Strategy.

Intercepts unhandled exceptions and shows a dialog instead of crashing to desktop.
"""

import platform
import subprocess
import sys
import traceback
from datetime import datetime

from PySide6.QtGui import QFont
from PySide6.QtWidgets import (
    QApplication,
    QDialog,
    QHBoxLayout,
    QLabel,
    QPushButton,
    QStyle,
    QTextEdit,
    QVBoxLayout,
)

from infra import get_logger

logger = get_logger("CrashHandler")


class CrashDialog(QDialog):
    """
    Dialog shown when the application crashes.
    """

    def __init__(self, exctype, value, tb, parent=None):
        super().__init__(parent)
        self.setWindowTitle("RetroAuto - Critcal Error")
        self.setMinimumSize(600, 400)
        self.setModal(True)

        # Get traceback string
        self.traceback_text = "".join(traceback.format_exception(exctype, value, tb))

        # Determine restart command
        self.restart_cmd = [sys.executable] + sys.argv

        self._init_ui(exctype, value)

    def _init_ui(self, exctype, value):
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)

        # Header
        header_layout = QHBoxLayout()

        # Icon (Warning)
        icon_label = QLabel()
        icon = self.style().standardIcon(QStyle.StandardPixmap.SP_MessageBoxCritical)
        icon_label.setPixmap(icon.pixmap(48, 48))
        header_layout.addWidget(icon_label)

        # Message
        msg_layout = QVBoxLayout()
        title_label = QLabel("Oops! RetroAuto encountered a problem.")
        title_label.setStyleSheet("font-size: 16px; font-weight: bold; color: #ff5555;")

        desc_label = QLabel(
            "An unhandled exception occurred. You can restart the application or close it.\n"
            f"Error: {exctype.__name__}: {value}"
        )
        desc_label.setWordWrap(True)

        msg_layout.addWidget(title_label)
        msg_layout.addWidget(desc_label)
        header_layout.addLayout(msg_layout)
        header_layout.addStretch()

        layout.addLayout(header_layout)

        # Stack Trace Area
        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        self.text_edit.setFont(QFont("Consolas", 9))
        self.text_edit.setPlainText(self.traceback_text)
        self.text_edit.setStyleSheet(
            "background-color: #2b2b2b; color: #f8f8f2; border: 1px solid #444;"
        )
        layout.addWidget(self.text_edit)

        # Buttons
        btn_layout = QHBoxLayout()

        btn_copy = QPushButton("üìÑ Copy Error")
        btn_copy.clicked.connect(self._copy_error)

        btn_restart = QPushButton("üîÑ Restart Application")
        btn_restart.clicked.connect(self._restart_app)
        btn_restart.setStyleSheet("background-color: #50fa7b; color: #000; font-weight: bold;")

        btn_close = QPushButton("‚ùå Close")
        btn_close.clicked.connect(self.close)

        btn_layout.addWidget(btn_copy)
        btn_layout.addStretch()
        btn_layout.addWidget(btn_restart)
        btn_layout.addWidget(btn_close)

        layout.addLayout(btn_layout)

    def _copy_error(self):
        clipboard = QApplication.clipboard()
        report = (
            f"RetroAuto Crash Report\n"
            f"Date: {datetime.now()}\n"
            f"OS: {platform.system()} {platform.release()}\n"
            f"Python: {platform.python_version()}\n\n"
            f"Traceback:\n{self.traceback_text}"
        )
        clipboard.setText(report)
        self.text_edit.selectAll()

    def _restart_app(self):
        """Restart the application."""
        logger.info("Restarting application...")
        subprocess.Popen(self.restart_cmd)
        QApplication.quit()


class CrashHandler:
    """
    Installs global exception hooks to catch crashes.
    """

    _installed = False
    _is_handling = False

    @classmethod
    def install(cls):
        if cls._installed:
            return

        sys.excepthook = cls._handle_exception
        # Also catch calls that are ignored (like in threads mostly, though Qt handles connection errors differently)
        # sys.unraisablehook = cls._handle_unraisable

        cls._installed = True
        logger.info("Global Crash Handler installed")

    @classmethod
    def _handle_exception(cls, exctype, value, tb):
        """Handle execution exception."""
        # Prevent recursion
        if cls._is_handling:
            sys.__excepthook__(exctype, value, tb)
            return

        cls._is_handling = True
        try:
            # Log it first (safely)
            try:
                logger.critical("Uncaught exception!", exc_info=(exctype, value, tb))
            except Exception:
                print("Failed to log crash (likely stack overflow)", file=sys.stderr)

            # Don't handle KeyboardInterrupt (Ctrl+C)
            if issubclass(exctype, KeyboardInterrupt):
                sys.__excepthook__(exctype, value, tb)
                return

            # Show dialog if QApplication exists
            app = QApplication.instance()
            if app:
                try:
                    dialog = CrashDialog(exctype, value, tb)
                    dialog.exec()
                except Exception as e:
                    # If dialog fails, fallback to stderr
                    print("Error showing CrashDialog:", e, file=sys.stderr)
                    sys.__excepthook__(exctype, value, tb)
            else:
                sys.__excepthook__(exctype, value, tb)
        finally:
            cls._is_handling = False

    # @classmethod
    # def _handle_unraisable(cls, args):
    #     """Handle unraisable exceptions (e.g. in __del__)."""
    #     cls._handle_exception(args.exc_type, args.exc_value, args.exc_traceback)


================================================================================
FILE PATH: infra\hotkeys.py
LINES: 203
================================================================================

"""
RetroAuto v2 - Global hotkey management using Windows RegisterHotKey.
"""

import ctypes
import threading
from collections.abc import Callable
from ctypes import wintypes

from infra.logging import get_logger

logger = get_logger("Hotkeys")

# Windows constants
WM_HOTKEY = 0x0312
MOD_ALT = 0x0001
MOD_CONTROL = 0x0002
MOD_SHIFT = 0x0004
MOD_WIN = 0x0008
MOD_NOREPEAT = 0x4000

# Virtual key codes
VK_CODES: dict[str, int] = {
    "F1": 0x70,
    "F2": 0x71,
    "F3": 0x72,
    "F4": 0x73,
    "F5": 0x74,
    "F6": 0x75,
    "F7": 0x76,
    "F8": 0x77,
    "F9": 0x78,
    "F10": 0x79,
    "F11": 0x7A,
    "F12": 0x7B,
    "ESC": 0x1B,
    "SPACE": 0x20,
    "RETURN": 0x0D,
    "TAB": 0x09,
    "BACK": 0x08,
    "DELETE": 0x2E,
    "INSERT": 0x2D,
    "HOME": 0x24,
    "END": 0x23,
    "PAGEUP": 0x21,
    "PAGEDOWN": 0x22,
    "LEFT": 0x25,
    "UP": 0x26,
    "RIGHT": 0x27,
    "DOWN": 0x28,
    "0": 0x30,
    "1": 0x31,
    "2": 0x32,
    "3": 0x33,
    "4": 0x34,
    "5": 0x35,
    "6": 0x36,
    "7": 0x37,
    "8": 0x38,
    "9": 0x39,
    "A": 0x41,
    "B": 0x42,
    "C": 0x43,
    "D": 0x44,
    "E": 0x45,
    "F": 0x46,
    "G": 0x47,
    "H": 0x48,
    "I": 0x49,
    "J": 0x4A,
    "K": 0x4B,
    "L": 0x4C,
    "M": 0x4D,
    "N": 0x4E,
    "O": 0x4F,
    "P": 0x50,
    "Q": 0x51,
    "R": 0x52,
    "S": 0x53,
    "T": 0x54,
    "U": 0x55,
    "V": 0x56,
    "W": 0x57,
    "X": 0x58,
    "Y": 0x59,
    "Z": 0x5A,
}


def parse_hotkey(hotkey_str: str) -> tuple[int, int]:
    """
    Parse hotkey string like 'CTRL+SHIFT+F5' into (modifiers, vk_code).

    Returns:
        (modifiers, virtual_key_code)
    """
    parts = [p.strip().upper() for p in hotkey_str.split("+")]
    modifiers = 0
    vk_code = 0

    for part in parts:
        if part in ("CTRL", "CONTROL"):
            modifiers |= MOD_CONTROL
        elif part in ("ALT",):
            modifiers |= MOD_ALT
        elif part in ("SHIFT",):
            modifiers |= MOD_SHIFT
        elif part in ("WIN", "WINDOWS"):
            modifiers |= MOD_WIN
        elif part in VK_CODES:
            vk_code = VK_CODES[part]
        else:
            raise ValueError(f"Unknown key: {part}")

    if vk_code == 0:
        raise ValueError(f"No main key in hotkey: {hotkey_str}")

    return modifiers | MOD_NOREPEAT, vk_code


class HotkeyManager:
    """
    Manages global hotkeys using Windows RegisterHotKey.

    Thread-safe: runs message loop in background thread.
    """

    def __init__(self) -> None:
        self._hotkeys: dict[int, Callable[[], None]] = {}
        self._next_id = 1
        self._thread: threading.Thread | None = None
        self._running = False
        self._hwnd: int = 0

    def register(self, hotkey: str, callback: Callable[[], None]) -> int:
        """
        Register a global hotkey.

        Args:
            hotkey: Hotkey string like 'CTRL+SHIFT+S' or 'F5'
            callback: Function to call when hotkey pressed

        Returns:
            Hotkey ID for unregistering
        """
        modifiers, vk_code = parse_hotkey(hotkey)
        hotkey_id = self._next_id
        self._next_id += 1

        if not ctypes.windll.user32.RegisterHotKey(None, hotkey_id, modifiers, vk_code):
            error = ctypes.get_last_error()
            raise OSError(f"Failed to register hotkey {hotkey}: error {error}")

        self._hotkeys[hotkey_id] = callback
        logger.info("Registered hotkey: %s (id=%d)", hotkey, hotkey_id)
        return hotkey_id

    def unregister(self, hotkey_id: int) -> None:
        """Unregister a hotkey by ID."""
        if hotkey_id in self._hotkeys:
            ctypes.windll.user32.UnregisterHotKey(None, hotkey_id)
            del self._hotkeys[hotkey_id]
            logger.info("Unregistered hotkey id=%d", hotkey_id)

    def unregister_all(self) -> None:
        """Unregister all hotkeys."""
        for hotkey_id in list(self._hotkeys.keys()):
            self.unregister(hotkey_id)

    def start(self) -> None:
        """Start the hotkey listener thread."""
        if self._running:
            return

        self._running = True
        self._thread = threading.Thread(target=self._message_loop, daemon=True)
        self._thread.start()
        logger.info("Hotkey manager started")

    def stop(self) -> None:
        """Stop the hotkey listener."""
        self._running = False
        self.unregister_all()
        if self._thread:
            self._thread.join(timeout=1.0)
            self._thread = None
        logger.info("Hotkey manager stopped")

    def _message_loop(self) -> None:
        """Windows message loop for hotkey events."""
        msg = wintypes.MSG()
        while self._running:
            if ctypes.windll.user32.PeekMessageW(ctypes.byref(msg), None, 0, 0, 1):
                if msg.message == WM_HOTKEY:
                    hotkey_id = msg.wParam
                    if hotkey_id in self._hotkeys:
                        try:
                            self._hotkeys[hotkey_id]()
                        except Exception as e:
                            logger.error("Hotkey callback error: %s", e)
            else:
                # Avoid busy-wait
                ctypes.windll.kernel32.Sleep(10)


================================================================================
FILE PATH: infra\logging.py
LINES: 119
================================================================================

"""
RetroAuto v2 - Windows Automation Tool

Logging infrastructure with rotating file handler and GUI integration.
"""

import logging
import sys
from collections.abc import Callable
from datetime import datetime
from logging.handlers import RotatingFileHandler
from pathlib import Path

# Default log directory
LOG_DIR = Path.home() / ".retroauto" / "logs"


class LogEmitter:
    """Bridge between logging and GUI log panel."""

    def __init__(self) -> None:
        self._callbacks: list[Callable[[str, str, str], None]] = []

    def add_callback(self, callback: Callable[[str, str, str], None]) -> None:
        """Register callback: (level, timestamp, message) -> None."""
        self._callbacks.append(callback)

    def emit(self, level: str, timestamp: str, message: str) -> None:
        """Emit log to all registered callbacks."""
        import contextlib

        for cb in self._callbacks:
            with contextlib.suppress(Exception):
                cb(level, timestamp, message)


# Global emitter for GUI integration
log_emitter = LogEmitter()


class GUIHandler(logging.Handler):
    """Handler that emits logs to GUI via LogEmitter."""

    def emit(self, record: logging.LogRecord) -> None:
        try:
            timestamp = datetime.fromtimestamp(record.created).strftime("%H:%M:%S")
            message = self.format(record)
            log_emitter.emit(record.levelname, timestamp, message)
        except Exception:
            self.handleError(record)


def setup_logging(
    level: int = logging.INFO,
    log_dir: Path | None = None,
    max_bytes: int = 5 * 1024 * 1024,  # 5MB
    backup_count: int = 3,
    enable_gui: bool = True,
) -> logging.Logger:
    """
    Configure application logging.

    Args:
        level: Log level (default INFO)
        log_dir: Directory for log files
        max_bytes: Max size per log file
        backup_count: Number of backup files
        enable_gui: Enable GUI handler

    Returns:
        Root logger for RetroAuto
    """
    if log_dir is None:
        log_dir = LOG_DIR

    log_dir.mkdir(parents=True, exist_ok=True)

    # Format
    fmt = "%(asctime)s | %(levelname)-8s | %(name)s | %(message)s"
    date_fmt = "%Y-%m-%d %H:%M:%S"
    formatter = logging.Formatter(fmt, date_fmt)

    # Root logger
    logger = logging.getLogger("RetroAuto")
    logger.setLevel(level)
    logger.handlers.clear()

    # Console handler
    console = logging.StreamHandler(sys.stdout)
    console.setLevel(level)
    console.setFormatter(formatter)
    logger.addHandler(console)

    # File handler with rotation
    log_file = log_dir / "retroauto.log"
    file_handler = RotatingFileHandler(
        log_file,
        maxBytes=max_bytes,
        backupCount=backup_count,
        encoding="utf-8",
    )
    file_handler.setLevel(logging.DEBUG)  # File gets everything
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    # GUI handler
    if enable_gui:
        gui_handler = GUIHandler()
        gui_handler.setLevel(level)
        gui_handler.setFormatter(logging.Formatter("%(message)s"))
        logger.addHandler(gui_handler)

    logger.info("Logging initialized: %s", log_file)
    return logger


def get_logger(name: str) -> logging.Logger:
    """Get a child logger under RetroAuto namespace."""
    return logging.getLogger(f"RetroAuto.{name}")


================================================================================
FILE PATH: infra\profiler.py
LINES: 156
================================================================================

"""
RetroAuto v2 - Performance Profiler

CPU profiling utilities for optimization.
"""

import cProfile
import pstats
import time
from collections.abc import Generator
from contextlib import contextmanager
from dataclasses import dataclass
from io import StringIO

from infra.logging import get_logger

logger = get_logger("Profiler")


@dataclass
class TimingStats:
    """Statistics for a timed operation."""

    name: str
    count: int = 0
    total_ms: float = 0.0
    min_ms: float = float("inf")
    max_ms: float = 0.0

    @property
    def avg_ms(self) -> float:
        return self.total_ms / self.count if self.count > 0 else 0.0

    def record(self, ms: float) -> None:
        self.count += 1
        self.total_ms += ms
        self.min_ms = min(self.min_ms, ms)
        self.max_ms = max(self.max_ms, ms)

    def __str__(self) -> str:
        return (
            f"{self.name}: count={self.count}, "
            f"avg={self.avg_ms:.2f}ms, "
            f"min={self.min_ms:.2f}ms, "
            f"max={self.max_ms:.2f}ms"
        )


class PerformanceProfiler:
    """
    Simple performance profiler for tracking operation timings.

    Usage:
        profiler = PerformanceProfiler()

        with profiler.track("template_match"):
            # ... do work ...

        profiler.report()
    """

    def __init__(self) -> None:
        self._stats: dict[str, TimingStats] = {}
        self._enabled = True

    def enable(self) -> None:
        """Enable profiling."""
        self._enabled = True

    def disable(self) -> None:
        """Disable profiling."""
        self._enabled = False

    @contextmanager
    def track(self, name: str) -> Generator[None, None, None]:
        """
        Track execution time of a code block.

        Args:
            name: Operation name for grouping
        """
        if not self._enabled:
            yield
            return

        start = time.perf_counter()
        try:
            yield
        finally:
            elapsed_ms = (time.perf_counter() - start) * 1000

            if name not in self._stats:
                self._stats[name] = TimingStats(name)
            self._stats[name].record(elapsed_ms)

    def get_stats(self, name: str) -> TimingStats | None:
        """Get stats for a specific operation."""
        return self._stats.get(name)

    def reset(self) -> None:
        """Reset all statistics."""
        self._stats.clear()

    def report(self) -> str:
        """Generate text report of all timings."""
        if not self._stats:
            return "No profiling data collected."

        lines = ["Performance Report", "=" * 50]
        for name in sorted(self._stats.keys()):
            lines.append(str(self._stats[name]))
        return "\n".join(lines)

    def log_report(self) -> None:
        """Log the performance report."""
        logger.info("\n%s", self.report())


def run_cprofile(func, *args, **kwargs):  # type: ignore
    """
    Run function with cProfile and return stats.

    Args:
        func: Function to profile
        *args, **kwargs: Arguments to pass to function

    Returns:
        (result, stats_string)
    """
    profiler = cProfile.Profile()
    profiler.enable()

    try:
        result = func(*args, **kwargs)
    finally:
        profiler.disable()

    # Get stats as string
    stream = StringIO()
    stats = pstats.Stats(profiler, stream=stream)
    stats.sort_stats("cumulative")
    stats.print_stats(30)

    return result, stream.getvalue()


# Global profiler instance
_profiler: PerformanceProfiler | None = None


def get_profiler() -> PerformanceProfiler:
    """Get global profiler instance."""
    global _profiler
    if _profiler is None:
        _profiler = PerformanceProfiler()
    return _profiler


================================================================================
FILE PATH: infra\version.py
LINES: 207
================================================================================

"""
RetroAuto v2 - Version Management

Automatic versioning with changelog and git integration.
"""

import subprocess
from datetime import datetime
from pathlib import Path

# Current version - update this when releasing
__version__ = "2.0.0"
__build__ = "20251223.021"

VERSION_FILE = Path(__file__).parent.parent / "VERSION"
CHANGELOG_FILE = Path(__file__).parent.parent / "CHANGELOG.md"


def get_version() -> str:
    """Get current version string."""
    return f"{__version__}+{__build__}"


def bump_build() -> str:
    """
    Auto-increment build number and update version.py file.

    Build format: YYYYMMDD.NNN (date + daily increment)
    Returns:
        New build string
    """
    from datetime import datetime

    today = datetime.now().strftime("%Y%m%d")
    current_date = __build__.split(".")[0]

    # Same day - increment counter, new day - reset to 1
    counter = int(__build__.split(".")[1]) + 1 if today == current_date else 1

    new_build = f"{today}.{counter:03d}"

    # Update this file
    version_file = Path(__file__)
    content = version_file.read_text(encoding="utf-8")
    content = content.replace(f'__build__ = "{__build__}"', f'__build__ = "{new_build}"')
    version_file.write_text(content, encoding="utf-8")

    print(f"üì¶ Build updated: {__build__} -> {new_build}")
    return new_build


def get_version_tuple() -> tuple[int, int, int]:
    """Get version as tuple (major, minor, patch)."""
    parts = __version__.split(".")
    return (int(parts[0]), int(parts[1]), int(parts[2]))


def bump_version(part: str = "patch") -> str:
    """
    Bump version number.

    Args:
        part: "major", "minor", or "patch"

    Returns:
        New version string
    """
    major, minor, patch = get_version_tuple()

    if part == "major":
        major += 1
        minor = 0
        patch = 0
    elif part == "minor":
        minor += 1
        patch = 0
    else:  # patch
        patch += 1

    return f"{major}.{minor}.{patch}"


def git_commit(message: str, auto_add: bool = True) -> bool:
    """
    Create git commit with message.

    Args:
        message: Commit message
        auto_add: Auto-add all changes

    Returns:
        True if successful
    """
    try:
        cwd = Path(__file__).parent.parent

        if auto_add:
            subprocess.run(
                ["git", "add", "-A"],
                cwd=cwd,
                check=True,
                capture_output=True,
            )

        subprocess.run(
            ["git", "commit", "-m", message],
            cwd=cwd,
            check=True,
            capture_output=True,
        )
        return True
    except subprocess.CalledProcessError:
        return False


def git_tag(tag: str, message: str = "") -> bool:
    """Create git tag."""
    try:
        cwd = Path(__file__).parent.parent
        cmd = ["git", "tag", "-a", tag, "-m", message or tag]
        subprocess.run(cmd, cwd=cwd, check=True, capture_output=True)
        return True
    except subprocess.CalledProcessError:
        return False


def add_changelog_entry(
    version: str,
    changes: list[str],
    category: str = "Changed",
) -> None:
    """
    Add entry to CHANGELOG.md.

    Args:
        version: Version string
        changes: List of change descriptions
        category: "Added", "Changed", "Fixed", "Removed"
    """
    date = datetime.now().strftime("%Y-%m-%d")

    entry = f"\n## [{version}] - {date}\n\n"
    entry += f"### {category}\n\n"
    for change in changes:
        entry += f"- {change}\n"

    if CHANGELOG_FILE.exists():
        content = CHANGELOG_FILE.read_text(encoding="utf-8")
        # Insert after header
        if "# Changelog" in content:
            parts = content.split("# Changelog", 1)
            new_content = parts[0] + "# Changelog\n" + entry + parts[1].lstrip("\n")
        else:
            new_content = "# Changelog\n" + entry + "\n" + content
    else:
        new_content = "# Changelog\n\nAll notable changes to RetroAuto v2.\n" + entry

    CHANGELOG_FILE.write_text(new_content, encoding="utf-8")


def release(
    changes: list[str],
    bump: str = "patch",
    category: str = "Changed",
) -> str:
    """
    Create a new release with version bump, changelog, and git commit/tag.

    Args:
        changes: List of change descriptions
        bump: Version bump type ("major", "minor", "patch")
        category: Changelog category

    Returns:
        New version string
    """
    new_version = bump_version(bump)

    # Update changelog
    add_changelog_entry(new_version, changes, category)

    # Commit
    commit_msg = f"Release v{new_version}\n\n"
    for change in changes:
        commit_msg += f"- {change}\n"

    git_commit(commit_msg)

    # Tag
    git_tag(f"v{new_version}", f"Version {new_version}")

    return new_version


def quick_save(description: str) -> bool:
    """
    Quick save changes with auto-commit.

    Args:
        description: Short description of changes

    Returns:
        True if successful
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    message = f"[{timestamp}] {description}"
    return git_commit(message)


================================================================================
FILE PATH: input\__init__.py
LINES: 9
================================================================================

"""RetroAuto v2 - Input package."""

from input.keyboard import KeyboardController
from input.mouse import MouseController

__all__ = [
    "MouseController",
    "KeyboardController",
]


================================================================================
FILE PATH: input\keyboard.py
LINES: 316
================================================================================

"""
RetroAuto v2 - Keyboard Controller

Keyboard control using pywin32 with paste mode for Vietnamese support.
"""

import time

import win32api
import win32clipboard
import win32con

from infra import get_logger

logger = get_logger("Keyboard")

# Virtual key code mappings
VK_CODES: dict[str, int] = {
    # Function keys
    "F1": win32con.VK_F1,
    "F2": win32con.VK_F2,
    "F3": win32con.VK_F3,
    "F4": win32con.VK_F4,
    "F5": win32con.VK_F5,
    "F6": win32con.VK_F6,
    "F7": win32con.VK_F7,
    "F8": win32con.VK_F8,
    "F9": win32con.VK_F9,
    "F10": win32con.VK_F10,
    "F11": win32con.VK_F11,
    "F12": win32con.VK_F12,
    # Modifiers
    "CTRL": win32con.VK_CONTROL,
    "CONTROL": win32con.VK_CONTROL,
    "ALT": win32con.VK_MENU,
    "SHIFT": win32con.VK_SHIFT,
    "WIN": win32con.VK_LWIN,
    "LWIN": win32con.VK_LWIN,
    "RWIN": win32con.VK_RWIN,
    # Special keys
    "ENTER": win32con.VK_RETURN,
    "RETURN": win32con.VK_RETURN,
    "TAB": win32con.VK_TAB,
    "ESC": win32con.VK_ESCAPE,
    "ESCAPE": win32con.VK_ESCAPE,
    "SPACE": win32con.VK_SPACE,
    "BACKSPACE": win32con.VK_BACK,
    "BACK": win32con.VK_BACK,
    "DELETE": win32con.VK_DELETE,
    "DEL": win32con.VK_DELETE,
    "INSERT": win32con.VK_INSERT,
    "INS": win32con.VK_INSERT,
    "HOME": win32con.VK_HOME,
    "END": win32con.VK_END,
    "PAGEUP": win32con.VK_PRIOR,
    "PGUP": win32con.VK_PRIOR,
    "PAGEDOWN": win32con.VK_NEXT,
    "PGDN": win32con.VK_NEXT,
    # Arrow keys
    "UP": win32con.VK_UP,
    "DOWN": win32con.VK_DOWN,
    "LEFT": win32con.VK_LEFT,
    "RIGHT": win32con.VK_RIGHT,
    # Numbers
    "0": 0x30,
    "1": 0x31,
    "2": 0x32,
    "3": 0x33,
    "4": 0x34,
    "5": 0x35,
    "6": 0x36,
    "7": 0x37,
    "8": 0x38,
    "9": 0x39,
    # Letters
    "A": 0x41,
    "B": 0x42,
    "C": 0x43,
    "D": 0x44,
    "E": 0x45,
    "F": 0x46,
    "G": 0x47,
    "H": 0x48,
    "I": 0x49,
    "J": 0x4A,
    "K": 0x4B,
    "L": 0x4C,
    "M": 0x4D,
    "N": 0x4E,
    "O": 0x4F,
    "P": 0x50,
    "Q": 0x51,
    "R": 0x52,
    "S": 0x53,
    "T": 0x54,
    "U": 0x55,
    "V": 0x56,
    "W": 0x57,
    "X": 0x58,
    "Y": 0x59,
    "Z": 0x5A,
}

# Extended key codes that require special flag
EXTENDED_KEYS = {
    win32con.VK_UP,
    win32con.VK_DOWN,
    win32con.VK_LEFT,
    win32con.VK_RIGHT,
    win32con.VK_HOME,
    win32con.VK_END,
    win32con.VK_PRIOR,
    win32con.VK_NEXT,
    win32con.VK_INSERT,
    win32con.VK_DELETE,
}


def _key_down(vk_code: int) -> None:
    """Send key down event."""
    flags = 0
    if vk_code in EXTENDED_KEYS:
        flags |= win32con.KEYEVENTF_EXTENDEDKEY
    win32api.keybd_event(vk_code, 0, flags, 0)


def _key_up(vk_code: int) -> None:
    """Send key up event."""
    flags = win32con.KEYEVENTF_KEYUP
    if vk_code in EXTENDED_KEYS:
        flags |= win32con.KEYEVENTF_EXTENDEDKEY
    win32api.keybd_event(vk_code, 0, flags, 0)


class KeyboardController:
    """
    Keyboard control using Windows API.

    Features:
    - Hotkey combinations (e.g., CTRL+S)
    - Type text with paste mode (for Vietnamese)
    - Single key press/release
    """

    def __init__(self, key_delay_ms: int = 10) -> None:
        """
        Initialize keyboard controller.

        Args:
            key_delay_ms: Delay between key events
        """
        self._key_delay_ms = key_delay_ms

    def press_key(self, key: str) -> None:
        """
        Press and release a single key.

        Args:
            key: Key name (e.g., "A", "ENTER", "F5")
        """
        key_upper = key.upper()
        if key_upper not in VK_CODES:
            raise ValueError(f"Unknown key: {key}")

        vk_code = VK_CODES[key_upper]
        _key_down(vk_code)
        time.sleep(self._key_delay_ms / 1000.0)
        _key_up(vk_code)
        logger.debug("Pressed key: %s", key)

    def hotkey(self, keys: list[str]) -> None:
        """
        Press hotkey combination.

        Args:
            keys: List of keys to press together (e.g., ["CTRL", "S"])
        """
        if not keys:
            return

        vk_codes = []
        for key in keys:
            key_upper = key.upper()
            if key_upper not in VK_CODES:
                raise ValueError(f"Unknown key: {key}")
            vk_codes.append(VK_CODES[key_upper])

        # Press all keys down
        for vk in vk_codes:
            _key_down(vk)
            time.sleep(self._key_delay_ms / 1000.0)

        # Release in reverse order
        for vk in reversed(vk_codes):
            _key_up(vk)
            time.sleep(self._key_delay_ms / 1000.0)

        logger.debug("Hotkey: %s", "+".join(keys))

    def type_text(
        self,
        text: str,
        paste_mode: bool = True,
        enter: bool = False,
    ) -> None:
        """
        Type text.

        Args:
            text: Text to type
            paste_mode: Use clipboard paste (recommended for Vietnamese)
            enter: Press Enter after text
        """
        if not text:
            if enter:
                self.press_key("ENTER")
            return

        if paste_mode:
            self._paste_text(text)
        else:
            self._type_direct(text)

        if enter:
            time.sleep(0.05)
            self.press_key("ENTER")

        logger.debug(
            "Typed text: %s... (paste=%s)", text[:20] if len(text) > 20 else text, paste_mode
        )

    def _paste_text(self, text: str) -> None:
        """Type using clipboard paste (CTRL+V)."""
        # Save current clipboard
        try:
            win32clipboard.OpenClipboard()
            try:
                old_data = win32clipboard.GetClipboardData(win32clipboard.CF_UNICODETEXT)
            except Exception:
                old_data = None
            win32clipboard.EmptyClipboard()
            win32clipboard.SetClipboardData(win32clipboard.CF_UNICODETEXT, text)
            win32clipboard.CloseClipboard()
        except Exception as e:
            logger.warning("Clipboard error: %s", e)
            # Fallback to direct typing
            self._type_direct(text)
            return

        # Paste
        time.sleep(0.01)
        self.hotkey(["CTRL", "V"])
        time.sleep(0.05)

        # Restore clipboard
        try:
            win32clipboard.OpenClipboard()
            win32clipboard.EmptyClipboard()
            if old_data:
                win32clipboard.SetClipboardData(win32clipboard.CF_UNICODETEXT, old_data)
            win32clipboard.CloseClipboard()
        except Exception:
            pass

    def _type_direct(self, text: str) -> None:
        """Type directly using SendInput (for ASCII only)."""
        for char in text:
            if char.upper() in VK_CODES:
                # Simple letter/number
                vk = VK_CODES[char.upper()]
                need_shift = char.isupper() or char in '!@#$%^&*()_+{}|:"<>?'

                if need_shift:
                    _key_down(VK_CODES["SHIFT"])

                _key_down(vk)
                time.sleep(0.01)
                _key_up(vk)

                if need_shift:
                    _key_up(VK_CODES["SHIFT"])

                time.sleep(self._key_delay_ms / 1000.0)
            elif char == " ":
                self.press_key("SPACE")
            elif char == "\n":
                self.press_key("ENTER")
            elif char == "\t":
                self.press_key("TAB")
            else:
                # Use Unicode input for special characters
                logger.warning("Cannot type character: %r (use paste_mode=True)", char)

    def hold(self, key: str) -> None:
        """
        Hold a key down.

        Args:
            key: Key to hold
        """
        key_upper = key.upper()
        if key_upper not in VK_CODES:
            raise ValueError(f"Unknown key: {key}")
        _key_down(VK_CODES[key_upper])

    def release(self, key: str) -> None:
        """
        Release a held key.

        Args:
            key: Key to release
        """
        key_upper = key.upper()
        if key_upper not in VK_CODES:
            raise ValueError(f"Unknown key: {key}")
        _key_up(VK_CODES[key_upper])


================================================================================
FILE PATH: input\mouse.py
LINES: 178
================================================================================

"""
RetroAuto v2 - Mouse Controller

Smooth mouse control using pywin32 for Windows.
"""

import time

import win32api
import win32con

from infra import get_logger

logger = get_logger("Mouse")


class MouseController:
    """
    Mouse control using Windows API.

    Features:
    - Move to coordinates
    - Click (left/right/middle)
    - Double-click
    - Smooth movement (optional)
    """

    # Mouse button mappings
    BUTTONS = {
        "left": (win32con.MOUSEEVENTF_LEFTDOWN, win32con.MOUSEEVENTF_LEFTUP),
        "right": (win32con.MOUSEEVENTF_RIGHTDOWN, win32con.MOUSEEVENTF_RIGHTUP),
        "middle": (win32con.MOUSEEVENTF_MIDDLEDOWN, win32con.MOUSEEVENTF_MIDDLEUP),
    }

    def __init__(self, click_delay_ms: int = 80) -> None:
        """
        Initialize mouse controller.

        Args:
            click_delay_ms: Delay between clicks for multi-click
        """
        self._click_delay_ms = click_delay_ms

    @staticmethod
    def get_position() -> tuple[int, int]:
        """Get current cursor position."""
        return win32api.GetCursorPos()

    def move_to(self, x: int, y: int) -> None:
        """
        Move cursor to absolute coordinates.

        Args:
            x: X coordinate
            y: Y coordinate
        """
        win32api.SetCursorPos((x, y))
        logger.debug("Mouse moved to (%d, %d)", x, y)

    def move_relative(self, dx: int, dy: int) -> None:
        """Move cursor relative to current position."""
        x, y = self.get_position()
        self.move_to(x + dx, y + dy)

    def click(
        self,
        x: int | None = None,
        y: int | None = None,
        button: str = "left",
        clicks: int = 1,
        interval_ms: int | None = None,
    ) -> None:
        """
        Click at position.

        Args:
            x: X coordinate (None = current position)
            y: Y coordinate (None = current position)
            button: "left", "right", or "middle"
            clicks: Number of clicks
            interval_ms: Interval between clicks (None = use default)
        """
        if button not in self.BUTTONS:
            raise ValueError(f"Invalid button: {button}. Use 'left', 'right', or 'middle'")

        # Move if coordinates provided
        if x is not None and y is not None:
            self.move_to(x, y)

        down_flag, up_flag = self.BUTTONS[button]
        interval = (interval_ms if interval_ms is not None else self._click_delay_ms) / 1000.0

        for i in range(clicks):
            win32api.mouse_event(down_flag, 0, 0, 0, 0)
            time.sleep(0.01)  # Brief delay between down/up
            win32api.mouse_event(up_flag, 0, 0, 0, 0)

            if i < clicks - 1:
                time.sleep(interval)

        pos = self.get_position()
        logger.debug("Clicked %s x%d at (%d, %d)", button, clicks, pos[0], pos[1])

    def double_click(
        self,
        x: int | None = None,
        y: int | None = None,
        button: str = "left",
    ) -> None:
        """Double-click at position."""
        self.click(x, y, button, clicks=2, interval_ms=50)

    def right_click(
        self,
        x: int | None = None,
        y: int | None = None,
    ) -> None:
        """Right-click at position."""
        self.click(x, y, button="right")

    def drag(
        self,
        start_x: int,
        start_y: int,
        end_x: int,
        end_y: int,
        button: str = "left",
        duration_ms: int = 100,
    ) -> None:
        """
        Drag from start to end position.

        Args:
            start_x, start_y: Start position
            end_x, end_y: End position
            button: Button to hold during drag
            duration_ms: Duration of drag movement
        """
        if button not in self.BUTTONS:
            raise ValueError(f"Invalid button: {button}")

        down_flag, up_flag = self.BUTTONS[button]

        # Move to start
        self.move_to(start_x, start_y)
        time.sleep(0.01)

        # Press down
        win32api.mouse_event(down_flag, 0, 0, 0, 0)

        # Move to end (simple linear interpolation)
        steps = max(1, duration_ms // 10)
        for i in range(1, steps + 1):
            progress = i / steps
            x = int(start_x + (end_x - start_x) * progress)
            y = int(start_y + (end_y - start_y) * progress)
            self.move_to(x, y)
            time.sleep(0.01)

        # Release
        win32api.mouse_event(up_flag, 0, 0, 0, 0)
        logger.debug("Dragged from (%d, %d) to (%d, %d)", start_x, start_y, end_x, end_y)

    def scroll(self, delta: int, x: int | None = None, y: int | None = None) -> None:
        """
        Scroll the mouse wheel.

        Args:
            delta: Scroll amount (positive = up, negative = down)
            x, y: Position to scroll at (None = current)
        """
        if x is not None and y is not None:
            self.move_to(x, y)

        # WHEEL_DELTA is 120
        wheel_delta = delta * 120
        win32api.mouse_event(win32con.MOUSEEVENTF_WHEEL, 0, 0, wheel_delta, 0)
        logger.debug("Scrolled %d at cursor position", delta)


================================================================================
FILE PATH: packaging\pyinstaller_spec.py
LINES: 90
================================================================================

"""
RetroAuto v2 - PyInstaller Spec File

Build: pyinstaller packaging/pyinstaller_spec.py
Output: dist/RetroAuto/

Note: SPECPATH, Analysis, PYZ, EXE, COLLECT are provided by PyInstaller runtime.
"""

# ruff: noqa: F821
# type: ignore

from pathlib import Path

project_root = Path(SPECPATH).parent  # noqa: F821

a = Analysis(  # noqa: F821
    [str(project_root / "app" / "main.py")],
    pathex=[str(project_root)],
    binaries=[],
    datas=[],
    hiddenimports=[
        "PySide6.QtCore",
        "PySide6.QtGui",
        "PySide6.QtWidgets",
        "core",
        "core.models",
        "core.templates",
        "core.script",
        "core.script.io",
        "core.engine",
        "core.engine.runner",
        "core.engine.context",
        "core.engine.interrupts",
        "vision",
        "vision.capture",
        "vision.matcher",
        "vision.waiter",
        "input",
        "input.mouse",
        "input.keyboard",
        "infra",
        "infra.logging",
        "infra.config",
        "infra.hotkeys",
        "app.ui",
        "app.ui.main_window",
        "app.ui.assets_panel",
        "app.ui.actions_panel",
        "app.ui.properties_panel",
        "app.ui.log_panel",
        "app.ui.capture_tool",
        "app.ui.roi_editor",
        "app.ui.engine_worker",
        "pydantic",
        "pydantic_core",
        "ruamel.yaml",
        "cv2",
        "numpy",
        "mss",
        "win32api",
        "win32con",
        "win32clipboard",
    ],
    excludes=["tkinter", "matplotlib", "scipy", "pandas"],
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name="RetroAuto",
    debug=False,
    console=False,
    icon=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    name="RetroAuto",
)


================================================================================
FILE PATH: scripts\deep_check.py
LINES: 351
================================================================================

#!/usr/bin/env python3
"""
RetroAuto v2 - Deep Code Analysis

Extended 7-layer code quality analysis:
1. Syntax Check - Python syntax errors
2. Import Check - Missing dependencies
3. Lint Check - Ruff (style, bugs, unused code)
4. Format Check - Black formatting
5. Type Check - Mypy type errors
6. Security Check - Bandit vulnerabilities
7. Test Check - Pytest functional tests

Additional Analysis:
- Dead code detection
- Complexity analysis (McCabe)
- Dependency impact analysis

Usage:
    python scripts/deep_check.py           # Quick check (layers 1-5)
    python scripts/deep_check.py --full    # Full check (all 7 layers)
    python scripts/deep_check.py --fix     # Auto-fix issues
    python scripts/deep_check.py --deep    # Extended analysis
"""

import argparse
import json
import os
import subprocess
import sys
import time
from collections.abc import Callable
from dataclasses import dataclass, field
from pathlib import Path

# Force UTF-8 output on Windows
if sys.platform == "win32":
    os.environ["PYTHONIOENCODING"] = "utf-8"
    sys.stdout.reconfigure(encoding="utf-8", errors="replace")  # type: ignore
    sys.stderr.reconfigure(encoding="utf-8", errors="replace")  # type: ignore

# Configuration
PROJECT_ROOT = Path(__file__).parent.parent
CHECK_DIRS = ["app", "core", "vision", "input", "infra"]


@dataclass
class CheckResult:
    """Result of a single check."""

    name: str
    passed: bool
    duration: float
    errors: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)
    fixed: int = 0


def run_cmd(cmd: list[str], timeout: int = 120) -> tuple[int, str]:
    """Run command and return (returncode, output)."""
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            cwd=PROJECT_ROOT,
            timeout=timeout,
            encoding="utf-8",
            errors="replace",
        )
        return result.returncode, result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        return -1, "Command timed out"
    except Exception as e:
        return -1, str(e)


def timed_check(
    name: str, check_func: Callable[[], tuple[bool, list[str], list[str]]]
) -> CheckResult:
    """Run a check with timing."""
    start = time.time()
    try:
        passed, errors, warnings = check_func()
    except Exception as e:
        passed, errors, warnings = False, [str(e)], []
    duration = time.time() - start
    return CheckResult(
        name=name, passed=passed, duration=duration, errors=errors, warnings=warnings
    )


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Layer 1: Syntax Check
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
def check_syntax() -> tuple[bool, list[str], list[str]]:
    """Check Python syntax."""
    errors = []
    for dir_name in CHECK_DIRS:
        dir_path = PROJECT_ROOT / dir_name
        if not dir_path.exists():
            continue
        for py_file in dir_path.rglob("*.py"):
            code, output = run_cmd([sys.executable, "-m", "py_compile", str(py_file)])
            if code != 0:
                errors.append(f"{py_file.relative_to(PROJECT_ROOT)}: {output.strip()[:100]}")
    return len(errors) == 0, errors, []


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Layer 2: Import Check
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
def check_imports() -> tuple[bool, list[str], list[str]]:
    """Check that critical modules can be imported."""
    errors = []
    modules = [
        "app.main",
        "core.models",
        "core.engine.runner",
        "core.dsl.lexer",
        "core.dsl.parser",
    ]
    for module in modules:
        code, output = run_cmd([sys.executable, "-c", f"import {module}"])
        if code != 0:
            errors.append(f"{module}: {output.strip()[:80]}")
    return len(errors) == 0, errors, []


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Layer 3: Lint Check (Ruff)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
def check_lint(fix: bool = False) -> tuple[bool, list[str], list[str]]:
    """Run Ruff linter."""
    cmd = [sys.executable, "-m", "ruff", "check", "."]
    if fix:
        cmd.append("--fix")

    code, output = run_cmd(cmd)

    if code != 0:
        lines = [l for l in output.strip().split("\n") if ": " in l][:20]
        return False, lines, []
    return True, [], []


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Layer 4: Format Check (Black)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
def check_format(fix: bool = False) -> tuple[bool, list[str], list[str]]:
    """Check Black formatting."""
    cmd = [sys.executable, "-m", "black", "--check", "."]
    if fix:
        cmd = [sys.executable, "-m", "black", "."]

    code, output = run_cmd(cmd)

    if code != 0 and not fix:
        lines = [l for l in output.strip().split("\n") if "would reformat" in l.lower()][:10]
        return False, lines, []
    return True, [], []


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Layer 5: Type Check (Mypy)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
def check_types() -> tuple[bool, list[str], list[str]]:
    """Run Mypy type checker."""
    cmd = [sys.executable, "-m", "mypy", "core/"]
    code, output = run_cmd(cmd, timeout=180)

    if code != 0:
        errors = [l for l in output.strip().split("\n") if ": error:" in l][:15]
        warnings = [l for l in output.strip().split("\n") if ": note:" in l][:5]
        if not errors:  # Only warnings
            return True, [], warnings
        return False, errors, warnings
    return True, [], []


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Layer 6: Security Check (Bandit)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
def check_security() -> tuple[bool, list[str], list[str]]:
    """Run Bandit security scanner."""
    cmd = [
        sys.executable,
        "-m",
        "bandit",
        "-r",
        "core/",
        "app/",
        "-f",
        "json",
        "-ll",  # Low and above
        "--quiet",
    ]
    code, output = run_cmd(cmd)

    try:
        data = json.loads(output)
        issues = data.get("results", [])
        if issues:
            errors = []
            for issue in issues[:10]:
                severity = issue.get("issue_severity", "UNKNOWN")
                text = issue.get("issue_text", "")
                file = issue.get("filename", "")
                line = issue.get("line_number", 0)
                errors.append(f"[{severity}] {file}:{line} - {text}")
            return len([i for i in issues if i.get("issue_severity") == "HIGH"]) == 0, errors, []
        return True, [], []
    except json.JSONDecodeError:
        # Bandit not installed or other error
        return True, [], ["Bandit not installed, skipping security check"]


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Layer 7: Test Check (Pytest)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
def check_tests(full: bool = False) -> tuple[bool, list[str], list[str]]:
    """Run pytest tests."""
    cmd = [sys.executable, "-m", "pytest", "tests/", "-q", "--tb=line"]
    if not full:
        cmd.append("-x")  # Stop on first failure

    code, output = run_cmd(cmd, timeout=300)

    if code != 0:
        lines = output.strip().split("\n")
        errors = [l for l in lines if "FAILED" in l or "ERROR" in l][:10]
        return False, errors, []
    return True, [], []


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Extended Analysis
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
def check_complexity() -> tuple[bool, list[str], list[str]]:
    """Check code complexity using Ruff's McCabe checker."""
    cmd = [sys.executable, "-m", "ruff", "check", ".", "--select=C901"]
    code, output = run_cmd(cmd)

    if code != 0:
        lines = [l for l in output.strip().split("\n") if "C901" in l][:10]
        return False, [], lines  # Complexity as warnings, not errors
    return True, [], []


def check_dead_code() -> tuple[bool, list[str], list[str]]:
    """Check for unused code using Ruff's F841, F401."""
    cmd = [sys.executable, "-m", "ruff", "check", ".", "--select=F401,F841"]
    code, output = run_cmd(cmd)

    if code != 0:
        lines = [l for l in output.strip().split("\n") if l.strip()][:15]
        return True, [], lines  # Dead code as warnings
    return True, [], []


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Main Pipeline
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
def run_pipeline(full: bool = False, fix: bool = False, deep: bool = False) -> int:
    """Run the full check pipeline."""
    print("=" * 70)
    print("  RetroAuto v2 - Deep Code Analysis")
    print("  Mode:", "FULL" if full else "QUICK", "| Fix:", "ON" if fix else "OFF")
    print("=" * 70)

    results: list[CheckResult] = []

    # Layer 1-5 (Always run)
    checks = [
        ("1. Syntax", lambda: check_syntax()),
        ("2. Imports", lambda: check_imports()),
        ("3. Lint (Ruff)", lambda: check_lint(fix)),
        ("4. Format (Black)", lambda: check_format(fix)),
        ("5. Types (Mypy)", lambda: check_types()),
    ]

    # Layer 6-7 (Full mode)
    if full:
        checks.extend(
            [
                ("6. Security (Bandit)", lambda: check_security()),
                ("7. Tests (Pytest)", lambda: check_tests(full)),
            ]
        )

    # Extended analysis
    if deep:
        checks.extend(
            [
                ("8. Complexity", lambda: check_complexity()),
                ("9. Dead Code", lambda: check_dead_code()),
            ]
        )

    for name, check_func in checks:
        print(f"\nüîç {name}...")
        result = timed_check(name, check_func)
        results.append(result)

        status = "‚úÖ PASS" if result.passed else "‚ùå FAIL"
        print(f"   {status} ({result.duration:.2f}s)")

        for err in result.errors[:5]:
            print(f"   ‚îú‚îÄ {err[:90]}")
        for warn in result.warnings[:3]:
            print(f"   ‚îî‚îÄ ‚ö†Ô∏è {warn[:90]}")

    # Summary
    print("\n" + "=" * 70)
    print("  Summary")
    print("=" * 70)

    total_time = sum(r.duration for r in results)
    passed = sum(1 for r in results if r.passed)
    failed = sum(1 for r in results if not r.passed)

    for r in results:
        status = "‚úÖ" if r.passed else "‚ùå"
        print(f"  {status} {r.name:25s} ({r.duration:.2f}s)")

    print(f"\n  Total: {passed} passed, {failed} failed ({total_time:.2f}s)")

    if failed == 0:
        print("\n  üéâ All checks passed! Ready to commit.")
        return 0
    else:
        print("\n  ‚ö†Ô∏è  Some checks failed. Fix before committing.")
        return 1


def main() -> int:
    parser = argparse.ArgumentParser(description="Deep Code Analysis")
    parser.add_argument(
        "--full", action="store_true", help="Run all 7 layers including security and tests"
    )
    parser.add_argument("--fix", action="store_true", help="Auto-fix lint and format issues")
    parser.add_argument(
        "--deep", action="store_true", help="Extended analysis (complexity, dead code)"
    )
    args = parser.parse_args()

    return run_pipeline(full=args.full, fix=args.fix, deep=args.deep)


if __name__ == "__main__":
    sys.exit(main())


================================================================================
FILE PATH: scripts\dev_watcher.py
LINES: 237
================================================================================

#!/usr/bin/env python3
"""
RetroAuto v2 - Development File Watcher

Watches for Python file changes and runs checks + auto-commit.

Features:
- Real-time file change detection
- Quick lint check on save
- Auto-fix option
- AUTO-COMMIT after successful check
- Version bump on commit

Usage:
    python scripts/dev_watcher.py              # Check only
    python scripts/dev_watcher.py --fix        # Auto-fix + check
    python scripts/dev_watcher.py --auto       # Auto-fix + check + commit

Press Ctrl+C to stop.
"""

import argparse
import subprocess
import sys
import time
from pathlib import Path

# Try to import watchdog
try:
    from watchdog.events import FileModifiedEvent, FileSystemEventHandler
    from watchdog.observers import Observer

    HAS_WATCHDOG = True
except ImportError:
    HAS_WATCHDOG = False
    print("‚ö†Ô∏è  watchdog not installed. Run: pip install watchdog")
    sys.exit(1)

PROJECT_ROOT = Path(__file__).parent.parent
WATCH_DIRS = ["app", "core", "vision", "input", "infra"]
DEBOUNCE_SECONDS = 2.0  # Increased debounce for auto-commit


class CodeCheckHandler(FileSystemEventHandler):
    """Handle file system events."""

    def __init__(self, fix: bool = False, auto_commit: bool = False):
        self.fix = fix
        self.auto_commit = auto_commit
        self._last_check: dict[str, float] = {}
        self._checking = False
        self._pending_changes: list[str] = []

    def on_modified(self, event):
        if self._checking:
            return

        if not isinstance(event, FileModifiedEvent):
            return

        path = Path(event.src_path)

        # Only Python files
        if path.suffix != ".py":
            return

        # Ignore __pycache__
        if "__pycache__" in str(path):
            return

        # Debounce - don't check same file within threshold
        now = time.time()
        last = self._last_check.get(str(path), 0)
        if now - last < DEBOUNCE_SECONDS:
            return
        self._last_check[str(path)] = now

        self._run_quick_check(path)

    def _run_quick_check(self, path: Path):
        """Run quick check on a single file."""
        self._checking = True
        rel_path = path.relative_to(PROJECT_ROOT)
        print(f"\n{'='*60}")
        print(f"üìù File changed: {rel_path}")
        print(f"{'='*60}")

        all_passed = True

        # 1. Syntax check
        result = subprocess.run(
            [sys.executable, "-m", "py_compile", str(path)],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            print(f"‚ùå Syntax Error: {result.stderr.strip()[:100]}")
            all_passed = False
        else:
            print("‚úÖ Syntax OK")

        # 2. Ruff check + fix (single file)
        cmd = [sys.executable, "-m", "ruff", "check", str(path)]
        if self.fix:
            cmd.extend(["--fix", "--unsafe-fixes"])

        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0 and not self.fix:
            print("‚ö†Ô∏è  Lint issues found")
            all_passed = False
        else:
            print("‚úÖ Lint OK" + (" (auto-fixed)" if self.fix else ""))

        # 3. Black format (single file)
        if self.fix:
            subprocess.run(
                [sys.executable, "-m", "black", str(path), "-q"],
                capture_output=True,
            )
            print("‚úÖ Formatted")

        # 4. Auto-commit if enabled and all passed
        if all_passed and self.auto_commit:
            self._auto_commit(rel_path)
        elif all_passed:
            print("\nüéâ All checks passed!")
        else:
            print("\n‚ö†Ô∏è  Fix issues before commit")

        self._checking = False

    def _auto_commit(self, changed_file: Path):
        """Auto version bump + commit + push."""
        print("\nüöÄ Auto-committing...")

        try:
            # 1. Version bump
            result = subprocess.run(
                [sys.executable, "scripts/version_bump.py", "--patch"],
                capture_output=True,
                text=True,
                cwd=PROJECT_ROOT,
            )
            version_line = result.stdout.strip()
            print(f"   {version_line}")

            # 2. Get new version
            result = subprocess.run(
                [sys.executable, "scripts/version_bump.py", "--show"],
                capture_output=True,
                text=True,
                cwd=PROJECT_ROOT,
            )
            version = result.stdout.strip()

            # 3. Git add all
            subprocess.run(
                ["git", "add", "-A"],
                cwd=PROJECT_ROOT,
                capture_output=True,
            )

            # 4. Git commit
            commit_msg = f"Auto: v{version} - {changed_file}"
            result = subprocess.run(
                ["git", "commit", "-m", commit_msg, "--no-verify"],
                cwd=PROJECT_ROOT,
                capture_output=True,
                text=True,
            )
            if result.returncode == 0:
                print(f"   ‚úÖ Committed: {commit_msg}")
            else:
                if "nothing to commit" in result.stdout:
                    print("   ‚ÑπÔ∏è  No changes to commit")
                else:
                    print(f"   ‚ö†Ô∏è  Commit failed: {result.stderr[:50]}")
                return

            # 5. Git push
            result = subprocess.run(
                ["git", "push", "origin", "master"],
                cwd=PROJECT_ROOT,
                capture_output=True,
                text=True,
            )
            if result.returncode == 0:
                print("   ‚úÖ Pushed to master")
            else:
                print(f"   ‚ö†Ô∏è  Push failed: {result.stderr[:50]}")

        except Exception as e:
            print(f"   ‚ùå Auto-commit error: {e}")


def main():
    parser = argparse.ArgumentParser(description="Development File Watcher")
    parser.add_argument("--fix", action="store_true", help="Auto-fix issues on save")
    parser.add_argument("--auto", action="store_true", help="Auto-commit after successful check")
    args = parser.parse_args()

    # --auto implies --fix
    if args.auto:
        args.fix = True

    print("=" * 60)
    print("  RetroAuto v2 - Development Watcher")
    print("=" * 60)
    mode = "AUTO-COMMIT" if args.auto else ("Auto-Fix" if args.fix else "Check Only")
    print(f"  Mode: {mode}")
    print(f"  Watching: {', '.join(WATCH_DIRS)}")
    print("  Press Ctrl+C to stop")
    print("=" * 60)

    handler = CodeCheckHandler(fix=args.fix, auto_commit=args.auto)
    observer = Observer()

    for dir_name in WATCH_DIRS:
        dir_path = PROJECT_ROOT / dir_name
        if dir_path.exists():
            observer.schedule(handler, str(dir_path), recursive=True)
            print(f"  üëÅÔ∏è  Watching: {dir_name}/")

    observer.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
        print("\n\nüëã Watcher stopped.")

    observer.join()


if __name__ == "__main__":
    main()


================================================================================
FILE PATH: scripts\generate_changelog.py
LINES: 198
================================================================================

#!/usr/bin/env python3
"""
RetroAuto v2 - Changelog Generator

Generates CHANGELOG.md from git commits since last release.

Features:
- Groups commits by type (Added, Changed, Fixed)
- Extracts version bumps
- Maintains history between runs

Usage:
    python scripts/generate_changelog.py           # Generate/update changelog
    python scripts/generate_changelog.py --since 2.0.0  # Since specific version
"""

import argparse
import re
import subprocess
import sys
from datetime import datetime
from pathlib import Path

PROJECT_ROOT = Path(__file__).parent.parent
CHANGELOG_PATH = PROJECT_ROOT / "docs" / "CHANGELOG.md"


def get_current_version() -> str:
    """Get current version from pyproject.toml."""
    pyproject = PROJECT_ROOT / "pyproject.toml"
    content = pyproject.read_text(encoding="utf-8")
    match = re.search(r'version = "(\d+\.\d+\.\d+)"', content)
    return match.group(1) if match else "0.0.0"


def get_git_commits(since_tag: str | None = None, limit: int = 50) -> list[dict]:
    """Get git commits with parsed info."""
    cmd = ["git", "log", f"-{limit}", "--pretty=format:%H|%s|%ai"]
    if since_tag:
        cmd.insert(2, f"{since_tag}..HEAD")

    result = subprocess.run(cmd, capture_output=True, text=True, cwd=PROJECT_ROOT)
    if result.returncode != 0:
        return []

    commits = []
    for line in result.stdout.strip().split("\n"):
        if not line:
            continue
        parts = line.split("|")
        if len(parts) >= 3:
            commits.append(
                {
                    "hash": parts[0][:7],
                    "message": parts[1],
                    "date": parts[2][:10],
                }
            )
    return commits


def categorize_commit(message: str) -> str | None:
    """Categorize commit message into changelog sections."""
    msg_lower = message.lower()

    # Feature patterns
    if any(p in msg_lower for p in ["feat:", "feature:", "add:", "added", "new:", "implement"]):
        return "Added"

    # Fix patterns
    if any(p in msg_lower for p in ["fix:", "fixed", "bug:", "bugfix", "hotfix"]):
        return "Fixed"

    # Change patterns
    if any(p in msg_lower for p in ["change:", "update:", "refactor:", "improve", "config:"]):
        return "Changed"

    # Remove patterns
    if any(p in msg_lower for p in ["remove:", "delete:", "deprecate"]):
        return "Removed"

    # Auto-commits
    if msg_lower.startswith("auto:"):
        return "Changed"

    # Skip docs, chore, etc.
    if any(p in msg_lower for p in ["docs:", "chore:", "test:", "ci:", "merge"]):
        return None

    return "Changed"  # Default


def clean_commit_message(message: str) -> str:
    """Clean up commit message for changelog."""
    # Remove prefixes
    prefixes = ["feat:", "fix:", "chore:", "docs:", "refactor:", "auto:", "config:"]
    for prefix in prefixes:
        if message.lower().startswith(prefix):
            message = message[len(prefix) :].strip()
            break

    # Capitalize first letter
    if message:
        message = message[0].upper() + message[1:]

    return message


def generate_changelog_section(version: str, commits: list[dict]) -> str:
    """Generate a changelog section for a version."""
    today = datetime.now().strftime("%Y-%m-%d")

    lines = [
        f"## [{version}] - {today}",
        "",
    ]

    # Group by category
    categories: dict[str, list[str]] = {}
    for commit in commits:
        cat = categorize_commit(commit["message"])
        if cat:
            clean_msg = clean_commit_message(commit["message"])
            categories.setdefault(cat, []).append(f"- {clean_msg}")

    # Output in order
    for cat in ["Added", "Changed", "Fixed", "Removed"]:
        if cat in categories:
            lines.append(f"### {cat}")
            lines.extend(categories[cat])
            lines.append("")

    return "\n".join(lines)


def update_changelog(new_section: str) -> bool:
    """Update CHANGELOG.md with new section."""
    if CHANGELOG_PATH.exists():
        content = CHANGELOG_PATH.read_text(encoding="utf-8")
        # Check if this version already exists
        version = re.search(r"\[(\d+\.\d+\.\d+)\]", new_section)
        if version and f"[{version.group(1)}]" in content:
            # Update existing section (find and replace)
            print(f"   ‚ÑπÔ∏è  Version {version.group(1)} already in changelog")
            return False

        # Insert after header
        if "# Changelog" in content:
            parts = content.split("\n## ", 1)
            if len(parts) == 2:
                new_content = f"{parts[0]}\n{new_section}\n## {parts[1]}"
            else:
                new_content = f"{content}\n\n{new_section}"
        else:
            new_content = f"# Changelog\n\n{new_section}\n\n{content}"
    else:
        new_content = f"# Changelog\n\nAll notable changes to RetroAuto v2.\n\n{new_section}"

    CHANGELOG_PATH.write_text(new_content, encoding="utf-8")
    return True


def main():
    parser = argparse.ArgumentParser(description="Generate changelog")
    parser.add_argument("--since", type=str, help="Generate since specific tag/version")
    parser.add_argument("--limit", type=int, default=30, help="Max commits to process")
    args = parser.parse_args()

    print("=" * 60)
    print("  RetroAuto v2 - Changelog Generator")
    print("=" * 60)

    version = get_current_version()
    print(f"\nüì¶ Current version: {version}")

    print("\nüìú Fetching git commits...")
    commits = get_git_commits(since_tag=args.since, limit=args.limit)
    print(f"   Found {len(commits)} commits")

    if not commits:
        print("   ‚ÑπÔ∏è  No new commits to add")
        return 0

    print("\nüìù Generating changelog section...")
    section = generate_changelog_section(version, commits)

    print("\nüíæ Updating CHANGELOG.md...")
    if update_changelog(section):
        print("   ‚úÖ Changelog updated!")
    else:
        print("   ‚ÑπÔ∏è  No changes made")

    print(f"\nüìÑ Changelog saved to: {CHANGELOG_PATH}")
    return 0


if __name__ == "__main__":
    sys.exit(main())


================================================================================
FILE PATH: scripts\generate_pdf_html.py
LINES: 97
================================================================================

import os
import re

# 1. Config
SOURCE_DIR = "docs/user_guide"
OUTPUT_FILE = "docs/RetroAuto_UserGuide_v5.html"
CSS = """
<style>
    @import url('https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;1,400&family=JetBrains+Mono:wght@400;600&display=swap');

    body {
        font-family: 'Merriweather', serif;
        line-height: 1.6;
        color: #333;
        max-width: 800px;
        margin: 0 auto;
        padding: 40px;
    }
    h1, h2, h3 { font-family: sans-serif; color: #2c3e50; }
    h1 { border-bottom: 2px solid #eee; padding-bottom: 10px; break-before: always; page-break-before: always; }
    h2 { margin-top: 30px; border-bottom: 1px solid #eee; }
    code { font-family: 'JetBrains Mono', monospace; background: #f4f4f4; padding: 2px 5px; border-radius: 3px; font-size: 0.9em; }
    pre { background: #f8f8f8; padding: 15px; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
    pre code { background: none; padding: 0; }
    blockquote { border-left: 4px solid #3498db; margin: 0; padding-left: 15px; color: #555; background: #f1f9ff; padding: 10px; }
    table { border-collapse: collapse; width: 100%; margin: 20px 0; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #f2f2f2; }
    img { max-width: 100%; height: auto; display: block; margin: 20px auto; }

    @media print {
        body { max-width: 100%; padding: 0; }
        a { text-decoration: none; color: #333; }
        pre, blockquote { page-break-inside: avoid; }
        h1 { page-break-before: always; }
        h1:first-child { page-break-before: avoid; }
    }
</style>
"""

# 2. Reading Order
FILES = [
    "01_start.md",
    "02_ide_visual.md",
    "03_ide_code.md",
    "04_concepts.md",
    "05_cookbook.md",
    "06_troubleshooting.md",
    "07_reference.md",
]

# 3. Processing
content_html = ""
for fname in FILES:
    path = os.path.join(SOURCE_DIR, fname)
    if os.path.exists(path):
        with open(path, encoding="utf-8") as f:
            md = f.read()
            # Simple Markdown to HTML fallback (since we might not have 'markdown' lib)
            # 1. Headers
            md = re.sub(r"^# (.*)", r"<h1>\1</h1>", md, flags=re.MULTILINE)
            md = re.sub(r"^## (.*)", r"<h2>\1</h2>", md, flags=re.MULTILINE)
            md = re.sub(r"^### (.*)", r"<h3>\1</h3>", md, flags=re.MULTILINE)
            # 2. Bold/Italic
            md = re.sub(r"\*\*(.*?)\*\*", r"<b>\1</b>", md)
            md = re.sub(r"`(.*?)`", r"<code>\1</code>", md)
            # 3. Code Blocks
            md = re.sub(r"```(.*?)```", r"<pre><code>\1</code></pre>", md, flags=re.DOTALL)
            # 4. Images
            md = re.sub(r"!\[(.*?)\]\((.*?)\)", r'<img src="\2" alt="\1">', md)

            content_html += f"<section class='chapter'>{md}</section>\n"

# 4. Wrap
final_html = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>RetroAuto v2 - User Guide v5.0</title>
    {CSS}
</head>
<body>
    <div style="text-align: center; padding: 50px 0; page-break-after: always;">
        <h1 style="font-size: 3em; border: none;">RetroAuto v2</h1>
        <h2 style="font-size: 2em; border: none; color: #555;">The Encyclopedia (v5.0)</h2>
        <p>Generated: 2025-12-23</p>
    </div>
    {content_html}
</body>
</html>
"""

with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
    f.write(final_html)

print(f"‚úÖ Generated: {OUTPUT_FILE}")


================================================================================
FILE PATH: scripts\sync_docs.py
LINES: 283
================================================================================

#!/usr/bin/env python3
"""
RetroAuto v2 - Documentation Sync

Automatically updates user guide documentation from code docstrings.

Features:
- Extracts action signatures from core/models.py
- Extracts DSL commands from core/dsl/tokens.py
- Updates 07_reference.md with auto-generated sections
- Preserves manual content outside auto-generated blocks

Usage:
    python scripts/sync_docs.py           # Sync all docs
    python scripts/sync_docs.py --check   # Check if docs are up-to-date
    python scripts/sync_docs.py --verbose # Show extracted docstrings
"""

import argparse
import ast
import re
import sys
from dataclasses import dataclass
from pathlib import Path

PROJECT_ROOT = Path(__file__).parent.parent
DOCS_DIR = PROJECT_ROOT / "docs" / "user_guide"
MODELS_FILE = PROJECT_ROOT / "core" / "models.py"
TOKENS_FILE = PROJECT_ROOT / "core" / "dsl" / "tokens.py"

# Markers for auto-generated sections
AUTO_START = "<!-- AUTO-GENERATED: START -->"
AUTO_END = "<!-- AUTO-GENERATED: END -->"


@dataclass
class ActionDoc:
    """Documentation for an action."""

    name: str
    signature: str
    docstring: str
    category: str


def extract_action_docs(file_path: Path) -> list[ActionDoc]:
    """Extract action class documentation from models.py."""
    actions = []

    if not file_path.exists():
        return actions

    try:
        tree = ast.parse(file_path.read_text(encoding="utf-8"))
    except SyntaxError:
        return actions

    # Categories based on class names
    categories = {
        "Click": "üéØ Mouse Actions",
        "Drag": "üéØ Mouse Actions",
        "Scroll": "üéØ Mouse Actions",
        "Wait": "üëÅÔ∏è Vision & Wait",
        "If": "üîÄ Conditionals",
        "While": "üîÅ Loops",
        "Type": "‚å®Ô∏è Keyboard",
        "Hotkey": "‚å®Ô∏è Keyboard",
        "Read": "üìñ OCR",
        "Notify": "üì¢ Notifications",
        "Run": "üîß Flow Control",
        "Goto": "üîß Flow Control",
        "Label": "üîß Flow Control",
        "Delay": "‚è±Ô∏è Timing",
        "Loop": "üîÅ Loops",
    }

    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            # Skip non-action classes
            if not any(node.name.startswith(prefix) for prefix in categories):
                continue

            # Get docstring
            docstring = ast.get_docstring(node) or ""

            # Build signature from class fields
            fields = []
            for item in node.body:
                if isinstance(item, ast.AnnAssign) and isinstance(item.target, ast.Name):
                    field_name = item.target.id
                    if field_name not in ["action", "comment"]:
                        fields.append(field_name)

            signature = f"{node.name}({', '.join(fields)})" if fields else node.name

            # Determine category
            category = "üîß Other"
            for prefix, cat in categories.items():
                if node.name.startswith(prefix):
                    category = cat
                    break

            actions.append(
                ActionDoc(
                    name=node.name,
                    signature=signature,
                    docstring=docstring.split("\n")[0] if docstring else "",
                    category=category,
                )
            )

    return actions


def extract_dsl_commands(file_path: Path) -> list[tuple[str, str]]:
    """Extract DSL command tokens from tokens.py."""
    commands = []

    if not file_path.exists():
        return commands

    content = file_path.read_text(encoding="utf-8")

    # Find TokenType enum members
    pattern = r"(\w+)\s*=\s*auto\(\)\s*#\s*(.+)"
    for match in re.finditer(pattern, content):
        token_name = match.group(1)
        description = match.group(2).strip()

        # Filter to actual commands (not structural tokens)
        if token_name.isupper() and not token_name.startswith("_"):
            commands.append((token_name.lower(), description))

    return commands


def generate_reference_section(actions: list[ActionDoc]) -> str:
    """Generate markdown reference section from actions."""
    lines = [
        "## Auto-Generated Action Reference",
        "",
        "> *T·ª± ƒë·ªông t·∫°o t·ª´ `core/models.py`. C·∫≠p nh·∫≠t l·∫ßn cu·ªëi: "
        + __import__("datetime").datetime.now().strftime("%Y-%m-%d %H:%M")
        + "*",
        "",
    ]

    # Group by category
    by_category: dict[str, list[ActionDoc]] = {}
    for action in actions:
        by_category.setdefault(action.category, []).append(action)

    for category, cat_actions in sorted(by_category.items()):
        lines.append(f"### {category}")
        lines.append("")
        for action in sorted(cat_actions, key=lambda a: a.name):
            lines.append(f"**`{action.signature}`**")
            if action.docstring:
                lines.append(f"  - {action.docstring}")
            lines.append("")

    return "\n".join(lines)


def update_reference_doc(reference_path: Path, new_content: str) -> bool:
    """Update reference.md with new auto-generated content."""
    if not reference_path.exists():
        return False

    content = reference_path.read_text(encoding="utf-8")

    # Find and replace auto-generated section
    if AUTO_START in content and AUTO_END in content:
        before = content.split(AUTO_START)[0]
        after = content.split(AUTO_END)[1]
        new_content_full = f"{before}{AUTO_START}\n{new_content}\n{AUTO_END}{after}"
    else:
        # Add auto-generated section at the end
        new_content_full = f"{content}\n\n---\n\n{AUTO_START}\n{new_content}\n{AUTO_END}\n"

    reference_path.write_text(new_content_full, encoding="utf-8")
    return True


def generate_features_list() -> str:
    """Generate a features list from the codebase."""
    features = []

    # Scan for feature markers in code
    for py_file in PROJECT_ROOT.rglob("*.py"):
        if "__pycache__" in str(py_file):
            continue
        try:
            content = py_file.read_text(encoding="utf-8", errors="ignore")
            # Look for feature docstrings
            if '"""' in content:
                match = re.search(r'"""([^"]+)"""', content)
                if match:
                    first_line = match.group(1).strip().split("\n")[0]
                    if len(first_line) < 100 and first_line:
                        rel_path = py_file.relative_to(PROJECT_ROOT)
                        features.append((str(rel_path), first_line))
        except Exception:
            continue

    return features


def main():
    parser = argparse.ArgumentParser(description="Sync documentation from code")
    parser.add_argument("--check", action="store_true", help="Check if docs need update")
    parser.add_argument("--verbose", action="store_true", help="Show extracted content")
    args = parser.parse_args()

    print("=" * 60)
    print("  RetroAuto v2 - Documentation Sync")
    print("=" * 60)

    # Extract action documentation
    print("\nüìö Extracting action documentation...")
    actions = extract_action_docs(MODELS_FILE)
    print(f"   Found {len(actions)} actions")

    if args.verbose:
        for action in actions:
            print(f"   - {action.name}: {action.docstring[:50]}...")

    # Extract DSL commands
    print("\nüìù Extracting DSL commands...")
    commands = extract_dsl_commands(TOKENS_FILE)
    print(f"   Found {len(commands)} commands")

    # Generate reference content
    print("\nüîÑ Generating reference content...")
    reference_content = generate_reference_section(actions)

    # Update reference.md
    reference_path = DOCS_DIR / "07_reference.md"
    if reference_path.exists():
        if args.check:
            current = reference_path.read_text(encoding="utf-8")
            if AUTO_START in current:
                print("   ‚ÑπÔ∏è  Reference has auto-generated section")
            else:
                print("   ‚ö†Ô∏è  Reference missing auto-generated section")
            return 0

        # Add auto-generated markers if missing
        content = reference_path.read_text(encoding="utf-8")
        if AUTO_START not in content:
            # Append at the end
            new_content = f"{content}\n\n---\n\n{AUTO_START}\n{reference_content}\n{AUTO_END}\n"
            reference_path.write_text(new_content, encoding="utf-8")
            print("   ‚úÖ Added auto-generated section to 07_reference.md")
        else:
            update_reference_doc(reference_path, reference_content)
            print("   ‚úÖ Updated auto-generated section in 07_reference.md")

    # Generate FEATURES.md
    features_path = PROJECT_ROOT / "docs" / "FEATURES.md"
    print("\nüìã Generating FEATURES.md...")

    features_content = [
        "# RetroAuto v2 - Feature List",
        "",
        "> *Auto-generated from codebase. Do not edit manually.*",
        "",
        "## Core Modules",
        "",
    ]

    for rel_path, desc in sorted(generate_features_list())[:30]:
        features_content.append(f"- **{rel_path}**: {desc}")

    features_path.write_text("\n".join(features_content), encoding="utf-8")
    print(f"   ‚úÖ Generated FEATURES.md ({len(generate_features_list())} modules)")

    print("\nüéâ Documentation sync complete!")
    return 0


if __name__ == "__main__":
    sys.exit(main())


================================================================================
FILE PATH: scripts\test_phase1_perf.py
LINES: 234
================================================================================

#!/usr/bin/env python3
"""
Performance Benchmark for Phase 1 Optimizations

Tests:
1. Adaptive Interrupt Scan Interval
2. OCR Result Caching
3. Image Cache TTL

Run: python scripts/test_phase1_perf.py
"""

import sys
import time
from pathlib import Path

# Setup path
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))


def test_adaptive_scan_interval():
    """Test adaptive interrupt scan interval calculation."""
    print("\n" + "=" * 60)
    print("TEST 1: Adaptive Interrupt Scan Interval")
    print("=" * 60)

    from core.engine.context import EngineState, ExecutionContext
    from core.models import Script

    # Create mock scanner to test interval logic
    class MockScanner:
        def __init__(self):
            self._interval_idle = 0.5
            self._interval_active = 0.2
            self._interval_fast = 0.1
            self._last_scan_had_activity = False

        def _get_adaptive_interval(self, state: EngineState, had_activity: bool) -> float:
            self._last_scan_had_activity = had_activity
            if state == EngineState.IDLE:
                return self._interval_idle
            elif state == EngineState.RUNNING:
                if self._last_scan_had_activity:
                    return self._interval_fast
                return self._interval_active
            else:
                return self._interval_active

    scanner = MockScanner()

    # Test cases
    tests = [
        (EngineState.IDLE, False, 0.5, "Idle state"),
        (EngineState.RUNNING, False, 0.2, "Running, no activity"),
        (EngineState.RUNNING, True, 0.1, "Running with activity"),
        (EngineState.PAUSED, False, 0.2, "Paused state"),
    ]

    all_passed = True
    for state, activity, expected, desc in tests:
        result = scanner._get_adaptive_interval(state, activity)
        passed = abs(result - expected) < 0.001
        status = "‚úÖ PASS" if passed else "‚ùå FAIL"
        print(f"  {status} {desc}: {result*1000:.0f}ms (expected {expected*1000:.0f}ms)")
        if not passed:
            all_passed = False

    return all_passed


def test_ocr_cache():
    """Test OCR result caching."""
    print("\n" + "=" * 60)
    print("TEST 2: OCR Result Caching")
    print("=" * 60)

    from PIL import Image

    from vision.ocr import TextReader

    reader = TextReader(cache_ttl=2.0)

    # Check cache is initialized
    print(f"  Cache TTL: {reader._cache_ttl}s")
    print(f"  Cache max size: {reader._cache_max_size}")

    # Test hash computation
    img = Image.new("RGB", (100, 50), color="white")
    hash1 = reader._compute_image_hash(img, "")
    hash2 = reader._compute_image_hash(img, "")
    hash3 = reader._compute_image_hash(img, "0123")  # Different allowlist

    print(f"  Hash same image: {hash1 == hash2} (expected: True)")
    print(f"  Hash different config: {hash1 != hash3} (expected: True)")

    # Test cache storage
    reader._cache_result(hash1, "test_result")
    cached = reader._ocr_cache.get(hash1)
    print(f"  Cache store/retrieve: {cached[0] == 'test_result' if cached else False}")

    # Test LRU eviction
    old_max = reader._cache_max_size
    reader._cache_max_size = 3
    for i in range(5):
        reader._cache_result(i, f"result_{i}")
    print(f"  LRU eviction: {len(reader._ocr_cache) == 3} (size: {len(reader._ocr_cache)})")
    reader._cache_max_size = old_max

    # Clear cache test
    reader.clear_cache()
    print(f"  Cache clear: {len(reader._ocr_cache) == 0}")

    return True


def test_image_cache_ttl():
    """Test image cache TTL and cleanup."""
    print("\n" + "=" * 60)
    print("TEST 3: Image Cache TTL")
    print("=" * 60)

    from core.vision.matcher import ImageCache

    # Create cache with short TTL for testing
    cache = ImageCache(max_size=5, ttl_seconds=2)

    print(f"  Max size: {cache._max_size}")
    print(f"  TTL: {cache._ttl}s")

    # Test put and get
    test_path = str(PROJECT_ROOT / "README.md")  # Use existing file
    cache.put(test_path, "dummy_image")

    result = cache.get(test_path)
    print(f"  Put/Get: {result == 'dummy_image'}")

    # Test LRU eviction
    for i in range(7):
        cache.put(f"path_{i}", f"image_{i}")

    print(f"  LRU eviction: {len(cache._cache) <= 5} (size: {len(cache._cache)})")

    # Test cleanup thread started
    print(f"  Cleanup thread: {cache._cleanup_started}")

    # Test clear
    cache.clear()
    print(f"  Cache clear: {len(cache._cache) == 0}")

    return True


def test_memory_baseline():
    """Measure baseline memory usage."""
    print("\n" + "=" * 60)
    print("TEST 4: Memory Baseline")
    print("=" * 60)

    try:
        import psutil

        process = psutil.Process()
        mem_mb = process.memory_info().rss / (1024 * 1024)
        print(f"  Current memory: {mem_mb:.1f} MB")
        print(f"  Memory target: <200 MB")
        print(f"  Status: {'‚úÖ OK' if mem_mb < 200 else '‚ö†Ô∏è  High'}")
        return mem_mb < 200
    except ImportError:
        print("  ‚ö†Ô∏è  psutil not installed, skipping memory test")
        return True


def test_import_speed():
    """Test import speed of key modules."""
    print("\n" + "=" * 60)
    print("TEST 5: Import Speed")
    print("=" * 60)

    modules = [
        "core.models",
        "core.engine.runner",
        "vision.capture",
        "vision.ocr",
    ]

    all_fast = True
    for mod in modules:
        start = time.time()
        __import__(mod)
        elapsed = (time.time() - start) * 1000
        status = "‚úÖ" if elapsed < 500 else "‚ö†Ô∏è"
        print(f"  {status} {mod}: {elapsed:.0f}ms")
        if elapsed > 500:
            all_fast = False

    return all_fast


def main():
    print("=" * 60)
    print("  RetroAuto v2 - Phase 1 Performance Tests")
    print("=" * 60)

    results = []
    results.append(("Adaptive Scan", test_adaptive_scan_interval()))
    results.append(("OCR Cache", test_ocr_cache()))
    results.append(("Image Cache", test_image_cache_ttl()))
    results.append(("Memory", test_memory_baseline()))
    results.append(("Import Speed", test_import_speed()))

    print("\n" + "=" * 60)
    print("  Summary")
    print("=" * 60)

    passed = sum(1 for _, r in results if r)
    failed = len(results) - passed

    for name, result in results:
        status = "‚úÖ PASS" if result else "‚ùå FAIL"
        print(f"  {status} {name}")

    print(f"\n  Total: {passed} passed, {failed} failed")

    if failed == 0:
        print("\n  üéâ All Phase 1 tests passed!")
        return 0
    else:
        print("\n  ‚ö†Ô∏è  Some tests failed")
        return 1


if __name__ == "__main__":
    sys.exit(main())


================================================================================
FILE PATH: scripts\version_bump.py
LINES: 117
================================================================================

#!/usr/bin/env python3
"""
RetroAuto v2 - Smart Version Manager

Automatically manages version numbers in pyproject.toml.

Version Format: MAJOR.MINOR.PATCH
- MAJOR: Breaking changes (manual)
- MINOR: New features (--minor)
- PATCH: Bug fixes, improvements (--patch, default)

Usage:
    python scripts/version_bump.py           # Bump patch (2.0.0 -> 2.0.1)
    python scripts/version_bump.py --minor   # Bump minor (2.0.0 -> 2.1.0)
    python scripts/version_bump.py --major   # Bump major (2.0.0 -> 3.0.0)
    python scripts/version_bump.py --show    # Show current version
    python scripts/version_bump.py --set 2.1.0  # Set specific version
"""

import argparse
import re
import sys
from pathlib import Path

PROJECT_ROOT = Path(__file__).parent.parent
PYPROJECT_PATH = PROJECT_ROOT / "pyproject.toml"
VERSION_PATTERN = re.compile(r'^version = "(\d+)\.(\d+)\.(\d+)"', re.MULTILINE)


def get_current_version() -> tuple[int, int, int]:
    """Get current version from pyproject.toml."""
    content = PYPROJECT_PATH.read_text(encoding="utf-8")
    match = VERSION_PATTERN.search(content)
    if not match:
        raise ValueError("Could not find version in pyproject.toml")
    return int(match.group(1)), int(match.group(2)), int(match.group(3))


def set_version(major: int, minor: int, patch: int) -> str:
    """Set version in pyproject.toml."""
    content = PYPROJECT_PATH.read_text(encoding="utf-8")
    new_version = f'version = "{major}.{minor}.{patch}"'
    new_content = VERSION_PATTERN.sub(new_version, content)
    PYPROJECT_PATH.write_text(new_content, encoding="utf-8")
    return f"{major}.{minor}.{patch}"


def bump_patch() -> str:
    """Bump patch version: 2.0.0 -> 2.0.1."""
    major, minor, patch = get_current_version()
    return set_version(major, minor, patch + 1)


def bump_minor() -> str:
    """Bump minor version: 2.0.5 -> 2.1.0."""
    major, minor, patch = get_current_version()
    return set_version(major, minor + 1, 0)


def bump_major() -> str:
    """Bump major version: 2.5.3 -> 3.0.0."""
    major, minor, patch = get_current_version()
    return set_version(major + 1, 0, 0)


def get_version_for_commit_message() -> str:
    """Get version string for commit message."""
    major, minor, patch = get_current_version()
    return f"v{major}.{minor}.{patch}"


def main() -> int:
    parser = argparse.ArgumentParser(description="Smart Version Manager")
    parser.add_argument("--patch", action="store_true", help="Bump patch version (default)")
    parser.add_argument("--minor", action="store_true", help="Bump minor version")
    parser.add_argument("--major", action="store_true", help="Bump major version")
    parser.add_argument("--show", action="store_true", help="Show current version")
    parser.add_argument("--set", type=str, help="Set specific version (e.g., 2.1.0)")
    args = parser.parse_args()

    try:
        if args.show:
            major, minor, patch = get_current_version()
            print(f"{major}.{minor}.{patch}")
            return 0

        if args.set:
            parts = args.set.split(".")
            if len(parts) != 3:
                print("Error: Version must be in format X.Y.Z")
                return 1
            new_version = set_version(int(parts[0]), int(parts[1]), int(parts[2]))
            print(f"Version set to: {new_version}")
            return 0

        old_version = ".".join(map(str, get_current_version()))

        if args.major:
            new_version = bump_major()
            bump_type = "MAJOR"
        elif args.minor:
            new_version = bump_minor()
            bump_type = "MINOR"
        else:
            new_version = bump_patch()
            bump_type = "PATCH"

        print(f"üì¶ Version bumped ({bump_type}): {old_version} ‚Üí {new_version}")
        return 0

    except Exception as e:
        print(f"Error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())


================================================================================
FILE PATH: tests\__init__.py
LINES: 1
================================================================================

"""RetroAuto v2 - Tests package."""


================================================================================
FILE PATH: tests\test_autocomplete.py
LINES: 136
================================================================================

"""
Tests for core/dsl/autocomplete.py - AutocompleteProvider
"""

from core.dsl.autocomplete import AutocompleteProvider, CompletionItem, CompletionKind


class TestCompletionItem:
    """Tests for CompletionItem."""

    def test_completion_item_creation(self):
        item = CompletionItem(
            label="click", kind=CompletionKind.FUNCTION, detail="Click at position"
        )
        assert item.label == "click"
        assert item.kind == CompletionKind.FUNCTION
        assert item.detail == "Click at position"

    def test_completion_item_insert_text_default(self):
        item = CompletionItem(label="click", kind=CompletionKind.FUNCTION)
        assert item.insert_text == "click"

    def test_completion_item_custom_insert_text(self):
        item = CompletionItem(
            label="click", kind=CompletionKind.FUNCTION, insert_text="click($1, $2)"
        )
        assert item.insert_text == "click($1, $2)"


class TestCompletionKind:
    """Tests for CompletionKind enum."""

    def test_completion_kinds_exist(self):
        assert hasattr(CompletionKind, "KEYWORD")
        assert hasattr(CompletionKind, "FUNCTION")
        assert hasattr(CompletionKind, "VARIABLE")
        assert hasattr(CompletionKind, "ASSET")
        assert hasattr(CompletionKind, "FLOW")
        assert hasattr(CompletionKind, "SNIPPET")


class TestAutocompleteProvider:
    """Tests for AutocompleteProvider."""

    def test_provider_creation(self):
        provider = AutocompleteProvider()
        assert provider is not None

    def test_set_context(self):
        provider = AutocompleteProvider()
        provider.set_context(
            assets=["btn_ok", "img_error"], flows=["main", "login"], variables=["counter", "result"]
        )
        # No exception means success

    def test_complete_keyword(self):
        provider = AutocompleteProvider()
        items = provider.complete("fl")

        # Should suggest "flow"
        labels = [item.label for item in items]
        assert "flow" in labels

    def test_complete_function(self):
        provider = AutocompleteProvider()
        items = provider.complete("cli")

        labels = [item.label for item in items]
        assert "click" in labels

    def test_complete_asset(self):
        provider = AutocompleteProvider()
        provider.set_context(assets=["btn_ok", "btn_cancel"])

        items = provider.complete("btn", in_string=True)
        labels = [item.label for item in items]

        assert "btn_ok" in labels
        assert "btn_cancel" in labels

    def test_complete_flow(self):
        provider = AutocompleteProvider()
        provider.set_context(flows=["main", "login", "logout"])

        items = provider.complete("log", in_string=True)
        labels = [item.label for item in items]

        assert "login" in labels
        assert "logout" in labels

    def test_complete_variable(self):
        provider = AutocompleteProvider()
        provider.set_context(variables=["counter", "result"])

        items = provider.complete("cou")
        labels = [item.label for item in items]

        assert "counter" in labels

    def test_get_all_functions(self):
        provider = AutocompleteProvider()
        functions = provider.get_all_functions()

        assert len(functions) > 0
        labels = [f.label for f in functions]
        assert "click" in labels
        assert "wait_image" in labels

    def test_get_all_keywords(self):
        provider = AutocompleteProvider()
        keywords = provider.get_all_keywords()

        assert len(keywords) > 0
        labels = [k.label for k in keywords]
        assert "flow" in labels

    def test_get_function_signature(self):
        provider = AutocompleteProvider()
        sig = provider.get_function_signature("click")

        assert sig is not None
        assert "click" in sig

    def test_empty_prefix(self):
        provider = AutocompleteProvider()
        items = provider.complete("")

        # Should return some results
        assert len(items) >= 0

    def test_no_match(self):
        provider = AutocompleteProvider()
        items = provider.complete("xyz_nonexistent")

        # Should return empty or very few results
        assert len(items) == 0


================================================================================
FILE PATH: tests\test_debugger.py
LINES: 233
================================================================================

"""
Tests for core/dsl/debugger.py - Debugger and BreakpointManager
"""

from core.dsl.debugger import (
    Breakpoint,
    BreakpointManager,
    Debugger,
    DebugState,
    StackFrame,
    StepMode,
    Variable,
)


class TestBreakpointDataclass:
    """Tests for Breakpoint dataclass."""

    def test_breakpoint_creation(self):
        bp = Breakpoint(id=1, file="test.dsl", line=10)
        assert bp.id == 1
        assert bp.file == "test.dsl"
        assert bp.line == 10
        assert bp.enabled is True

    def test_breakpoint_disabled(self):
        bp = Breakpoint(id=1, file="test.dsl", line=5, enabled=False)
        assert bp.enabled is False

    def test_breakpoint_with_condition(self):
        bp = Breakpoint(id=1, file="test.dsl", line=10, condition="x > 5")
        assert bp.condition == "x > 5"

    def test_breakpoint_hit_count(self):
        bp = Breakpoint(id=1, file="test.dsl", line=10, hit_count=5)
        assert bp.hit_count == 5


class TestStackFrame:
    """Tests for StackFrame dataclass."""

    def test_stack_frame_creation(self):
        frame = StackFrame(id=1, name="main", file="test.dsl", line=15)
        assert frame.id == 1
        assert frame.name == "main"
        assert frame.file == "test.dsl"
        assert frame.line == 15

    def test_stack_frame_with_locals(self):
        frame = StackFrame(id=1, name="main", file="test.dsl", line=15, locals={"x": 10, "y": 20})
        assert frame.locals["x"] == 10
        assert frame.locals["y"] == 20


class TestVariable:
    """Tests for Variable dataclass."""

    def test_variable_creation(self):
        var = Variable(name="counter", value=10, type="int")
        assert var.name == "counter"
        assert var.value == 10
        assert var.type == "int"

    def test_variable_expandable(self):
        var = Variable(name="obj", value={}, type="dict", expandable=True)
        assert var.expandable is True


class TestDebugState:
    """Tests for DebugState enum."""

    def test_debug_states_exist(self):
        assert DebugState.IDLE is not None
        assert DebugState.RUNNING is not None
        assert DebugState.PAUSED is not None
        assert DebugState.STEPPING is not None


class TestStepMode:
    """Tests for StepMode enum."""

    def test_step_modes_exist(self):
        assert StepMode.OVER is not None
        assert StepMode.INTO is not None
        assert StepMode.OUT is not None


class TestBreakpointManager:
    """Tests for BreakpointManager."""

    def test_manager_creation(self):
        manager = BreakpointManager()
        assert manager is not None

    def test_add_breakpoint(self):
        manager = BreakpointManager()
        bp = manager.add("test.dsl", 10)
        assert bp is not None
        assert bp.line == 10

    def test_remove_breakpoint(self):
        manager = BreakpointManager()
        bp = manager.add("test.dsl", 10)
        manager.remove(bp.id)
        assert manager.get(bp.id) is None

    def test_toggle_breakpoint(self):
        manager = BreakpointManager()
        bp = manager.add("test.dsl", 10)
        assert bp.enabled is True
        manager.toggle(bp.id)
        # After toggle, should be disabled
        bp2 = manager.get(bp.id)
        assert bp2 is not None and bp2.enabled is False

    def test_get_all(self):
        manager = BreakpointManager()
        manager.add("test.dsl", 10)
        manager.add("test.dsl", 20)
        all_bps = manager.get_all()
        assert len(all_bps) == 2

    def test_clear(self):
        manager = BreakpointManager()
        manager.add("test.dsl", 10)
        manager.add("test.dsl", 20)
        manager.clear()
        assert len(manager.get_all()) == 0

    def test_has_breakpoint(self):
        manager = BreakpointManager()
        manager.add("test.dsl", 10)
        assert manager.has_breakpoint("test.dsl", 10) is True
        assert manager.has_breakpoint("test.dsl", 20) is False

    def test_get_at(self):
        manager = BreakpointManager()
        manager.add("test.dsl", 10)
        bp = manager.get_at("test.dsl", 10)
        assert bp is not None
        assert bp.line == 10


class TestDebugger:
    """Tests for Debugger."""

    def test_debugger_creation(self):
        debugger = Debugger()
        assert debugger is not None
        assert debugger.state == DebugState.IDLE

    def test_debugger_breakpoints_access(self):
        debugger = Debugger()
        assert debugger.breakpoints is not None

    def test_debugger_start(self):
        debugger = Debugger()
        debugger.start()
        assert debugger.state == DebugState.RUNNING

    def test_debugger_stop(self):
        debugger = Debugger()
        debugger.start()
        debugger.stop()
        assert debugger.state == DebugState.IDLE

    def test_debugger_pause(self):
        debugger = Debugger()
        debugger.start()
        debugger.pause()
        assert debugger.state == DebugState.PAUSED

    def test_debugger_continue(self):
        debugger = Debugger()
        debugger.start()
        debugger.pause()
        debugger.continue_execution()
        assert debugger.state == DebugState.RUNNING

    def test_debugger_step_over(self):
        debugger = Debugger()
        debugger.start()
        debugger.pause()
        debugger.step_over()
        assert debugger.state == DebugState.STEPPING

    def test_debugger_step_into(self):
        debugger = Debugger()
        debugger.start()
        debugger.pause()
        debugger.step_into()
        assert debugger.state == DebugState.STEPPING

    def test_debugger_step_out(self):
        debugger = Debugger()
        debugger.start()
        debugger.pause()
        debugger.step_out()
        assert debugger.state == DebugState.STEPPING

    def test_debugger_is_paused(self):
        debugger = Debugger()
        assert debugger.is_paused is False
        debugger.start()
        debugger.pause()
        assert debugger.is_paused is True

    def test_debugger_call_stack(self):
        debugger = Debugger()
        stack = debugger.call_stack
        assert isinstance(stack, list)

    def test_debugger_callbacks(self):
        debugger = Debugger()
        called = []

        debugger.on_paused(lambda f, line_num: called.append("paused"))
        debugger.on_resumed(lambda: called.append("resumed"))
        debugger.on_stopped(lambda: called.append("stopped"))

        # Just verify no exceptions
        assert debugger is not None

    def test_debugger_get_variables(self):
        debugger = Debugger()
        vars = debugger.get_variables()
        assert isinstance(vars, list)

    def test_debugger_evaluate(self):
        debugger = Debugger()
        result = debugger.evaluate("1 + 1")
        # Returns tuple (value, error)
        assert isinstance(result, tuple)


================================================================================
FILE PATH: tests\test_formatter.py
LINES: 227
================================================================================

"""
Tests for DSL Formatter.
"""

from core.dsl.formatter import format_code
from core.dsl.parser import Parser


class TestFormatterIdempotent:
    """Test formatter idempotency: format(format(x)) == format(x)."""

    def test_simple_flow(self) -> None:
        """Simple flow is idempotent."""
        source = """
        flow main { log("test"); }
        """
        result1 = format_code(source)
        result2 = format_code(result1)
        assert result1 == result2

    def test_complex_script(self) -> None:
        """Complex script is idempotent."""
        source = """
        hotkeys {
            start = "F5"
            stop="F6"
        }
        flow main {
            let x=5;
            if x==1{log("one");}else{log("other");}
        }
        """
        result1 = format_code(source)
        result2 = format_code(result1)
        assert result1 == result2

    def test_nested_blocks(self) -> None:
        """Nested blocks are idempotent."""
        source = """
        flow main {
            while true {
                if x {
                    for i in range(10) {
                        log(i);
                    }
                }
            }
        }
        """
        result1 = format_code(source)
        result2 = format_code(result1)
        assert result1 == result2


class TestFormatterIndentation:
    """Test indentation rules."""

    def test_two_space_indent(self) -> None:
        """Uses 2-space indentation."""
        source = "flow main { log('test'); }"
        result = format_code(source)
        lines = result.split("\n")
        # Content line should start with 2 spaces
        content_lines = [line for line in lines if line.strip().startswith("log")]
        assert all(line.startswith("  ") for line in content_lines)

    def test_nested_indent(self) -> None:
        """Nested blocks have correct indentation."""
        source = """
        flow main {
            if true {
                log("nested");
            }
        }
        """
        result = format_code(source)
        lines = result.split("\n")
        log_line = [line for line in lines if "log" in line][0]
        # Should be 4 spaces (2 for flow + 2 for if)
        assert log_line.startswith("    ")


class TestFormatterBraces:
    """Test K&R brace style."""

    def test_opening_brace_same_line(self) -> None:
        """Opening brace on same line as keyword."""
        source = """
        flow main
        {
            log("test");
        }
        """
        result = format_code(source)
        assert "flow main {" in result

    def test_if_brace_same_line(self) -> None:
        """If opening brace on same line."""
        source = """
        flow main {
            if true
            {
                log("test");
            }
        }
        """
        result = format_code(source)
        assert "if true {" in result


class TestFormatterStrings:
    """Test string formatting."""

    def test_double_quotes(self) -> None:
        """Strings use double quotes."""
        source = "flow main { log('single'); }"
        result = format_code(source)
        assert '"single"' in result
        assert "'" not in result.replace("'", "").replace('"', "")

    def test_escape_in_strings(self) -> None:
        """Escapes preserved in strings."""
        source = 'flow main { log("hello\\nworld"); }'
        result = format_code(source)
        assert "\\n" in result or "\n" in result


class TestFormatterKeywords:
    """Test keyword formatting."""

    def test_lowercase_keywords(self) -> None:
        """Keywords are lowercase."""
        source = "FLOW main { IF TRUE { LOG('test'); } }"
        result = format_code(source)
        assert "flow " in result
        assert "if " in result
        assert "true" in result
        assert "FLOW" not in result


class TestFormatterSpacing:
    """Test spacing rules."""

    def test_binary_operator_spacing(self) -> None:
        """Binary operators have spaces."""
        source = "flow main { let x=1+2; }"
        result = format_code(source)
        assert " = " in result
        assert " + " in result

    def test_comma_spacing(self) -> None:
        """Commas followed by space."""
        source = "flow main { click(100,200,button='left'); }"
        result = format_code(source)
        assert ", " in result


class TestFormatterCompleteScript:
    """Test complete script formatting."""

    def test_full_script_format(self) -> None:
        """Complete script formats correctly."""
        source = """
        hotkeys{start="F5"}
        flow main{
            label start:
            wait_image("btn",timeout=5s);
            click(100,200);
            goto start;
        }
        interrupt{priority 10 when image "error"{click(50,50);}}
        """
        result = format_code(source)

        # Check structure
        assert "hotkeys {" in result
        assert "flow main {" in result
        assert "interrupt {" in result
        assert "label start:" in result
        assert 'wait_image("btn"' in result

    def test_preserves_semantics(self) -> None:
        """Formatting preserves semantics."""
        source = """
        flow main {
            let x = 1 + 2 * 3;
            if x == 7 {
                log("correct");
            }
        }
        """
        original_parser = Parser(source)
        original_ast = original_parser.parse()

        formatted = format_code(source)
        formatted_parser = Parser(formatted)
        formatted_ast = formatted_parser.parse()

        # Same structure
        assert len(original_ast.flows) == len(formatted_ast.flows)
        assert len(original_ast.flows[0].body.statements) == len(
            formatted_ast.flows[0].body.statements
        )


class TestFormatterEdgeCases:
    """Test edge cases."""

    def test_empty_flow(self) -> None:
        """Empty flow body."""
        source = "flow main {}"
        result = format_code(source)
        assert "flow main {\n}" in result

    def test_multiple_flows(self) -> None:
        """Multiple flows separated by blank line."""
        source = "flow a {} flow b {}"
        result = format_code(source)
        lines = result.strip().split("\n")
        # Should have blank line between flows
        assert len(lines) >= 4

    def test_parse_error_returns_original(self) -> None:
        """Parse error returns original source."""
        source = "this is not valid DSL @@@"
        result = format_code(source)
        assert result == source


================================================================================
FILE PATH: tests\test_input.py
LINES: 31
================================================================================

"""
Tests for input/mouse.py and input/keyboard.py
"""

from input.keyboard import KeyboardController
from input.mouse import MouseController


class TestMouseController:
    """Tests for MouseController."""

    def test_mouse_instance(self):
        mouse = MouseController()
        assert mouse is not None

    def test_get_position(self):
        mouse = MouseController()
        pos = mouse.get_position()

        assert isinstance(pos, tuple)
        assert len(pos) == 2
        assert isinstance(pos[0], int)
        assert isinstance(pos[1], int)


class TestKeyboardController:
    """Tests for KeyboardController."""

    def test_keyboard_instance(self):
        kb = KeyboardController()
        assert kb is not None


================================================================================
FILE PATH: tests\test_ir.py
LINES: 214
================================================================================

"""
Tests for core/dsl/ir.py - Intermediate Representation
"""

from core.dsl.ir import (
    ActionIR,
    AssetIR,
    FlowIR,
    HotkeysIR,
    InterruptIR,
    IRMapper,
    ScriptIR,
    ir_to_code,
    parse_to_ir,
)


class TestAssetIR:
    """Tests for AssetIR dataclass."""

    def test_asset_creation(self):
        asset = AssetIR(id="btn_ok", path="btn_ok.png")
        assert asset.id == "btn_ok"
        assert asset.path == "btn_ok.png"

    def test_asset_defaults(self):
        asset = AssetIR(id="test", path="test.png")
        assert asset.threshold == 0.8
        assert asset.roi is None

    def test_asset_with_roi(self):
        asset = AssetIR(id="test", path="test.png", roi={"x": 10, "y": 20, "w": 100, "h": 200})
        assert asset.roi["x"] == 10


class TestActionIR:
    """Tests for ActionIR dataclass."""

    def test_action_creation(self):
        action = ActionIR(action_type="Click", params={"x": 100, "y": 200})
        assert action.action_type == "Click"
        assert action.params["x"] == 100

    def test_action_defaults(self):
        action = ActionIR(action_type="Delay")
        assert action.params == {}
        assert action.span_line is None

    def test_action_with_line(self):
        action = ActionIR(action_type="Click", params={}, span_line=42)
        assert action.span_line == 42


class TestFlowIR:
    """Tests for FlowIR dataclass."""

    def test_flow_creation(self):
        flow = FlowIR(name="main")
        assert flow.name == "main"
        assert flow.actions == []

    def test_flow_with_actions(self):
        actions = [
            ActionIR(action_type="Click", params={"x": 100, "y": 100}),
            ActionIR(action_type="Delay", params={"ms": 500}),
        ]
        flow = FlowIR(name="main", actions=actions)
        assert len(flow.actions) == 2


class TestInterruptIR:
    """Tests for InterruptIR dataclass."""

    def test_interrupt_creation(self):
        interrupt = InterruptIR(priority=10, when_asset="error_popup")
        assert interrupt.priority == 10
        assert interrupt.when_asset == "error_popup"

    def test_interrupt_with_actions(self):
        interrupt = InterruptIR(
            priority=5, when_asset="popup", actions=[ActionIR(action_type="Click", params={})]
        )
        assert len(interrupt.actions) == 1


class TestHotkeysIR:
    """Tests for HotkeysIR dataclass."""

    def test_hotkeys_defaults(self):
        hotkeys = HotkeysIR()
        assert hotkeys.start == "F5"
        assert hotkeys.stop == "F6"
        assert hotkeys.pause == "F7"

    def test_hotkeys_custom(self):
        hotkeys = HotkeysIR(start="F1", stop="F2", pause="F3")
        assert hotkeys.start == "F1"


class TestScriptIR:
    """Tests for ScriptIR dataclass."""

    def test_script_defaults(self):
        script = ScriptIR()
        assert script.name == "Untitled"
        assert script.version == "1.0"
        assert script.assets == []
        assert script.flows == []

    def test_script_custom(self):
        script = ScriptIR(name="MyScript", version="2.0")
        assert script.name == "MyScript"
        assert script.version == "2.0"

    def test_add_asset(self):
        script = ScriptIR()
        asset = AssetIR(id="btn", path="btn.png")
        script.add_asset(asset)
        assert script.get_asset("btn") is not None

    def test_remove_asset(self):
        script = ScriptIR()
        asset = AssetIR(id="btn", path="btn.png")
        script.add_asset(asset)
        script.remove_asset("btn")
        assert script.get_asset("btn") is None

    def test_add_flow(self):
        script = ScriptIR()
        flow = FlowIR(name="main")
        script.add_flow(flow)
        assert script.get_flow("main") is not None

    def test_remove_flow(self):
        script = ScriptIR()
        flow = FlowIR(name="main")
        script.add_flow(flow)
        script.remove_flow("main")
        assert script.get_flow("main") is None

    def test_listener(self):
        script = ScriptIR()
        changes = []

        def listener(change_type):
            changes.append(change_type)

        script.add_listener(listener)
        script.notify_change("test_change")

        assert "test_change" in changes

    def test_remove_listener(self):
        script = ScriptIR()
        changes = []

        def listener(change_type):
            changes.append(change_type)

        script.add_listener(listener)
        script.remove_listener(listener)
        script.notify_change("test")

        assert len(changes) == 0


class TestParseToIR:
    """Tests for parse_to_ir function."""

    def test_parse_simple_flow(self):
        source = """
flow main {
    click(100, 200);
}
"""
        ir, errors = parse_to_ir(source)
        assert ir is not None
        assert len(errors) == 0

    def test_parse_invalid_syntax(self):
        source = "flow { }"  # Missing flow name
        ir, errors = parse_to_ir(source)
        assert len(errors) > 0


class TestIRToCode:
    """Tests for ir_to_code function."""

    def test_empty_script_to_code(self):
        script = ScriptIR()
        code = ir_to_code(script)
        assert isinstance(code, str)

    def test_script_with_flow_to_code(self):
        script = ScriptIR()
        flow = FlowIR(
            name="main",
            actions=[
                ActionIR(action_type="click", params={"x": 100, "y": 200}),
            ],
        )
        script.add_flow(flow)

        code = ir_to_code(script)
        assert "flow main" in code or "main" in code


class TestIRMapper:
    """Tests for IRMapper class."""

    def test_ir_to_code(self):
        script = ScriptIR()
        code = IRMapper.ir_to_code(script)
        assert isinstance(code, str)


================================================================================
FILE PATH: tests\test_lexer.py
LINES: 304
================================================================================

"""
Tests for DSL Lexer.
"""

from core.dsl.lexer import Lexer
from core.dsl.tokens import TokenType


class TestLexerBasics:
    """Test basic lexer functionality."""

    def test_empty_source(self) -> None:
        """Empty source produces only EOF."""
        lexer = Lexer("")
        tokens = lexer.tokenize()
        assert len(tokens) == 1
        assert tokens[0].type == TokenType.EOF

    def test_whitespace_only(self) -> None:
        """Whitespace only produces EOF."""
        lexer = Lexer("   \t\n\n  ")
        tokens = lexer.tokenize()
        assert len(tokens) == 1
        assert tokens[0].type == TokenType.EOF


class TestLexerKeywords:
    """Test keyword tokenization."""

    def test_all_keywords(self) -> None:
        """All keywords are recognized."""
        source = "flow if elif else while for in label goto break continue return"
        lexer = Lexer(source)
        tokens = lexer.tokenize()

        expected = [
            TokenType.FLOW,
            TokenType.IF,
            TokenType.ELIF,
            TokenType.ELSE,
            TokenType.WHILE,
            TokenType.FOR,
            TokenType.IN,
            TokenType.LABEL,
            TokenType.GOTO,
            TokenType.BREAK,
            TokenType.CONTINUE,
            TokenType.RETURN,
            TokenType.EOF,
        ]
        assert [t.type for t in tokens] == expected

    def test_case_insensitive_keywords(self) -> None:
        """Keywords are case-insensitive."""
        lexer = Lexer("FLOW Flow flow")
        tokens = lexer.tokenize()
        assert tokens[0].type == TokenType.FLOW
        assert tokens[1].type == TokenType.FLOW
        assert tokens[2].type == TokenType.FLOW


class TestLexerLiterals:
    """Test literal tokenization."""

    def test_integers(self) -> None:
        """Integer literals."""
        lexer = Lexer("0 42 12345")
        tokens = lexer.tokenize()
        assert tokens[0].type == TokenType.INTEGER
        assert tokens[0].value == "0"
        assert tokens[1].value == "42"
        assert tokens[2].value == "12345"

    def test_floats(self) -> None:
        """Float literals."""
        lexer = Lexer("1.0 3.14159 0.5")
        tokens = lexer.tokenize()
        assert all(t.type == TokenType.FLOAT for t in tokens[:-1])
        assert tokens[0].value == "1.0"
        assert tokens[1].value == "3.14159"

    def test_durations(self) -> None:
        """Duration literals."""
        lexer = Lexer("100ms 5s 2m 1h")
        tokens = lexer.tokenize()
        assert all(t.type == TokenType.DURATION for t in tokens[:-1])
        assert tokens[0].value == "100ms"
        assert tokens[1].value == "5s"
        assert tokens[2].value == "2m"
        assert tokens[3].value == "1h"

    def test_booleans(self) -> None:
        """Boolean literals."""
        lexer = Lexer("true false")
        tokens = lexer.tokenize()
        assert tokens[0].type == TokenType.TRUE
        assert tokens[1].type == TokenType.FALSE

    def test_null(self) -> None:
        """Null literal."""
        lexer = Lexer("null")
        tokens = lexer.tokenize()
        assert tokens[0].type == TokenType.NULL

    def test_double_quoted_string(self) -> None:
        """Double-quoted string."""
        lexer = Lexer('"hello world"')
        tokens = lexer.tokenize()
        assert tokens[0].type == TokenType.STRING
        assert tokens[0].value == "hello world"

    def test_single_quoted_string(self) -> None:
        """Single-quoted string."""
        lexer = Lexer("'hello'")
        tokens = lexer.tokenize()
        assert tokens[0].type == TokenType.STRING
        assert tokens[0].value == "hello"

    def test_string_escape_sequences(self) -> None:
        """String escape sequences."""
        lexer = Lexer(r'"hello\nworld\ttab"')
        tokens = lexer.tokenize()
        assert tokens[0].value == "hello\nworld\ttab"


class TestLexerOperators:
    """Test operator tokenization."""

    def test_arithmetic_operators(self) -> None:
        """Arithmetic operators."""
        lexer = Lexer("+ - * / %")
        tokens = lexer.tokenize()
        expected = [
            TokenType.PLUS,
            TokenType.MINUS,
            TokenType.STAR,
            TokenType.SLASH,
            TokenType.PERCENT,
            TokenType.EOF,
        ]
        assert [t.type for t in tokens] == expected

    def test_comparison_operators(self) -> None:
        """Comparison operators."""
        lexer = Lexer("== != < > <= >=")
        tokens = lexer.tokenize()
        expected = [
            TokenType.EQ,
            TokenType.NEQ,
            TokenType.LT,
            TokenType.GT,
            TokenType.LTE,
            TokenType.GTE,
            TokenType.EOF,
        ]
        assert [t.type for t in tokens] == expected

    def test_logical_operators(self) -> None:
        """Logical operators."""
        lexer = Lexer("&& || !")
        tokens = lexer.tokenize()
        expected = [TokenType.AND, TokenType.OR, TokenType.NOT, TokenType.EOF]
        assert [t.type for t in tokens] == expected


class TestLexerDelimiters:
    """Test delimiter tokenization."""

    def test_all_delimiters(self) -> None:
        """All delimiters."""
        lexer = Lexer("( ) { } [ ] ; : , . ->")
        tokens = lexer.tokenize()
        expected = [
            TokenType.LPAREN,
            TokenType.RPAREN,
            TokenType.LBRACE,
            TokenType.RBRACE,
            TokenType.LBRACKET,
            TokenType.RBRACKET,
            TokenType.SEMICOLON,
            TokenType.COLON,
            TokenType.COMMA,
            TokenType.DOT,
            TokenType.ARROW,
            TokenType.EOF,
        ]
        assert [t.type for t in tokens] == expected


class TestLexerComments:
    """Test comment tokenization."""

    def test_line_comment(self) -> None:
        """Line comment."""
        lexer = Lexer("flow main // this is a comment\n{}")
        tokens = lexer.tokenize()
        assert TokenType.LINE_COMMENT in [t.type for t in tokens]
        assert any("this is a comment" in t.value for t in tokens)

    def test_block_comment(self) -> None:
        """Block comment."""
        lexer = Lexer("flow /* comment */ main {}")
        tokens = lexer.tokenize()
        assert TokenType.BLOCK_COMMENT in [t.type for t in tokens]

    def test_multiline_block_comment(self) -> None:
        """Multiline block comment."""
        source = """flow main {
            /* this is a
               multiline comment */
        }"""
        lexer = Lexer(source)
        tokens = lexer.tokenize()
        assert any(t.type == TokenType.BLOCK_COMMENT for t in tokens)


class TestLexerPositions:
    """Test token position tracking."""

    def test_line_numbers(self) -> None:
        """Token line numbers."""
        source = "flow\nmain\n{"
        lexer = Lexer(source)
        tokens = lexer.tokenize()
        assert tokens[0].line == 1
        assert tokens[1].line == 2
        assert tokens[2].line == 3

    def test_column_numbers(self) -> None:
        """Token column numbers."""
        source = "flow main"
        lexer = Lexer(source)
        tokens = lexer.tokenize()
        assert tokens[0].column == 1
        assert tokens[1].column == 6


class TestLexerErrors:
    """Test lexer error handling."""

    def test_unterminated_string(self) -> None:
        """Unterminated string produces error."""
        lexer = Lexer('"unterminated')
        tokens = lexer.tokenize()
        assert len(lexer.errors) > 0
        assert any(t.type == TokenType.ERROR for t in tokens)

    def test_unknown_character(self) -> None:
        """Unknown character produces error."""
        lexer = Lexer("`~")  # Backtick and tilde are not valid tokens
        lexer.tokenize()
        assert len(lexer.errors) > 0


class TestLexerRealCode:
    """Test lexer with real DSL code."""

    def test_simple_flow(self) -> None:
        """Simple flow definition."""
        source = """
        flow main {
            wait_image("button", timeout=5s);
            click(100, 200);
        }
        """
        lexer = Lexer(source)
        tokens = lexer.tokenize()
        assert len(lexer.errors) == 0

        # Check key tokens
        types = [t.type for t in tokens]
        assert TokenType.FLOW in types
        assert TokenType.LBRACE in types
        assert TokenType.RBRACE in types
        assert TokenType.STRING in types
        assert TokenType.DURATION in types

    def test_complete_script(self) -> None:
        """Complete script with hotkeys, flow, and interrupt."""
        source = """
        hotkeys {
            start = "F5"
            stop = "F6"
        }

        flow main {
            label start:
            wait_image("ready");
            click(100, 200);
            sleep(500ms);
            goto start;
        }

        interrupt {
            priority 10
            when image "error"
            {
                click(50, 50);
            }
        }
        """
        lexer = Lexer(source)
        lexer.tokenize()
        assert len(lexer.errors) == 0


================================================================================
FILE PATH: tests\test_matcher_roi.py
LINES: 157
================================================================================

"""
Test matcher with ROI optimization.
"""

from pathlib import Path

import cv2
import numpy as np
import pytest

from core.models import ROI, AssetImage
from core.templates import TemplateStore
from vision.capture import ScreenCapture
from vision.matcher import Matcher


class MockCapture:
    """Mock screen capture for testing."""

    def __init__(self, image: np.ndarray) -> None:
        self._image = image
        self._gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) if len(image.shape) == 3 else image

    def capture_full(self, monitor: int = 1, grayscale: bool = False) -> np.ndarray:
        return self._gray if grayscale else self._image

    def capture_roi(self, roi: ROI, grayscale: bool = False) -> np.ndarray:
        img = self._gray if grayscale else self._image
        return img[roi.y : roi.y + roi.h, roi.x : roi.x + roi.w]


class TestMatcher:
    """Test template matching."""

    @pytest.fixture
    def setup_matcher(self, tmp_path: Path):  # type: ignore
        """Create matcher with test images."""
        # Create a test "screen" with a button
        screen = np.ones((600, 800, 3), dtype=np.uint8) * 200  # Gray background

        # Draw a red button at (100, 100)
        cv2.rectangle(screen, (100, 100), (180, 140), (0, 0, 255), -1)
        cv2.putText(screen, "OK", (120, 130), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)

        # Save button template
        btn_path = tmp_path / "btn_ok.png"
        btn_crop = screen[100:140, 100:180]
        cv2.imwrite(str(btn_path), btn_crop)

        # Create template store
        store = TemplateStore(tmp_path)
        asset = AssetImage(id="btn_ok", path="btn_ok.png", threshold=0.8)
        errors = store.preload([asset])
        assert len(errors) == 0

        # Create matcher with mock capture
        mock_capture = MockCapture(screen)
        matcher = Matcher(store, mock_capture)

        return matcher, screen, btn_crop

    def test_find_exact_match(self, setup_matcher) -> None:  # type: ignore
        """Test finding exact template match."""
        matcher, _, _ = setup_matcher

        match = matcher.find("btn_ok")
        assert match is not None
        assert match.x == 100
        assert match.y == 100
        assert match.confidence >= 0.99  # Should be near-perfect

    def test_find_with_roi(self, setup_matcher, tmp_path: Path) -> None:  # type: ignore
        """Test ROI-restricted matching."""
        matcher, screen, _ = setup_matcher

        # Match within ROI containing button
        roi = ROI(x=50, y=50, w=200, h=200)
        match = matcher.find("btn_ok", roi_override=roi)
        assert match is not None
        # Coordinates should be absolute
        assert match.x == 100
        assert match.y == 100

    def test_find_outside_roi(self, setup_matcher) -> None:  # type: ignore
        """Test that match outside ROI is not found."""
        matcher, _, _ = setup_matcher

        # ROI that doesn't contain the button
        roi = ROI(x=400, y=400, w=100, h=100)
        match = matcher.find("btn_ok", roi_override=roi)
        assert match is None

    def test_below_threshold(self, setup_matcher, tmp_path: Path) -> None:  # type: ignore
        """Test threshold filtering."""
        matcher, screen, _ = setup_matcher

        # Create asset with very high threshold
        store = TemplateStore(tmp_path)
        asset = AssetImage(id="btn_strict", path="btn_ok.png", threshold=0.999)
        errors = store.preload([asset])
        assert len(errors) == 0

        # Modify screen slightly so it's not perfect match
        screen_modified = screen.copy()
        screen_modified[110, 110] = [0, 255, 0]  # Add noise pixel
        mock_capture = MockCapture(screen_modified)
        matcher_strict = Matcher(store, mock_capture)

        matcher_strict.find("btn_strict")
        # May or may not match depending on threshold
        # This is mainly to test threshold logic works

    def test_exists(self, setup_matcher) -> None:  # type: ignore
        """Test exists helper."""
        matcher, _, _ = setup_matcher

        assert matcher.exists("btn_ok")
        assert not matcher.exists("nonexistent")

    def test_find_nonexistent_asset(self, setup_matcher) -> None:  # type: ignore
        """Test finding asset not in store."""
        matcher, _, _ = setup_matcher

        match = matcher.find("not_loaded")
        assert match is None


class TestScreenCapture:
    """Test screen capture functionality."""

    def test_screen_size(self) -> None:
        """Test getting screen size."""
        with ScreenCapture() as cap:
            w, h = cap.screen_size
            assert w > 0
            assert h > 0

    def test_capture_full(self) -> None:
        """Test full screen capture."""
        with ScreenCapture() as cap:
            img = cap.capture_full()
            assert img.shape[2] == 3  # BGR
            assert img.shape[0] > 0
            assert img.shape[1] > 0

    def test_capture_full_grayscale(self) -> None:
        """Test grayscale capture."""
        with ScreenCapture() as cap:
            img = cap.capture_full(grayscale=True)
            assert len(img.shape) == 2  # No color channels

    def test_capture_roi(self) -> None:
        """Test ROI capture."""
        roi = ROI(x=0, y=0, w=100, h=100)
        with ScreenCapture() as cap:
            img = cap.capture_roi(roi)
            assert img.shape == (100, 100, 3)


================================================================================
FILE PATH: tests\test_models.py
LINES: 149
================================================================================

"""
Tests for core/models.py - Action models
"""

from core.models import (
    ROI,
    AssetImage,
    Click,
    Delay,
    Flow,
    Goto,
    Hotkey,
    IfImage,
    Label,
    Match,
    MatchMethod,
    RunFlow,
    TypeText,
    WaitImage,
)


class TestROI:
    """Tests for ROI model."""

    def test_roi_creation(self):
        roi = ROI(x=10, y=20, w=100, h=200)
        assert roi.x == 10
        assert roi.y == 20
        assert roi.w == 100
        assert roi.h == 200


class TestAssetImage:
    """Tests for AssetImage model."""

    def test_asset_creation(self):
        asset = AssetImage(id="btn_ok", path="assets/btn_ok.png", threshold=0.8)
        assert asset.id == "btn_ok"
        assert asset.path == "assets/btn_ok.png"
        assert asset.threshold == 0.8

    def test_asset_defaults(self):
        asset = AssetImage(id="test", path="test.png")
        assert asset.threshold == 0.8  # Default
        assert asset.grayscale is True
        assert asset.roi is None


class TestMatch:
    """Tests for Match model."""

    def test_match_creation(self):
        match = Match(asset_id="btn_ok", x=100, y=200, w=50, h=30, confidence=0.95)
        assert match.center == (125, 215)

    def test_match_center_calculation(self):
        match = Match(asset_id="test", x=0, y=0, w=100, h=100, confidence=0.9)
        assert match.center == (50, 50)


class TestActions:
    """Tests for Action models."""

    def test_wait_image(self):
        action = WaitImage(asset_id="btn_ok", appear=True, timeout_ms=5000)
        assert action.action == "WaitImage"
        assert action.asset_id == "btn_ok"
        assert action.appear is True
        assert action.timeout_ms == 5000

    def test_click(self):
        action = Click(x=100, y=200, button="left", clicks=1)
        assert action.action == "Click"
        assert action.x == 100
        assert action.y == 200
        assert action.button == "left"

    def test_click_at_match(self):
        action = Click(use_match=True)
        assert action.use_match is True
        assert action.x is None

    def test_double_click(self):
        action = Click(x=100, y=200, clicks=2)
        assert action.clicks == 2

    def test_right_click(self):
        action = Click(x=100, y=200, button="right")
        assert action.button == "right"

    def test_if_image(self):
        then_actions = [Click(x=10, y=10)]
        else_actions = [Delay(ms=1000)]
        action = IfImage(asset_id="btn", then_actions=then_actions, else_actions=else_actions)
        assert action.action == "IfImage"
        assert len(action.then_actions) == 1
        assert len(action.else_actions) == 1

    def test_hotkey(self):
        action = Hotkey(keys=["CTRL", "S"])
        assert action.action == "Hotkey"
        assert action.keys == ["CTRL", "S"]

    def test_type_text(self):
        action = TypeText(text="Hello World")
        assert action.action == "TypeText"
        assert action.text == "Hello World"

    def test_label(self):
        action = Label(name="start")
        assert action.action == "Label"
        assert action.name == "start"

    def test_goto(self):
        action = Goto(label="start")
        assert action.action == "Goto"
        assert action.label == "start"

    def test_run_flow(self):
        action = RunFlow(flow_name="login")
        assert action.action == "RunFlow"
        assert action.flow_name == "login"

    def test_delay(self):
        action = Delay(ms=1000)
        assert action.action == "Delay"
        assert action.ms == 1000


class TestFlow:
    """Tests for Flow model."""

    def test_flow_creation(self):
        flow = Flow(name="main", actions=[WaitImage(asset_id="btn"), Click(x=100, y=100)])
        assert flow.name == "main"
        assert len(flow.actions) == 2

    def test_empty_flow(self):
        flow = Flow(name="empty")
        assert flow.actions == []


class TestMatchMethod:
    """Tests for MatchMethod enum."""

    def test_match_methods_exist(self):
        assert hasattr(MatchMethod, "TM_CCOEFF_NORMED")
        assert hasattr(MatchMethod, "TM_SQDIFF_NORMED")


================================================================================
FILE PATH: tests\test_parser.py
LINES: 394
================================================================================

"""
Tests for DSL Parser.
"""

from core.dsl.ast import (
    BinaryExpr,
    CallExpr,
    ExprStmt,
    ForStmt,
    GotoStmt,
    IfStmt,
    LabelStmt,
    LetStmt,
    WhileStmt,
)
from core.dsl.parser import Parser


class TestParserBasics:
    """Test basic parser functionality."""

    def test_empty_source(self) -> None:
        """Empty source produces empty program."""
        parser = Parser("")
        program = parser.parse()
        assert len(program.flows) == 0
        assert len(program.interrupts) == 0
        assert len(parser.errors) == 0

    def test_simple_flow(self) -> None:
        """Simple flow declaration."""
        parser = Parser("flow main {}")
        program = parser.parse()
        assert len(program.flows) == 1
        assert program.flows[0].name == "main"
        assert len(parser.errors) == 0


class TestParserFlows:
    """Test flow parsing."""

    def test_flow_with_statements(self) -> None:
        """Flow with multiple statements."""
        source = """
        flow main {
            wait_image("btn");
            click(100, 200);
            sleep(500ms);
        }
        """
        parser = Parser(source)
        program = parser.parse()
        assert len(program.flows) == 1
        flow = program.flows[0]
        assert len(flow.body.statements) == 3

    def test_multiple_flows(self) -> None:
        """Multiple flow declarations."""
        source = """
        flow main {
            run_flow("helper");
        }
        flow helper {
            log("helping");
        }
        """
        parser = Parser(source)
        program = parser.parse()
        assert len(program.flows) == 2
        assert program.flows[0].name == "main"
        assert program.flows[1].name == "helper"


class TestParserStatements:
    """Test statement parsing."""

    def test_label_goto(self) -> None:
        """Label and goto statements."""
        source = """
        flow main {
            label start:
            sleep(1s);
            goto start;
        }
        """
        parser = Parser(source)
        program = parser.parse()
        flow = program.flows[0]
        assert isinstance(flow.body.statements[0], LabelStmt)
        assert flow.body.statements[0].name == "start"
        assert isinstance(flow.body.statements[2], GotoStmt)
        assert flow.body.statements[2].target == "start"

    def test_if_statement(self) -> None:
        """If statement."""
        source = """
        flow main {
            if image_exists("btn") {
                click(100, 200);
            }
        }
        """
        parser = Parser(source)
        program = parser.parse()
        flow = program.flows[0]
        assert isinstance(flow.body.statements[0], IfStmt)

    def test_if_elif_else(self) -> None:
        """If with elif and else."""
        source = """
        flow main {
            if x == 1 {
                log("one");
            } elif x == 2 {
                log("two");
            } else {
                log("other");
            }
        }
        """
        parser = Parser(source)
        program = parser.parse()
        if_stmt = program.flows[0].body.statements[0]
        assert isinstance(if_stmt, IfStmt)
        assert len(if_stmt.elif_branches) == 1
        assert if_stmt.else_branch is not None

    def test_while_loop(self) -> None:
        """While loop."""
        source = """
        flow main {
            while running {
                sleep(100ms);
            }
        }
        """
        parser = Parser(source)
        program = parser.parse()
        stmt = program.flows[0].body.statements[0]
        assert isinstance(stmt, WhileStmt)

    def test_for_loop(self) -> None:
        """For loop."""
        source = """
        flow main {
            for i in range(10) {
                log(i);
            }
        }
        """
        parser = Parser(source)
        program = parser.parse()
        stmt = program.flows[0].body.statements[0]
        assert isinstance(stmt, ForStmt)
        assert stmt.variable == "i"

    def test_let_statement(self) -> None:
        """Let variable declaration."""
        source = """
        flow main {
            let x = 5;
            let y;
        }
        """
        parser = Parser(source)
        program = parser.parse()
        stmt1 = program.flows[0].body.statements[0]
        stmt2 = program.flows[0].body.statements[1]
        assert isinstance(stmt1, LetStmt)
        assert stmt1.name == "x"
        assert stmt1.initializer is not None
        assert isinstance(stmt2, LetStmt)
        assert stmt2.initializer is None


class TestParserExpressions:
    """Test expression parsing."""

    def test_function_call(self) -> None:
        """Function call with args and kwargs."""
        source = """
        flow main {
            wait_image("btn", timeout=5s, appear=true);
        }
        """
        parser = Parser(source)
        program = parser.parse()
        stmt = program.flows[0].body.statements[0]
        assert isinstance(stmt, ExprStmt)
        call = stmt.expr
        assert isinstance(call, CallExpr)
        assert call.callee == "wait_image"
        assert len(call.args) == 1
        assert "timeout" in call.kwargs
        assert "appear" in call.kwargs

    def test_binary_expressions(self) -> None:
        """Binary expressions."""
        source = """
        flow main {
            let x = 1 + 2 * 3;
            let y = a == b && c != d;
        }
        """
        parser = Parser(source)
        program = parser.parse()
        assert len(parser.errors) == 0

        stmt1 = program.flows[0].body.statements[0]
        assert isinstance(stmt1, LetStmt)
        assert isinstance(stmt1.initializer, BinaryExpr)

    def test_comparison_operators(self) -> None:
        """Comparison operators."""
        source = """
        flow main {
            if x < 10 && y >= 5 {
                log("ok");
            }
        }
        """
        parser = Parser(source)
        parser.parse()
        assert len(parser.errors) == 0

    def test_array_literal(self) -> None:
        """Array literal."""
        source = """
        flow main {
            wait_any(["btn1", "btn2", "btn3"]);
        }
        """
        parser = Parser(source)
        parser.parse()
        assert len(parser.errors) == 0


class TestParserHotkeys:
    """Test hotkeys parsing."""

    def test_hotkeys_block(self) -> None:
        """Hotkeys block."""
        source = """
        hotkeys {
            start = "F5"
            stop = "F6"
            pause = "F7"
        }
        """
        parser = Parser(source)
        program = parser.parse()
        assert program.hotkeys is not None
        assert program.hotkeys.bindings["start"] == "F5"
        assert program.hotkeys.bindings["stop"] == "F6"


class TestParserInterrupts:
    """Test interrupt parsing."""

    def test_interrupt_block(self) -> None:
        """Interrupt declaration."""
        source = """
        interrupt {
            priority 10
            when image "error_popup"
            {
                click(50, 50);
            }
        }
        """
        parser = Parser(source)
        program = parser.parse()
        assert len(program.interrupts) == 1
        interrupt = program.interrupts[0]
        assert interrupt.priority == 10
        assert interrupt.when_asset == "error_popup"


class TestParserErrorRecovery:
    """Test parser error recovery."""

    def test_missing_semicolon(self) -> None:
        """Missing semicolon continues parsing."""
        source = """
        flow main {
            log("first")
            log("second");
        }
        """
        parser = Parser(source)
        program = parser.parse()
        # Should still parse both statements
        assert len(program.flows) == 1

    def test_invalid_token_recovery(self) -> None:
        """Invalid token allows recovery."""
        source = """
        flow main {
            @@invalid@@
            log("recovered");
        }
        """
        parser = Parser(source)
        program = parser.parse()
        # Parser should recover after error
        assert len(program.flows) == 1

    def test_unclosed_brace(self) -> None:
        """Unclosed brace produces error."""
        source = """
        flow main {
            log("test");
        """
        parser = Parser(source)
        parser.parse()
        assert len(parser.errors) > 0


class TestParserSpans:
    """Test span tracking."""

    def test_flow_span(self) -> None:
        """Flow has correct span."""
        source = "flow main {}"
        parser = Parser(source)
        program = parser.parse()
        flow = program.flows[0]
        assert flow.span.start_line == 1
        assert flow.span.start_col == 1

    def test_statement_span(self) -> None:
        """Statement has correct span."""
        source = """
flow main {
    log("test");
}"""
        parser = Parser(source)
        program = parser.parse()
        stmt = program.flows[0].body.statements[0]
        assert stmt.span.start_line == 3


class TestParserCompleteScript:
    """Test complete script parsing."""

    def test_full_script(self) -> None:
        """Complete script with all features."""
        source = """
        hotkeys {
            start = "F5"
            stop = "F6"
        }

        const MAX_RETRIES = 5;

        flow main {
            let retries = 0;

            label start:

            if image_exists("ready") {
                click(100, 200);
            } else {
                sleep(1s);
                retries = retries + 1;

                if retries < MAX_RETRIES {
                    goto start;
                }
            }

            run_flow("cleanup");
        }

        flow cleanup {
            log("cleaning up", level="info");
        }

        interrupt {
            priority 10
            when image "error"
            {
                click(50, 50);
            }
        }
        """
        parser = Parser(source)
        program = parser.parse()

        assert len(parser.errors) == 0
        assert program.hotkeys is not None
        assert len(program.constants) == 1
        assert len(program.flows) == 2
        assert len(program.interrupts) == 1


================================================================================
FILE PATH: tests\test_runner_goto.py
LINES: 261
================================================================================

"""
Test runner with Label/Goto flow control.
"""

import pytest

from core.models import (
    AssetImage,
    Click,
    Delay,
    Flow,
    Goto,
    Hotkey,
    IfImage,
    Label,
    Script,
    TypeText,
)
from core.templates import TemplateStore


class MockMatcher:
    """Mock matcher for testing."""

    def __init__(self) -> None:
        self.find_results: dict[str, bool] = {}

    def find(self, asset_id: str, roi_override=None):  # type: ignore
        from core.models import Match

        if self.find_results.get(asset_id, False):
            return Match(x=100, y=100, w=50, h=50, confidence=0.95)
        return None

    def exists(self, asset_id: str, roi_override=None) -> bool:  # type: ignore
        return self.find_results.get(asset_id, False)


class MockWaiter:
    """Mock waiter for testing."""

    def __init__(self) -> None:
        self.success = True

    def wait_appear(self, asset_id, **kwargs):  # type: ignore
        from core.models import Match
        from vision.waiter import WaitOutcome, WaitResult

        if self.success:
            return WaitOutcome(
                result=WaitResult.SUCCESS,
                match=Match(x=100, y=100, w=50, h=50, confidence=0.95),
                elapsed_ms=100,
            )
        return WaitOutcome(result=WaitResult.TIMEOUT, elapsed_ms=1000)

    def wait_vanish(self, asset_id, **kwargs):  # type: ignore
        from vision.waiter import WaitOutcome, WaitResult

        if self.success:
            return WaitOutcome(result=WaitResult.SUCCESS, elapsed_ms=100)
        return WaitOutcome(result=WaitResult.TIMEOUT, elapsed_ms=1000)


class MockMouse:
    """Mock mouse for testing."""

    def __init__(self) -> None:
        self.clicks: list[tuple] = []

    def click(self, x=None, y=None, button="left", clicks=1, interval_ms=80):  # type: ignore
        self.clicks.append((x, y, button, clicks))


class MockKeyboard:
    """Mock keyboard for testing."""

    def __init__(self) -> None:
        self.hotkeys: list[list[str]] = []
        self.typed: list[str] = []

    def hotkey(self, keys: list[str]) -> None:
        self.hotkeys.append(keys)

    def type_text(self, text: str, paste_mode: bool = True, enter: bool = False) -> None:
        self.typed.append(text)


class TestRunner:
    """Test runner functionality."""

    @pytest.fixture
    def setup_runner(self):  # type: ignore
        """Create runner with mocks."""
        from core.engine.context import ExecutionContext
        from core.engine.runner import Runner

        script = Script(
            name="Test",
            flows=[
                Flow(
                    name="main",
                    actions=[
                        Label(name="start"),
                        Delay(ms=10),
                        Label(name="middle"),
                        Delay(ms=10),
                        Goto(label="end"),
                        Delay(ms=10),  # Should be skipped
                        Label(name="end"),
                        Delay(ms=10),
                    ],
                )
            ],
        )

        templates = TemplateStore()
        ctx = ExecutionContext(script=script, templates=templates)

        # Inject mocks
        ctx.matcher = MockMatcher()
        ctx.waiter = MockWaiter()
        ctx.mouse = MockMouse()
        ctx.keyboard = MockKeyboard()

        runner = Runner(ctx)
        return runner, ctx

    def test_label_goto(self, setup_runner) -> None:  # type: ignore
        """Test Label and Goto flow control."""
        runner, ctx = setup_runner

        # Track steps executed
        steps_executed = []

        def on_step(flow: str, idx: int, action) -> None:  # type: ignore
            steps_executed.append(idx)

        runner._on_step = on_step
        success = runner.run_flow("main")

        assert success
        # Should skip step 5 (Delay after Goto)
        # Steps: 0 (Label), 1 (Delay), 2 (Label), 3 (Delay), 4 (Goto), 6 (Label), 7 (Delay)
        assert 5 not in steps_executed

    def test_if_image_then(self, setup_runner) -> None:  # type: ignore
        """Test IfImage when image is found."""
        runner, ctx = setup_runner

        # Modify script for this test
        ctx.script = Script(
            name="Test",
            assets=[AssetImage(id="btn", path="btn.png")],
            flows=[
                Flow(
                    name="main",
                    actions=[
                        IfImage(
                            asset_id="btn",
                            then_actions=[Delay(ms=10)],
                            else_actions=[Delay(ms=20)],
                        )
                    ],
                )
            ],
        )

        # Mock: image IS found
        ctx.matcher.find_results["btn"] = True

        success = runner.run_flow("main")
        assert success

    def test_if_image_else(self, setup_runner) -> None:  # type: ignore
        """Test IfImage when image is NOT found."""
        runner, ctx = setup_runner

        ctx.script = Script(
            name="Test",
            assets=[AssetImage(id="btn", path="btn.png")],
            flows=[
                Flow(
                    name="main",
                    actions=[
                        IfImage(
                            asset_id="btn",
                            then_actions=[Delay(ms=10)],
                            else_actions=[Delay(ms=20)],
                        )
                    ],
                )
            ],
        )

        # Mock: image NOT found
        ctx.matcher.find_results["btn"] = False

        success = runner.run_flow("main")
        assert success

    def test_click_at_match(self, setup_runner) -> None:  # type: ignore
        """Test Click with use_match=True."""
        runner, ctx = setup_runner

        from core.models import Match

        ctx.last_match = Match(x=200, y=300, w=50, h=50, confidence=0.95)

        ctx.script = Script(
            name="Test",
            flows=[
                Flow(
                    name="main",
                    actions=[Click(use_match=True)],
                )
            ],
        )

        success = runner.run_flow("main")
        assert success
        assert len(ctx.mouse.clicks) == 1
        # Should click at center of match (200 + 25, 300 + 25)
        assert ctx.mouse.clicks[0][0] == 225
        assert ctx.mouse.clicks[0][1] == 325

    def test_hotkey(self, setup_runner) -> None:  # type: ignore
        """Test Hotkey action."""
        runner, ctx = setup_runner

        ctx.script = Script(
            name="Test",
            flows=[
                Flow(
                    name="main",
                    actions=[Hotkey(keys=["CTRL", "S"])],
                )
            ],
        )

        success = runner.run_flow("main")
        assert success
        assert ctx.keyboard.hotkeys == [["CTRL", "S"]]

    def test_type_text(self, setup_runner) -> None:  # type: ignore
        """Test TypeText action."""
        runner, ctx = setup_runner

        ctx.script = Script(
            name="Test",
            flows=[
                Flow(
                    name="main",
                    actions=[TypeText(text="Hello World")],
                )
            ],
        )

        success = runner.run_flow("main")
        assert success
        assert ctx.keyboard.typed == ["Hello World"]


================================================================================
FILE PATH: tests\test_script_roundtrip.py
LINES: 172
================================================================================

"""
Test script roundtrip - load, modify, save, reload.
"""

import tempfile
from pathlib import Path

import pytest

from core.models import (
    ROI,
    AssetImage,
    Click,
    Delay,
    Flow,
    Goto,
    Hotkey,
    Label,
    RunFlow,
    Script,
    TypeText,
    WaitImage,
)
from core.script.io import (
    ScriptLoadError,
    create_empty_script,
    load_script,
    save_script,
    script_to_yaml_string,
)


class TestModels:
    """Test pydantic models."""

    def test_roi_center(self) -> None:
        roi = ROI(x=100, y=200, w=50, h=40)
        assert roi.center == (125, 220)

    def test_roi_contains(self) -> None:
        roi = ROI(x=100, y=100, w=100, h=100)
        assert roi.contains(150, 150)
        assert not roi.contains(50, 50)
        assert not roi.contains(250, 250)

    def test_asset_path_normalization(self) -> None:
        asset = AssetImage(id="test", path="assets\\image.png")
        assert asset.path == "assets/image.png"

    def test_action_discriminated_union(self) -> None:
        # Test that actions can be created and have correct type
        wait = WaitImage(asset_id="btn_ok", timeout_ms=5000)
        assert wait.action == "WaitImage"

        click = Click(x=100, y=200, button="right")
        assert click.action == "Click"

        delay = Delay(ms=500)
        assert delay.action == "Delay"


class TestScriptValidation:
    """Test script validation."""

    def test_validate_missing_asset(self) -> None:
        script = Script(
            name="Test",
            assets=[],
            flows=[
                Flow(
                    name="main",
                    actions=[WaitImage(asset_id="nonexistent", timeout_ms=1000)],
                )
            ],
        )
        errors = script.validate_references()
        assert len(errors) == 1
        assert "nonexistent" in errors[0]

    def test_validate_missing_flow(self) -> None:
        script = Script(
            name="Test",
            assets=[],
            flows=[
                Flow(
                    name="main",
                    actions=[RunFlow(flow_name="nonexistent")],
                )
            ],
        )
        errors = script.validate_references()
        assert len(errors) == 1
        assert "nonexistent" in errors[0]

    def test_validate_success(self) -> None:
        script = Script(
            name="Test",
            assets=[AssetImage(id="btn", path="btn.png")],
            flows=[
                Flow(name="main", actions=[WaitImage(asset_id="btn")]),
                Flow(name="helper", actions=[Delay(ms=100)]),
            ],
        )
        errors = script.validate_references()
        assert len(errors) == 0


class TestScriptIO:
    """Test YAML IO."""

    def test_roundtrip(self) -> None:
        """Save script, reload, compare."""
        original = Script(
            name="Roundtrip Test",
            version="2.0",
            assets=[
                AssetImage(id="btn_ok", path="assets/btn_ok.png", threshold=0.85),
                AssetImage(id="dialog", path="assets/dialog.png", roi=ROI(x=0, y=0, w=800, h=600)),
            ],
            flows=[
                Flow(
                    name="main",
                    actions=[
                        Delay(ms=100),  # Use actions that don't reference assets
                        TypeText(text="Hello World", paste_mode=True),
                        Hotkey(keys=["CTRL", "S"]),
                        Delay(ms=1000),
                        Label(name="loop_start"),
                        Goto(label="loop_start"),
                    ],
                ),
            ],
        )

        with tempfile.TemporaryDirectory() as tmpdir:
            path = Path(tmpdir) / "script.yaml"
            save_script(original, path)

            # Check YAML was created
            assert path.exists()
            content = path.read_text()
            assert "Roundtrip Test" in content
            assert "btn_ok" in content

            # Reload (use dict loading to skip reference validation)
            from ruamel.yaml import YAML

            yaml = YAML()
            with open(path, encoding="utf-8") as f:
                data = yaml.load(f)
            reloaded = Script.model_validate(data)

            assert reloaded.name == original.name
            assert len(reloaded.assets) == len(original.assets)
            assert len(reloaded.flows) == len(original.flows)

    def test_load_nonexistent(self) -> None:
        with pytest.raises(ScriptLoadError) as exc:
            load_script("nonexistent.yaml")
        assert "not found" in str(exc.value).lower()

    def test_create_empty(self) -> None:
        script = create_empty_script("New Script")
        assert script.name == "New Script"
        assert len(script.flows) == 1
        assert script.flows[0].name == "main"

    def test_to_yaml_string(self) -> None:
        script = create_empty_script()
        yaml_str = script_to_yaml_string(script)
        assert "main" in yaml_str
        assert "flows:" in yaml_str


================================================================================
FILE PATH: tests\test_security.py
LINES: 53
================================================================================

import unittest

from core.dsl.parser import Parser
from core.engine.interpreter import Interpreter
from core.security.policy import SecurityViolation


class TestSecuritySandbox(unittest.TestCase):
    def test_default_unsafe(self):
        """Default policy should allow actions."""
        code = 'flow main { type("hello"); }'
        interp = Interpreter()
        # Should not raise exception
        try:
            interp.execute(Parser(code).parse())
        except SecurityViolation:
            self.fail("Default policy should be UNSAFE (allow everything)")

    def test_permission_denied(self):
        """Restricted policy should block unauthorized actions."""
        # Policy only allows FS_READ, but code tries INPUT_CONTROL (type)
        code = """
        @permissions { "FS_READ" }
        flow main {
            type("should fail");
        }
        """
        interp = Interpreter()
        program = Parser(code).parse()
        print(f"DEBUG: Parsed permissions: {program.permissions}")
        if not program.permissions:
            print(f"DEBUG: Parser errors: {Parser(code).errors}")

        with self.assertRaises(SecurityViolation):
            interp.execute(program)

    def test_permission_granted(self):
        """Policy with correct permission should succeed."""
        code = """
        @permissions { "INPUT_CONTROL" }
        flow main {
            type("should pass");
        }
        """
        interp = Interpreter()
        try:
            interp.execute(Parser(code).parse())
        except SecurityViolation as e:
            self.fail(f"Should allow action with correct permission: {e}")


if __name__ == "__main__":
    unittest.main()


================================================================================
FILE PATH: tests\test_semantic.py
LINES: 304
================================================================================

"""
Tests for DSL Semantic Analyzer.
"""

from core.dsl.diagnostics import Severity
from core.dsl.parser import Parser
from core.dsl.semantic import analyze


class TestSemanticAssets:
    """Test asset reference validation."""

    def test_unknown_asset_error(self) -> None:
        """Unknown asset produces error."""
        source = """
        flow main {
            wait_image("unknown_button");
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program, known_assets=[])

        assert len(diagnostics) > 0
        assert any("unknown_button" in d.message for d in diagnostics)
        assert any(d.code == "E1101" for d in diagnostics)

    def test_known_asset_no_error(self) -> None:
        """Known asset produces no error."""
        source = """
        flow main {
            wait_image("btn_ok");
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program, known_assets=["btn_ok"])

        asset_errors = [d for d in diagnostics if d.code == "E1101"]
        assert len(asset_errors) == 0

    def test_wait_any_assets(self) -> None:
        """wait_any validates all assets in array."""
        source = """
        flow main {
            wait_any(["btn1", "btn2", "btn3"]);
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program, known_assets=["btn1"])

        # Should report btn2 and btn3 as unknown
        asset_errors = [d for d in diagnostics if d.code == "E1101"]
        assert len(asset_errors) >= 2

    def test_asset_quick_fix(self) -> None:
        """Unknown asset has quick fix."""
        source = """
        flow main {
            wait_image("new_button");
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program, known_assets=[])

        asset_error = next(d for d in diagnostics if d.code == "E1101")
        assert asset_error.quick_fixes is not None
        assert len(asset_error.quick_fixes) > 0
        assert asset_error.quick_fixes[0].action == "capture_asset"


class TestSemanticFlows:
    """Test flow reference validation."""

    def test_unknown_flow_error(self) -> None:
        """Unknown flow produces error."""
        source = """
        flow main {
            run_flow("nonexistent");
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program)

        assert any(d.code == "E1102" for d in diagnostics)
        assert any("nonexistent" in d.message for d in diagnostics)

    def test_known_flow_no_error(self) -> None:
        """Known flow produces no error."""
        source = """
        flow main {
            run_flow("helper");
        }

        flow helper {
            log("helping");
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program)

        flow_errors = [d for d in diagnostics if d.code == "E1102"]
        assert len(flow_errors) == 0


class TestSemanticLabels:
    """Test label/goto validation."""

    def test_unknown_label_error(self) -> None:
        """Goto unknown label produces error."""
        source = """
        flow main {
            goto nonexistent;
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program)

        assert any(d.code == "E1103" for d in diagnostics)

    def test_known_label_no_error(self) -> None:
        """Goto known label produces no error."""
        source = """
        flow main {
            label start:
            sleep(1s);
            goto start;
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program)

        label_errors = [d for d in diagnostics if d.code == "E1103"]
        assert len(label_errors) == 0

    def test_duplicate_label_error(self) -> None:
        """Duplicate label produces error."""
        source = """
        flow main {
            label start:
            sleep(1s);
            label start:
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program)

        assert any(d.code == "E1104" for d in diagnostics)

    def test_labels_scoped_to_flow(self) -> None:
        """Labels are scoped to their flow."""
        source = """
        flow main {
            goto helper_label;
        }

        flow helper {
            label helper_label:
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program)

        # goto helper_label should fail because it's in different flow
        assert any(d.code == "E1103" for d in diagnostics)


class TestSemanticDuplicates:
    """Test duplicate definition detection."""

    def test_duplicate_flow_error(self) -> None:
        """Duplicate flow produces error."""
        source = """
        flow main {
            log("first");
        }

        flow main {
            log("second");
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program)

        assert any(d.code == "E1105" for d in diagnostics)


class TestSemanticFunctionCalls:
    """Test function call validation."""

    def test_missing_required_argument(self) -> None:
        """Missing required argument produces error."""
        source = """
        flow main {
            click();
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program)

        assert any(d.code == "E1109" for d in diagnostics)

    def test_all_required_args_no_error(self) -> None:
        """All required args produces no error."""
        source = """
        flow main {
            click(100, 200);
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program)

        arg_errors = [d for d in diagnostics if d.code == "E1109"]
        assert len(arg_errors) == 0


class TestSemanticInterrupts:
    """Test interrupt validation."""

    def test_interrupt_unknown_asset(self) -> None:
        """Interrupt with unknown asset produces error."""
        source = """
        interrupt {
            priority 10
            when image "unknown_popup"
            {
                click(50, 50);
            }
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program, known_assets=[])

        assert any(d.code == "E1101" for d in diagnostics)


class TestSemanticCompleteScript:
    """Test complete script validation."""

    def test_valid_script_no_errors(self) -> None:
        """Valid script produces no semantic errors."""
        source = """
        hotkeys {
            start = "F5"
            stop = "F6"
        }

        flow main {
            label start:

            wait_image("btn_ready", timeout=5s);
            click(100, 200);

            if image_exists("btn_done") {
                return;
            }

            sleep(1s);
            goto start;
        }

        interrupt {
            priority 10
            when image "error_popup"
            {
                click(50, 50);
            }
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program, known_assets=["btn_ready", "btn_done", "error_popup"])

        errors = [d for d in diagnostics if d.severity == Severity.ERROR]
        assert len(errors) == 0

    def test_multiple_errors(self) -> None:
        """Multiple errors are all reported."""
        source = """
        flow main {
            wait_image("unknown1");
            wait_image("unknown2");
            run_flow("missing_flow");
            goto missing_label;
        }
        """
        parser = Parser(source)
        program = parser.parse()
        diagnostics = analyze(program, known_assets=[])

        # Should have at least 4 errors
        assert len(diagnostics) >= 4


================================================================================
FILE PATH: tests\manual\test_graph_nodes.py
LINES: 105
================================================================================

"""
Test script for Node Rendering.
Creates sample nodes to verify visual appearance.
"""

import sys
from pathlib import Path

# Add project root
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from PySide6.QtWidgets import (
    QApplication,
    QHBoxLayout,
    QLabel,
    QMainWindow,
    QPushButton,
    QVBoxLayout,
    QWidget,
)

from app.ui.graph_node import NodeItem
from app.ui.graph_view import FlowGraphView
from core.models import ClickImage, Delay, Hotkey, IfImage, Loop, ReadText, WaitImage


class TestWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Node Rendering Test")
        self.setGeometry(100, 100, 1400, 900)

        # Central widget
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)

        # Controls
        controls = QHBoxLayout()

        info = QLabel(
            "Controls: Scroll=Zoom | MidMouse=Pan | LeftClick=Select | DRAG FROM RIGHT SOCKET TO LEFT SOCKET TO WIRE"
        )
        controls.addWidget(info)

        self.zoom_label = QLabel("Zoom: 100%")
        controls.addWidget(self.zoom_label)

        # Add node button
        add_btn = QPushButton("Add Sample Nodes")
        add_btn.clicked.connect(self._add_sample_nodes)
        controls.addWidget(add_btn)

        clear_btn = QPushButton("Clear")
        clear_btn.clicked.connect(self._clear)
        controls.addWidget(clear_btn)

        layout.addLayout(controls)

        # Graph view
        self.graph = FlowGraphView()
        self.graph.zoom_changed.connect(self._on_zoom)
        layout.addWidget(self.graph)

        # Add initial samples
        self._add_sample_nodes()

    def _on_zoom(self, level: float):
        self.zoom_label.setText(f"Zoom: {level * 100:.0f}%")

    def _add_sample_nodes(self):
        """Add sample nodes to demonstrate different action types."""
        # Create sample actions
        samples = [
            (ClickImage(asset_id="button_ok"), -300, -100),
            (WaitImage(asset_id="loading"), -300, 50),
            (IfImage(asset_id="error"), 0, -100),
            (ReadText(variable_name="$hp", roi={"x": 0, "y": 0, "w": 100, "h": 30}), 0, 50),
            (Delay(ms=1000), 300, -100),
            (Hotkey(keys=["CTRL", "C"]), 300, 50),
            (Loop(iterations=5), 0, 200),
        ]

        for action, x, y in samples:
            node = NodeItem(action, x, y)
            self.graph.scene.addItem(node)

    def _clear(self):
        """Clear all nodes."""
        self.graph.scene.clear()


if __name__ == "__main__":
    app = QApplication(sys.argv)

    # Apply dark theme
    theme_path = project_root / "app" / "resources" / "dark_theme.qss"
    if theme_path.exists():
        app.setStyleSheet(theme_path.read_text(encoding="utf-8"))

    window = TestWindow()
    window.show()

    sys.exit(app.exec())


================================================================================
FILE PATH: tests\manual\test_graph_view.py
LINES: 57
================================================================================

"""
Test script for FlowGraphView.
Verifies zoom, pan, and grid rendering.
"""

import sys
from pathlib import Path

# Add project root
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from PySide6.QtWidgets import QApplication, QLabel, QMainWindow, QVBoxLayout, QWidget

from app.ui.graph_view import FlowGraphView


class TestWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Flow Graph View Test")
        self.setGeometry(100, 100, 1200, 800)

        # Central widget
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)

        # Info label
        info = QLabel("Controls: Scroll = Zoom | Middle Mouse = Pan")
        layout.addWidget(info)

        # Zoom level label
        self.zoom_label = QLabel("Zoom: 100%")
        layout.addWidget(self.zoom_label)

        # Graph view
        self.graph = FlowGraphView()
        self.graph.zoom_changed.connect(self._on_zoom)
        layout.addWidget(self.graph)

    def _on_zoom(self, level: float):
        self.zoom_label.setText(f"Zoom: {level * 100:.0f}%")


if __name__ == "__main__":
    app = QApplication(sys.argv)

    # Apply dark theme if available
    theme_path = project_root / "app" / "resources" / "dark_theme.qss"
    if theme_path.exists():
        app.setStyleSheet(theme_path.read_text(encoding="utf-8"))

    window = TestWindow()
    window.show()

    sys.exit(app.exec())


================================================================================
FILE PATH: tests\manual\test_phase3_sync.py
LINES: 40
================================================================================

"""Test Phase 3: Bidirectional Sync"""

import sys
sys.path.insert(0, ".")

from core.dsl.document import ScriptDocument
from core.dsl.adapter import ir_to_actions
from core.dsl.formatter import format_code

# Test code with endif
code = """
flow main {
    if_image("capture_1");
    click(x=1, y=1);
    endif;
}
"""

print("=== Test 1: Code ‚Üí IR ‚Üí Actions ===")
doc = ScriptDocument()
doc.update_from_code(code)
print("IR valid:", doc.ir.is_valid)
print("Flows:", len(doc.ir.flows))

if doc.ir.flows:
    print("Actions in main:", len(doc.ir.flows[0].actions))
    for a in doc.ir.flows[0].actions:
        print("  -", a.action_type, a.params)
    
    # Test ir_to_actions conversion
    print("\nConverted to Action models:")
    actions = ir_to_actions(doc.ir.flows[0].actions)
    for a in actions:
        print("  -", type(a).__name__)

print("\n=== Test 2: Formatter Output ===")
formatted = format_code(code)
print("Formatted code:")
print(formatted)
print("\nContains 'endif':", "endif" in formatted)


================================================================================
FILE PATH: tests\manual\verify_ide_completeness.py
LINES: 183
================================================================================

import sys
from pathlib import Path
from unittest.mock import patch

sys.path.append(r"c:\Auto\Newauto")

from PySide6.QtCore import QPointF, QRect, Qt
from PySide6.QtGui import QMouseEvent
from PySide6.QtWidgets import QApplication

from app.ui.ide_main_window import IDEMainWindow
from app.ui.intellisense import DSL_SIGNATURES
from core.models import InterruptRule


def test_ide_components():
    print("üöÄ Starting IDE Comprehensive Audit...")

    # Init App
    QApplication.instance() or QApplication(sys.argv)

    # 1. Test IDEMainWindow Initialization
    try:
        window = IDEMainWindow()
        window.show()
        print("‚úÖ IDEMainWindow initialized successfully")
    except Exception as e:
        print(f"‚ùå IDEMainWindow init failed: {e}")
        return

    # 2. Test Code Editor & IntelliSense
    print("\nüß™ Testing Code Editor & Intelligence...")
    editor = window.editor

    # 2.1 Asset Peek
    editor.set_asset_provider(lambda x: Path(f"assets/{x}.png"))
    # Mock mouse move
    # We can't easily trigger real tooltip without event loop, but we can verify logic
    # (Logic is inside mouseMoveEvent, hard to unit test without events.
    # But we verified it manually previously. Here we verify no crash on move.)
    event = QMouseEvent(
        QMouseEvent.Type.MouseMove,
        QPointF(10, 10),
        Qt.MouseButton.NoButton,
        Qt.MouseButton.NoButton,
        Qt.KeyboardModifier.NoModifier,
    )
    try:
        editor.mouseMoveEvent(event)
        print("‚úÖ Asset Peek (mouseMoveEvent) handled without crash")
    except Exception as e:
        print(f"‚ùå Asset Peek failed: {e}")

    # 2.2 Test Line Highlighting (Recent Bug Verification)
    try:
        # Trigger highlight manually
        editor._highlight_current_line()
        print("‚úÖ Line Highlighting (QTextEdit.ExtraSelection) works")
    except NameError as e:
        print(f"‚ùå Line Highlighting failed (NameError): {e}")
    except Exception as e:
        print(f"‚ùå Line Highlighting failed: {e}")

    # 2.2 Signature Help Logic checks
    # Verify signatures exist
    if "click" in DSL_SIGNATURES:
        print(f"‚úÖ Signature Help registry loaded ({len(DSL_SIGNATURES)} signatures)")
    else:
        print("‚ùå Signature Help registry missing 'click'")

    # 3. Test Properties Panel with InterruptRule (Recent Bug Verification)
    print("\nüß™ Testing Properties Panel (Regression Test)...")
    panel = window.inspector
    try:
        # Mock an interrupt rule
        rule = InterruptRule(when_image="test_img_id", do_actions=[])
        # Force load (simulating selection)
        # We need to wrap it like the IDE does: {"action": rule, "type": "interrupt", "index": 0}
        data = {"action": rule, "type": "interrupt", "index": 0}
        panel.load_action(data)
        print("‚úÖ PropertiesPanel loaded InterruptRule successfully (Fix verified)")
    except AttributeError as e:
        print(f"‚ùå PropertiesPanel crashed on InterruptRule: {e}")
    except Exception as e:
        print(f"‚ùå PropertiesPanel failed: {e}")

    # 4. Test Syntax Checking
    print("\nüß™ Testing Syntax Checker...")
    code = """
@main:
  click btn
    """
    editor.set_code(code)
    try:
        window._check_syntax()
        # Verify output panel has logs (it might fail content check if parser strict, but shouldn't crash)
        print("‚úÖ Syntax Check ran successfully")
    except Exception as e:
        print(f"‚ùå Syntax Check crashed: {e}")

    # 5. Test Flow Editor Integration (Regression Test)
    print("\nüß™ Testing Flow Editor Integration...")
    try:
        # Mock window.show to avoid opening real window during test
        with patch.object(window, "_flow_window", create=True):
            # Also need to mock QMessageBox to avoid popping up on success/fail
            with (
                patch("PySide6.QtWidgets.QMessageBox.warning") as mock_warn,
                patch("PySide6.QtWidgets.QMessageBox.critical") as mock_crit,
            ):
                window._show_flow_editor()
                if mock_warn.called or mock_crit.called:
                    print(
                        f"‚ö†Ô∏è Flow Editor opened with warnings: {mock_warn.call_args or mock_crit.call_args}"
                    )
                else:
                    print("‚úÖ Flow Editor logic executed successfully (Conversion OK)")
    except AttributeError as e:
        print(f"‚ùå IDEMainWindow crashed on Flow Editor (Regression): {e}")
    except Exception as e:
        print(f"‚ùå Flow Editor test failed: {e}")

    # 6. Test Minimap (The Navigator)
    print("\nüß™ Testing Minimap (The Navigator)...")
    try:
        if hasattr(editor, "minimap"):
            print("‚úÖ Minimap widget initialized")
            if editor.minimap.isVisible():
                print("‚úÖ Minimap is visible")
            else:
                # Minimap might be hidden if window not shown properly or logic differs
                # logic says self.minimap.show() in init.
                print(
                    "‚ö†Ô∏è Minimap exists but isVisible() returned False (might be due to mocked window state)"
                )

            # Test paint event (no crash)
            # editor.minimap.repaint()

            # Test Signal Connection (Regression Test for AttributeError)
            try:
                editor.updateRequest.emit(QRect(0, 0, 10, 10), 0)
                print("‚úÖ Minimap _on_update_request Slot connection verified")
            except Exception as e:
                print(f"‚ùå Minimap Slot connection FAILED: {e}")

            print("‚úÖ Minimap integration checked")

        else:
            print("‚ùå Minimap widget NOT found in editor")
    except Exception as e:
        print(f"‚ùå Minimap test failed: {e}")

    # 7. Test Structure Panel Integration
    print("\nüß™ Testing Structure Overlay...")
    try:
        if hasattr(window, "structure_panel"):
            print("‚úÖ StructurePanel widget found in window")

            # Test refresh
            test_code = "@flow test:\n  #start"
            window.structure_panel.refresh(test_code)

            # Check items
            item_count = window.structure_panel.tree.topLevelItemCount()
            if item_count > 0:
                print(f"‚úÖ Structure parsed successfully (found {item_count} items)")
                # Verify navigation signal works (mock emit)
                # window.structure_panel.navigate_requested.emit(1)
            else:
                print("‚ö†Ô∏è Structure parsing produced 0 items (check regex?)")
        else:
            print("‚ùå StructurePanel widget NOT found in IDEMainWindow")
    except Exception as e:
        print(f"‚ùå Structure Panel test failed: {e}")

    # 8. Clean up
    window.close()
    print("\n‚ú® Audit Complete. If all ticks are green, the System is stable.")


if __name__ == "__main__":
    test_ide_components()


================================================================================
FILE PATH: tests\verification\test_graph_execution.py
LINES: 72
================================================================================

"""
Test graph execution with GraphWalker.
"""

import sys
from pathlib import Path

project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from core.graph import list_to_graph
from core.graph.walker import GraphWalker
from core.models import ClickImage, Delay, Flow, WaitImage


def test_graph_walker():
    """Test basic graph execution."""
    print("=" * 60)
    print("Graph Execution Test")
    print("=" * 60)

    # Create a simple flow
    flow = Flow(name="test_flow")
    flow.actions = [
        Delay(ms=100),
        ClickImage(asset_id="button1"),
        WaitImage(asset_id="loading"),
        ClickImage(asset_id="button2"),
    ]

    # Convert to graph
    flow.graph = list_to_graph(flow.actions)

    print("\nüìä Graph Info:")
    print(f"  Nodes: {len(flow.graph.nodes)}")
    print(f"  Connections: {len(flow.graph.connections)}")

    # Create walker
    walker = GraphWalker(flow.graph)

    # Find start node
    start = walker.find_start_node()
    print(f"\nüöÄ Start Node: {type(start.action).__name__}")

    # Track execution order
    execution_order = []

    def mock_executor(action):
        """Mock action executor that just records execution."""
        action_name = type(action).__name__
        execution_order.append(action_name)
        print(f"  ‚úì Executed: {action_name}")
        return None  # No branch result

    # Execute graph
    print("\n‚öôÔ∏è  Executing graph...")
    walker.execute_graph(mock_executor)

    # Verify execution order
    print("\nüìã Execution Order:")
    for i, name in enumerate(execution_order):
        print(f"  {i+1}. {name}")

    expected = ["Delay", "ClickImage", "WaitImage", "ClickImage"]
    assert execution_order == expected, f"Expected {expected}, got {execution_order}"

    print(f"\n‚úÖ Test passed! All {len(execution_order)} nodes executed in correct order.")
    print("=" * 60)


if __name__ == "__main__":
    test_graph_walker()


================================================================================
FILE PATH: tests\verification\test_graph_model.py
LINES: 101
================================================================================

"""
Test graph data model and conversion.
"""

import sys
from pathlib import Path

project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

import yaml

from core.graph import graph_to_list, list_to_graph
from core.models import ClickImage, Delay, Flow, WaitImage


def _create_test_flow() -> Flow:
    """Helper to create a test flow with graph."""
    flow = Flow(name="test_flow")
    flow.actions = [
        Delay(ms=1000),
        ClickImage(asset_id="button"),
        WaitImage(asset_id="loading"),
    ]
    flow.graph = list_to_graph(flow.actions)
    return flow


def test_model_creation():
    """Test creating graph models."""
    flow = _create_test_flow()

    assert len(flow.graph.nodes) == 3
    assert len(flow.graph.connections) == 2


def test_serialization():
    """Test YAML serialization."""
    flow = _create_test_flow()

    # Serialize to dict
    data = flow.model_dump()

    # Convert to YAML
    yaml_str = yaml.dump(data, sort_keys=False, allow_unicode=True)

    # Deserialize back
    loaded_data = yaml.safe_load(yaml_str)
    loaded_flow = Flow(**loaded_data)

    assert loaded_flow.name == flow.name
    assert len(loaded_flow.graph.nodes) == len(flow.graph.nodes)


def test_graph_to_list():
    """Test graph -> list conversion."""
    flow = _create_test_flow()

    # Convert graph back to list
    actions = graph_to_list(flow.graph)

    assert len(actions) == 3
    assert actions[0].action == "Delay"
    assert actions[1].action == "ClickImage"
    assert actions[2].action == "WaitImage"


def test_backward_compat():
    """Test backward compatibility (flow without graph)."""
    # Legacy format (no graph)
    legacy_flow = Flow(name="legacy")
    legacy_flow.actions = [Delay(ms=500), ClickImage(asset_id="ok")]

    # Should work fine without graph
    yaml_str = yaml.dump(legacy_flow.model_dump(), sort_keys=False)
    loaded = Flow(**yaml.safe_load(yaml_str))

    assert loaded.graph is None
    assert len(loaded.actions) == 2


if __name__ == "__main__":
    print("=" * 60)
    print("Graph Data Model Tests")
    print("=" * 60)

    test_model_creation()
    print("  ‚úì Model creation passed")

    test_serialization()
    print("  ‚úì Serialization passed")

    test_graph_to_list()
    print("  ‚úì Graph-to-list conversion passed")

    test_backward_compat()
    print("  ‚úì Backward compatibility passed")

    print("\n" + "=" * 60)
    print("All tests passed! ‚úì")
    print("=" * 60)


================================================================================
FILE PATH: tests\verification\test_minimal_pydantic.py
LINES: 48
================================================================================

"""
Minimal test to isolate Pydantic validation issue.
"""

import sys
from pathlib import Path

project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

print("Step 1: Import models...")
from core.models import Action, ClickImage, GraphNode

print("Step 2: Create ClickImage directly...")
click = ClickImage(asset_id="test_button")
print(f"  Created: {click}")
print(f"  Action field value: {click.action}")
print(f"  Type: {type(click)}")

print("\nStep 3: Verify ClickImage is an Action...")
# Can't use isinstance with Union types
print("  Skipping isinstance check (Union types don't support it)")

print("\nStep 4: Create GraphNode with ClickImage...")
try:
    node = GraphNode(id="test-123", action=click, x=0, y=0)
    print(f"  ‚úì SUCCESS: {node}")
except Exception as e:
    print(f"  ‚úó FAILED: {type(e).__name__}")
    print(f"  Error: {e}")

print("\nStep 5: Try with model_dump/model_validate...")
try:
    click_dict = click.model_dump()
    print(f"  Dumped to dict: {click_dict}")

    node = GraphNode(id="test-123", action=click_dict, x=0, y=0)  # Pass as dict
    print(f"  ‚úì SUCCESS with dict: {node}")
except Exception as e:
    print(f"  ‚úó FAILED: {type(e).__name__}")
    print(f"  Error: {e}")

print("\nStep 6: Check Action union...")
from typing import get_args

action_types = get_args(Action)
print(f"  Action union has {len(action_types)} types")
print(f"  ClickImage in union? {ClickImage in action_types}")


================================================================================
FILE PATH: tests\verification\test_production.py
LINES: 276
================================================================================

"""
Production Test Suite - Real-world scenarios.

Simulates actual automation scripts to find edge cases and bugs.
"""

import sys
from pathlib import Path

project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))


def test_scenario_1_missing_asset():
    """Scenario: Script references non-existent image."""
    print("\n" + "=" * 60)
    print("SCENARIO 1: Missing Asset Handling")
    print("=" * 60)

    from core.models import ClickImage, Delay, Flow, Script
    from core.validation import validate_assets

    # Create script with missing asset
    script = Script(name="test_missing")
    flow = Flow(name="main")
    flow.actions = [
        Delay(ms=100),
        ClickImage(asset_id="nonexistent_button"),  # This doesn't exist
        Delay(ms=100),
    ]
    script.flows = [flow]

    # Validate
    assets_dir = Path("C:/fake/assets")
    valid, missing = validate_assets(script, assets_dir)

    if not valid:
        print(f"‚úì Validation caught {len(missing)} missing assets before execution")
        print(f"  Missing: {missing}")
        print("‚úì System prevented crash by validating upfront")
        return True
    else:
        print("‚úó Validation should have detected missing asset")
        return False


def test_scenario_2_timeout_protection():
    """Scenario: Wait action with excessive timeout."""
    print("\n" + "=" * 60)
    print("SCENARIO 2: Timeout Protection")
    print("=" * 60)

    from pydantic import ValidationError

    from core.models import WaitImage

    # Try to create wait with 10-minute timeout (should fail)
    try:
        WaitImage(asset_id="test", timeout_ms=600000)
        print("‚úó Should have rejected 10-minute timeout")
        return False
    except ValidationError as e:
        print("‚úì Pydantic rejected excessive timeout (600,000ms)")
        print(f"  Error: {str(e).split('validation error')[0]}")
        print("‚úì System prevents infinite hangs")
        return True


def test_scenario_3_nested_conditionals():
    """Scenario: Complex nested if/else logic."""
    print("\n" + "=" * 60)
    print("SCENARIO 3: Nested Conditionals")
    print("=" * 60)

    from core.models import ClickImage, Delay, IfImage

    try:
        # Create nested IfImage
        inner_if = IfImage(
            asset_id="error_dialog",
            then_actions=[ClickImage(asset_id="ok_button")],
            else_actions=[Delay(ms=100)],
        )

        outer_if = IfImage(
            asset_id="main_menu",
            then_actions=[ClickImage(asset_id="start_button"), inner_if],  # Nested conditional
            else_actions=[Delay(ms=1000)],
        )

        print("‚úì Created nested conditional structure")
        print(f"  Outer IfImage with {len(outer_if.then_actions)} then-actions")
        print(f"  Inner IfImage with {len(inner_if.then_actions)} then-actions")
        print("‚úì Model supports complex logic")
        return True

    except Exception as e:
        print(f"‚úó Failed to create nested conditionals: {e}")
        return False


def test_scenario_4_ocr_with_missing_tesseract():
    """Scenario: OCR action when Tesseract unavailable."""
    print("\n" + "=" * 60)
    print("SCENARIO 4: OCR Graceful Degradation")
    print("=" * 60)

    from core.models import ReadText
    from vision.ocr import TextReader

    reader = TextReader()

    if not reader.available:
        print("‚úì System detected Tesseract unavailable")
        print("  ReadText actions would be skipped gracefully")
        print("‚úì No crash - just warning logged")
        return True
    else:
        print("‚úì Tesseract available - OCR fully functional")

        # Test creating ReadText action
        action = ReadText(variable_name="$hp", roi={"x": 10, "y": 10, "w": 100, "h": 30})
        print(f"‚úì ReadText action created: variable={action.variable_name}")
        return True


def test_scenario_5_graph_execution():
    """Scenario: Execute flow as graph instead of list."""
    print("\n" + "=" * 60)
    print("SCENARIO 5: Graph-based Execution")
    print("=" * 60)

    from core.graph import list_to_graph
    from core.graph.walker import GraphWalker
    from core.models import ClickImage, Delay, Flow

    try:
        # Create flow
        flow = Flow(name="test")
        flow.actions = [
            Delay(ms=100),
            ClickImage(asset_id="btn1"),
            Delay(ms=200),
            ClickImage(asset_id="btn2"),
        ]

        # Convert to graph
        flow.graph = list_to_graph(flow.actions)
        print(f"‚úì Converted {len(flow.actions)} actions to graph")
        print(f"  Graph: {len(flow.graph.nodes)} nodes, {len(flow.graph.connections)} connections")

        # Test walker can find start
        walker = GraphWalker(flow.graph)
        start = walker.find_start_node()

        if start:
            print(f"‚úì Walker found start node: {type(start.action).__name__}")
            print("‚úì Graph execution ready")
            return True
        else:
            print("‚úó Walker could not find start node")
            return False

    except Exception as e:
        print(f"‚úó Graph execution failed: {e}")
        return False


def test_scenario_6_serialization_roundtrip():
    """Scenario: Save and load complex script."""
    print("\n" + "=" * 60)
    print("SCENARIO 6: Serialization Roundtrip")
    print("=" * 60)

    import yaml

    from core.models import Delay, Flow, IfText, ReadText, Script

    try:
        # Create complex script
        script = Script(name="production_bot")
        flow = Flow(name="main_loop")
        flow.actions = [
            ReadText(variable_name="$hp", roi={"x": 0, "y": 0, "w": 50, "h": 20}),
            IfText(
                variable_name="$hp",
                operator="numeric_lt",
                value="50",
                then_actions=[Delay(ms=500)],
                else_actions=[Delay(ms=100)],
            ),
            Delay(ms=1000),
        ]
        script.flows = [flow]

        # Serialize
        yaml_str = yaml.dump(script.model_dump(), sort_keys=False)
        print(f"‚úì Serialized script to YAML ({len(yaml_str)} bytes)")

        # Deserialize
        loaded_data = yaml.safe_load(yaml_str)
        loaded_script = Script(**loaded_data)

        print(f"‚úì Deserialized script: '{loaded_script.name}'")
        print(f"  Flows: {len(loaded_script.flows)}")
        print(f"  Actions: {len(loaded_script.flows[0].actions)}")

        # Verify
        assert loaded_script.name == script.name
        assert len(loaded_script.flows) == len(script.flows)
        print("‚úì Roundtrip successful - no data loss")
        return True

    except Exception as e:
        print(f"‚úó Serialization failed: {e}")
        return False


def run_production_tests():
    """Run all production scenarios."""
    print("\n" + "#" * 60)
    print("# PRODUCTION TEST SUITE")
    print("# Real-world automation scenarios")
    print("#" * 60)

    scenarios = [
        ("Missing Asset Handling", test_scenario_1_missing_asset),
        ("Timeout Protection", test_scenario_2_timeout_protection),
        ("Nested Conditionals", test_scenario_3_nested_conditionals),
        ("OCR Graceful Degradation", test_scenario_4_ocr_with_missing_tesseract),
        ("Graph Execution", test_scenario_5_graph_execution),
        ("Serialization Roundtrip", test_scenario_6_serialization_roundtrip),
    ]

    results = []
    for name, test_func in scenarios:
        try:
            passed = test_func()
            results.append((name, passed, None))
        except Exception as e:
            print(f"\n‚úó CRITICAL ERROR: {e}")
            results.append((name, False, str(e)))

    # Summary
    print("\n" + "#" * 60)
    print("# PRODUCTION TEST SUMMARY")
    print("#" * 60)

    for name, passed, error in results:
        if passed:
            print(f"‚úÖ PASS: {name}")
        else:
            print(f"‚ùå FAIL: {name}")
            if error:
                print(f"         {error}")

    passed_count = sum(1 for _, p, _ in results if p)
    total = len(results)

    print(f"\n{passed_count}/{total} scenarios passed")

    if passed_count == total:
        print("\nüéâ SYSTEM READY FOR PRODUCTION!")
        print("All real-world scenarios handled correctly.")
    else:
        print(f"\n‚ö†Ô∏è  {total - passed_count} scenarios failed")
        print("System needs additional hardening.")

    print("#" * 60 + "\n")

    return passed_count == total


if __name__ == "__main__":
    success = run_production_tests()
    sys.exit(0 if success else 1)


================================================================================
FILE PATH: tests\verification\test_quick_wins.py
LINES: 124
================================================================================

"""
Test Quick Wins implementation.
"""

import sys
from pathlib import Path

project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))


def test_asset_validation():
    """Test asset validation utility."""
    print("=" * 60)
    print("TEST: Asset Validation")
    print("=" * 60)

    from core.models import ClickImage, Flow, Script, WaitImage
    from core.validation import get_referenced_assets, validate_assets

    # Create test flow with assets
    flow = Flow(name="test")
    flow.actions = [
        ClickImage(asset_id="button_ok"),
        WaitImage(asset_id="loading_screen"),
        ClickImage(asset_id="button_cancel"),
    ]

    # Get referenced assets
    assets = get_referenced_assets(flow)
    print(f"‚úì Found {len(assets)} referenced assets: {assets}")
    assert len(assets) == 3

    # Create script
    script = Script(name="test", flows=[flow])

    # Test with non-existent directory
    fake_dir = Path("C:/nonexistent/assets")
    valid, missing = validate_assets(script, fake_dir)

    print(f"‚úì Validation detected {len(missing)} missing assets")
    assert not valid
    assert len(missing) == 3

    print("‚úì Asset validation working correctly\n")
    return True


def test_timeout_limits():
    """Test timeout validation."""
    print("=" * 60)
    print("TEST: Timeout Limits")
    print("=" * 60)

    from pydantic import ValidationError

    from core.models import WaitImage

    # Test valid timeout
    action1 = WaitImage(asset_id="test", timeout_ms=10000)
    print(f"‚úì Valid timeout accepted: {action1.timeout_ms}ms")

    # Test max timeout (5 minutes = 300,000ms)
    action2 = WaitImage(asset_id="test", timeout_ms=300000)
    print(f"‚úì Max timeout accepted: {action2.timeout_ms}ms")

    # Test exceeding max (should fail)
    try:
        WaitImage(asset_id="test", timeout_ms=600000)  # 10 minutes
        print("‚úó Should have rejected timeout > 5 min")
        return False
    except ValidationError:
        print("‚úì Timeout > 5 min correctly rejected")

    print("‚úì Timeout limits working\n")
    return True


def test_ocr_availability():
    """Test OCR availability check."""
    print("=" * 60)
    print("TEST: OCR Availability Check")
    print("=" * 60)

    try:
        from vision.ocr import TextReader

        reader = TextReader()
        print(f"OCR Available: {reader.available}")

        if reader.available:
            print("‚úì Tesseract detected")
        else:
            print("‚ö† Tesseract not available (feature will be disabled)")

        print("‚úì OCR check completed without crash\n")
        return True

    except Exception as e:
        print(f"‚úó OCR check failed: {e}\n")
        return False


if __name__ == "__main__":
    print("\n" + "#" * 60)
    print("# QUICK WINS VERIFICATION")
    print("#" * 60 + "\n")

    results = []
    results.append(("Asset Validation", test_asset_validation()))
    results.append(("Timeout Limits", test_timeout_limits()))
    results.append(("OCR Availability", test_ocr_availability()))

    print("#" * 60)
    print("# SUMMARY")
    print("#" * 60)

    for name, passed in results:
        status = "‚úÖ PASS" if passed else "‚ùå FAIL"
        print(f"{status}: {name}")

    passed_count = sum(1 for _, p in results if p)
    print(f"\n{passed_count}/{len(results)} tests passed")
    print("#" * 60 + "\n")


================================================================================
FILE PATH: tests\verification\test_system_comprehensive.py
LINES: 262
================================================================================

"""
Comprehensive System Test Suite
Tests all major components for bugs and regressions.
"""

import sys
from pathlib import Path

project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))


def test_models_validation():
    """Test 1: Model validation and serialization."""
    print("\n" + "=" * 60)
    print("TEST 1: Models Validation")
    print("=" * 60)

    import yaml

    from core.models import (
        ROI,
        ClickImage,
        Delay,
        Flow,
        Hotkey,
        IfImage,
        IfText,
        Loop,
        ReadText,
        Script,
        WaitImage,
    )

    try:
        # Test all action types can be created
        actions = [
            ClickImage(asset_id="test"),
            WaitImage(asset_id="test", timeout_ms=5000),
            Delay(ms=1000),
            IfImage(asset_id="test", then_actions=[], else_actions=[]),
            IfText(variable_name="$hp", operator="contains", value="100"),
            ReadText(variable_name="$text", roi=ROI(x=0, y=0, w=100, h=30)),
            Hotkey(keys=["CTRL", "C"]),
            Loop(iterations=5),
        ]

        print(f"‚úì Created {len(actions)} action types successfully")

        # Test flow creation
        flow = Flow(name="test_flow", actions=actions)
        print(f"‚úì Created flow with {len(flow.actions)} actions")

        # Test script creation
        script = Script(name="test_script", flows=[flow])
        print(f"‚úì Created script with {len(script.flows)} flows")

        # Test serialization
        yaml_str = yaml.dump(script.model_dump(), sort_keys=False)
        print(f"‚úì Serialized to YAML ({len(yaml_str)} bytes)")

        # Test deserialization
        loaded_data = yaml.safe_load(yaml_str)
        loaded_script = Script(**loaded_data)
        print("‚úì Deserialized from YAML")

        assert loaded_script.name == script.name
        assert len(loaded_script.flows) == len(script.flows)
        print("‚úì Validation passed!\n")
        return True

    except Exception as e:
        print(f"‚úó FAILED: {e}\n")
        return False


def test_ocr_functionality():
    """Test 2: OCR functionality."""
    print("=" * 60)
    print("TEST 2: OCR Functionality")
    print("=" * 60)

    try:
        from PIL import Image, ImageDraw

        from vision.ocr import TextReader

        reader = TextReader()

        if not reader.available:
            print("‚ö† Tesseract not available, skipping OCR test")
            return True

        # Create test image
        img = Image.new("RGB", (200, 50), color=(255, 255, 255))
        d = ImageDraw.Draw(img)
        d.text((10, 10), "TEST: 123", fill=(0, 0, 0))

        # Read text
        text = reader.read_from_image(img)
        print(f"‚úì OCR read: '{text}'")

        if "123" in text or "TEST" in text:
            print("‚úì OCR working correctly\n")
            return True
        else:
            print("‚ö† OCR result unclear, but no crash\n")
            return True

    except Exception as e:
        print(f"‚úó FAILED: {e}\n")
        return False


def test_graph_models():
    """Test 3: Graph models and conversion."""
    print("=" * 60)
    print("TEST 3: Graph Models & Conversion")
    print("=" * 60)

    try:
        from core.graph import graph_to_list, list_to_graph
        from core.models import ClickImage, Delay, Flow

        # Create flow
        flow = Flow(name="test")
        flow.actions = [Delay(ms=100), ClickImage(asset_id="btn")]

        # Convert to graph
        flow.graph = list_to_graph(flow.actions)
        print(f"‚úì Converted list to graph ({len(flow.graph.nodes)} nodes)")

        # Convert back to list
        actions_back = graph_to_list(flow.graph)
        print(f"‚úì Converted graph to list ({len(actions_back)} actions)")

        assert len(actions_back) == len(flow.actions)
        print("‚úì Round-trip conversion successful\n")
        return True

    except Exception as e:
        print(f"‚úó FAILED: {e}\n")
        return False


def test_action_union():
    """Test 4: Action discriminated union."""
    print("=" * 60)
    print("TEST 4: Action Discriminated Union")
    print("=" * 60)

    try:
        from core.models import ClickImage, IfText, ReadText, WaitImage

        # Create instances to verify they work
        test_actions = [
            ClickImage(asset_id="test"),
            WaitImage(asset_id="test"),
            IfText(variable_name="$var", value="test"),
            ReadText(variable_name="$var", roi={"x": 0, "y": 0, "w": 100, "h": 30}),
        ]

        print(f"‚úì Created {len(test_actions)} test action instances")

        # Verify each has correct action field
        for action in test_actions:
            assert hasattr(action, "action"), f"{type(action).__name__} missing 'action' field"
            print(f"  - {action.action} ‚úì")

        print("‚úì All key action types validated\n")
        return True

    except Exception as e:
        print(f"‚úó FAILED: {e}\n")
        return False


def test_imports():
    """Test 5: Import all major modules."""
    print("=" * 60)
    print("TEST 5: Module Imports")
    print("=" * 60)

    modules_to_test = [
        "core.models",
        "core.engine.runner",
        "core.engine.context",
        "core.graph.converter",
        "core.graph.walker",
        "app.ui.graph_view",
        "app.ui.graph_node",
        "app.ui.graph_connection",
        "vision.ocr",
    ]

    failed = []
    for module_name in modules_to_test:
        try:
            __import__(module_name)
            print(f"  ‚úì {module_name}")
        except Exception as e:
            print(f"  ‚úó {module_name}: {e}")
            failed.append(module_name)

    if failed:
        print(f"\n‚úó {len(failed)} imports failed\n")
        return False

    print(f"\n‚úì All {len(modules_to_test)} modules imported successfully\n")
    return True


def run_all_tests():
    """Run complete test suite."""
    print("\n" + "#" * 60)
    print("# RETROAUTO COMPREHENSIVE SYSTEM TEST")
    print("#" * 60)

    tests = [
        ("Module Imports", test_imports),
        ("Models Validation", test_models_validation),
        ("OCR Functionality", test_ocr_functionality),
        ("Graph Models", test_graph_models),
        ("Action Union", test_action_union),
    ]

    results = []
    for name, test_func in tests:
        try:
            passed = test_func()
            results.append((name, passed))
        except Exception as e:
            print(f"CRITICAL ERROR in {name}: {e}")
            results.append((name, False))

    # Summary
    print("\n" + "#" * 60)
    print("# TEST SUMMARY")
    print("#" * 60)

    passed_count = sum(1 for _, passed in results if passed)
    total_count = len(results)

    for name, passed in results:
        status = "‚úÖ PASS" if passed else "‚ùå FAIL"
        print(f"{status}: {name}")

    print(f"\n{passed_count}/{total_count} tests passed")

    if passed_count == total_count:
        print("\nüéâ ALL TESTS PASSED! System is stable.")
    else:
        print(f"\n‚ö†Ô∏è  {total_count - passed_count} TESTS FAILED! Bugs detected.")

    print("#" * 60 + "\n")

    return passed_count == total_count


if __name__ == "__main__":
    success = run_all_tests()
    sys.exit(0 if success else 1)


================================================================================
FILE PATH: tests\verification\verify_humanness.py
LINES: 161
================================================================================

"""
Deep Verification for Human Mouse Movement
"""

import math
import statistics
import sys
import unittest
from unittest.mock import MagicMock, patch

# Ensure core can be imported
sys.path.append("c:/Auto/Newauto")

from core.models import ROI, ClickRandom
from core.vision.input import MouseController


class TestHumanMouseMovement(unittest.TestCase):
    def setUp(self):
        # Force HAS_PYAUTOGUI to True so logic runs
        import core.vision.input

        core.vision.input.HAS_PYAUTOGUI = True
        # Ensure pyautogui exists in module so patch works (if it failed import)
        if not hasattr(core.vision.input, "pyautogui"):
            core.vision.input.pyautogui = MagicMock()

        self.mouse = MouseController()
        # Mock pyautogui.position to return (0,0) initially
        self.mock_pos = MagicMock(return_value=MagicMock(x=0, y=0))

    @patch("core.vision.input.pyautogui")
    @patch("core.vision.input.time")
    def test_bezier_curve_shape(self, mock_time, mock_pyautogui):
        """Verify the path is curved, not straight."""
        # Fix position mock
        mock_point = MagicMock()
        mock_point.x = 0
        mock_point.y = 0
        mock_pyautogui.position.return_value = mock_point

        self.mouse._position = MagicMock(x=0, y=0)
        recorded_points = []

        # Mock time to increment to avoid infinite loops or stuck logic
        # Increase range to support long loops
        mock_time.time.side_effect = [i * 0.001 for i in range(50000)]

        def side_effect_moveTo(x, y, duration=0.0, _pause=False):
            recorded_points.append((x, y))

        mock_pyautogui.moveTo.side_effect = side_effect_moveTo

        # Move from 0,0 to 1000, 1000 using absolute move
        self.mouse.moveto(1000, 1000)

        # Filter out start and potential jitter points
        if len(recorded_points) < 5:
            self.fail(f"Path too short: {len(recorded_points)}")

        path = recorded_points[:-2]

        # Calculate linearity error
        max_deviation = 0
        for x, y in path:
            # Distance from point to line: |Ax + By + C| / sqrt(A^2 + B^2)
            # Line: -x + y = 0 -> | -x + y | / sqrt(2)
            deviation = abs(-x + y) / math.sqrt(2)
            max_deviation = max(max_deviation, deviation)

        print(f"Max deviation from straight line: {max_deviation:.2f} px")
        self.assertGreater(max_deviation, 1.0, "Movement is too robotic (straight line)")

    @patch("core.vision.input.pyautogui")
    @patch("core.vision.input.time")
    def test_speed_variance(self, mock_time, mock_pyautogui):
        """Verify speed (distance per step) is not constant."""
        # Fix position mock
        mock_point = MagicMock()
        mock_point.x = 0
        mock_point.y = 0
        mock_pyautogui.position.return_value = mock_point

        self.mouse._position = MagicMock(x=0, y=0)
        recorded_points = []

        mock_time.time.side_effect = [i * 0.001 for i in range(10000)]

        def side_effect_moveTo(x, y, duration=0.0, _pause=False):
            recorded_points.append((x, y))

        mock_pyautogui.moveTo.side_effect = side_effect_moveTo

        self.mouse.moveto(1000, 1000)

        if len(recorded_points) < 10:
            self.fail("Path too short")

        # Calculate segment lengths
        lengths = []
        prev = (0, 0)
        for p in recorded_points[:-2]:  # Ignore last jitter
            dist = math.sqrt((p[0] - prev[0]) ** 2 + (p[1] - prev[1]) ** 2)
            lengths.append(dist)
            prev = p

        # If speed varies, segments should vary
        stdev = statistics.stdev(lengths)
        print(f"Segment length stdev: {stdev:.2f}")
        # With Bezier easing, we expect significant variance
        self.assertGreater(stdev, 1.0, "Speed appears constant (equidistant points)")

    @patch("core.vision.input.pyautogui")
    @patch("core.vision.input.time")
    def test_random_distribution(self, mock_time, mock_pyautogui):
        """Verify random clicks check ROI distribution."""
        from core.engine.runner import Runner

        # Mock dependencies
        ctx = MagicMock()
        ctx.mouse = self.mouse
        runner = Runner(ctx)

        # Run 1000 clicks
        roi = ROI(x=0, y=0, w=100, h=100)
        action = ClickRandom(roi=roi, clicks=1, interval_ms=0)

        clicks = []

        def side_effect_click(x, y, *args, **kwargs):
            clicks.append((x, y))

        self.mouse.click = MagicMock(side_effect=side_effect_click)

        for _ in range(1000):
            runner._exec_click_random(action)

        xs = [c[0] for c in clicks]
        ys = [c[1] for c in clicks]

        mean_x = statistics.mean(xs)
        mean_y = statistics.mean(ys)
        stdev_x = statistics.stdev(xs)

        print(f"Distribution: Mean=({mean_x:.1f}, {mean_y:.1f}), StdDev={stdev_x:.1f}")

        # Target mean is 50, 50
        self.assertTrue(45 < mean_x < 55, "Distribution not centered X")
        self.assertTrue(45 < mean_y < 55, "Distribution not centered Y")

        # Target sigma was width/6 = 100/6 = 16.6
        self.assertTrue(14 < stdev_x < 19, "Distribution spread incorrect")

        # Check clamping
        min_x, max_x = min(xs), max(xs)
        self.assertGreaterEqual(min_x, 0)
        self.assertLessEqual(max_x, 100)


if __name__ == "__main__":
    unittest.main()


================================================================================
FILE PATH: tests\verification\verify_interrupts_deep.py
LINES: 118
================================================================================

"""
Deep Verification for Global Interrupts (Concurrency & Priority)
"""

import sys
import time
import unittest
from unittest.mock import MagicMock, call

# Ensure core can be imported
sys.path.append("c:/Auto/Newauto")

from core.engine.context import EngineState, ExecutionContext
from core.engine.interrupts import InterruptWatcher
from core.models import InterruptRule


class TestInterruptsDeep(unittest.TestCase):
    def setUp(self):
        self.ctx = MagicMock(spec=ExecutionContext)
        self.ctx.state = EngineState.RUNNING
        self.ctx.wait_if_paused.return_value = True
        self.ctx.is_running = True
        self.ctx.should_stop = False

        # Mock script with interrupts list
        self.ctx.script = MagicMock()
        self.ctx.script.interrupts = []

        self.runner = MagicMock()
        self.watcher = InterruptWatcher(self.ctx, self.runner, poll_ms=10)  # Fast poll for tests

    def tearDown(self):
        if self.watcher:
            self.watcher.stop()

    def test_interrupt_trigger(self):
        """Verify interrupt triggers when image appears."""
        # Rule: If 'low_hp' appears, run 'HealFlow'
        rule = InterruptRule(when_image="low_hp", priority=10, run_flow="HealFlow")
        self.ctx.script.interrupts = [rule]

        # Mock matcher: Initially nothing, then 'low_hp' appears
        def side_effect_find(asset_id, roi=None):
            if asset_id == "low_hp":
                return MagicMock(confidence=0.99)
            return None

        self.ctx.matcher.find.side_effect = side_effect_find

        self.watcher.start()
        time.sleep(0.1)  # Give thread time to tick

        # Verify run_flow called
        self.runner.run_flow.assert_called_with("HealFlow")

        # Verify pause requested
        self.ctx.request_pause.assert_called()
        self.ctx.request_resume.assert_called()

    def test_interrupt_priority(self):
        """Verify higher priority interrupt preempts lower."""
        # Rules: Critical (P10) and Buff (P1)
        r_crit = InterruptRule(when_image="crit", priority=10, run_flow="Critical")
        r_buff = InterruptRule(when_image="buff", priority=1, run_flow="Buff")
        self.ctx.script.interrupts = [r_crit, r_buff]

        # Both appear at same time
        def side_effect_find(asset_id, roi=None):
            return MagicMock(confidence=0.9)

        self.ctx.matcher.find.side_effect = side_effect_find

        self.watcher.start()
        time.sleep(0.1)

        # Should execute Critical (P10)
        self.runner.run_flow.assert_any_call("Critical")

        # Since watcher loops, it might execute Buff next if critical is done/cooldown?
        # But we verify critical was called FIRST or at least called.
        # Actually since logic breaks after first trigger, only P10 should fire in the first tick.
        # P1 might fire in next tick if P10 enters cooldown.

        # Let's check call args list to ensure Critical was first *if* both fired
        calls = self.runner.run_flow.call_args_list
        if not calls:
            self.fail("No flow run")

        self.assertEqual(calls[0], call("Critical"), "Highest priority did not run first")

    def test_cooldown_logic(self):
        """Verify interrupt does not spam (1s cooldown)."""
        rule = InterruptRule(when_image="spam", priority=5, run_flow="AntiSpam")
        self.ctx.script.interrupts = [rule]

        self.ctx.matcher.find.return_value = MagicMock(confidence=1.0)

        self.watcher.start()
        time.sleep(0.3)

        # Should have run once (maybe twice if 0.1s slept > poll 10ms + execution)
        # But cooldown is 1.0s. So strictly ONCE.
        self.assertEqual(
            self.runner.run_flow.call_count, 1, "Cooldown failed, triggered multiple times"
        )

        # Wait for cooldown expire (>1s)
        time.sleep(1.1)

        # Should trigger again
        # The watcher thread is still running
        count = self.runner.run_flow.call_count
        self.assertGreater(count, 1, "Did not re-trigger after cooldown")


if __name__ == "__main__":
    unittest.main()


================================================================================
FILE PATH: tests\verification\verify_logic_ocr.py
LINES: 90
================================================================================

import sys
import unittest
from pathlib import Path
from unittest.mock import MagicMock

# Add project root to path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from core.engine.context import ExecutionContext
from core.engine.runner import Runner
from core.models import Delay, IfText


class TestOCRLogic(unittest.TestCase):
    def setUp(self):
        # Mock Context
        self.ctx = MagicMock(spec=ExecutionContext)
        self.ctx.variables = {}
        # Mock wait_if_paused to always return True (not paused)
        self.ctx.wait_if_paused.return_value = True

        # Init Runner with mocked context
        self.runner = Runner(self.ctx)

        # Mock recursive execution to track calls
        self.runner._execute_action = MagicMock()

    def test_if_text_numeric(self):
        # Scenario: HP = "100"
        self.ctx.variables["$hp"] = "100"

        pass_action = Delay(ms=10)
        fail_action = Delay(ms=999)

        # If $hp > 50
        action = IfText(
            variable_name="$hp",
            operator="numeric_gt",
            value="50",
            then_actions=[pass_action],
            else_actions=[fail_action],
        )

        self.runner._exec_if_text(action, MagicMock(), {})

        # Verify THEN branch executed (pass_action)
        self.runner._execute_action.assert_called_with(
            pass_action, unittest.mock.ANY, unittest.mock.ANY
        )

    def test_if_text_contains(self):
        self.ctx.variables["$chat"] = "Player1: Hello World"
        pass_action = Delay(ms=10)

        action = IfText(
            variable_name="$chat",
            operator="contains",
            value="Hello",
            then_actions=[pass_action],
            else_actions=[],
        )

        self.runner._exec_if_text(action, MagicMock(), {})
        self.runner._execute_action.assert_called_with(
            pass_action, unittest.mock.ANY, unittest.mock.ANY
        )

    def test_if_text_fail(self):
        self.ctx.variables["$hp"] = "10"
        pass_action = Delay(ms=10)
        fail_action = Delay(ms=999)

        action = IfText(
            variable_name="$hp",
            operator="numeric_gt",
            value="50",
            then_actions=[pass_action],
            else_actions=[fail_action],
        )

        self.runner._exec_if_text(action, MagicMock(), {})
        # Verify ELSE branch executed (fail_action)
        self.runner._execute_action.assert_called_with(
            fail_action, unittest.mock.ANY, unittest.mock.ANY
        )


if __name__ == "__main__":
    unittest.main()


================================================================================
FILE PATH: tests\verification\verify_ocr.py
LINES: 58
================================================================================

import sys
import unittest
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from PIL import Image, ImageDraw

from core.models import ROI
from vision.ocr import TextReader


class TestOCR(unittest.TestCase):
    def setUp(self):
        self.reader = TextReader()

    def test_ocr_read(self):
        if not self.reader.available:
            print("WARNING: Tesseract not installed. Skipping OCR test.")
            return

        # Create image with text
        img = Image.new("RGB", (200, 50), color=(255, 255, 255))
        d = ImageDraw.Draw(img)
        # Use default bitmap font
        d.text((10, 10), "HP: 100/100", fill=(0, 0, 0))

        # Read
        text = self.reader.read_from_image(img)
        print(f"OCR Read: '{text}'")

        # Tesseract usually struggles with default PIL font (very small) unless scaled
        # But let's see if it gets anything.
        # Ideally we'd use a better font, but we don't know if arial.ttf is available?
        # Windows usually has arial.

        # Only assert if we got something, otherwise just warn (environment dependent)
        if text:
            self.assertIn("100", text)

    def test_roi_crop(self):
        if not self.reader.available:
            return

        img = Image.new("RGB", (200, 50), color=(255, 255, 255))
        d = ImageDraw.Draw(img)
        d.text((10, 10), "Mana: 50", fill=(0, 0, 0))

        # ROI matching the text area roughly
        roi = ROI(x=0, y=0, w=100, h=50)
        text = self.reader.read_from_image(img, roi=roi)
        print(f"ROI Read: '{text}'")


if __name__ == "__main__":
    unittest.main()


================================================================================
FILE PATH: vision\__init__.py
LINES: 14
================================================================================

"""RetroAuto v2 - Vision package."""

from vision.capture import ScreenCapture, get_capture
from vision.matcher import Matcher
from vision.waiter import ImageWaiter, WaitOutcome, WaitResult

__all__ = [
    "ScreenCapture",
    "get_capture",
    "Matcher",
    "ImageWaiter",
    "WaitResult",
    "WaitOutcome",
]


================================================================================
FILE PATH: vision\capture.py
LINES: 121
================================================================================

"""
RetroAuto v2 - Screen Capture

Fast screen capture using mss library.
"""

import cv2
import numpy as np
from mss import mss
from mss.base import MSSBase

from core.models import ROI
from infra import get_logger

logger = get_logger("Capture")


class ScreenCapture:
    """
    High-performance screen capture using mss.

    Features:
    - Full screen capture
    - ROI-specific capture (faster)
    - Grayscale conversion
    - Monitor selection
    """

    def __init__(self) -> None:
        self._sct: MSSBase | None = None

    def _get_sct(self) -> MSSBase:
        """Get or create mss instance."""
        if self._sct is None:
            self._sct = mss()
        return self._sct

    @property
    def monitors(self) -> list[dict]:
        """Get list of available monitors."""
        return list(self._get_sct().monitors)

    @property
    def screen_size(self) -> tuple[int, int]:
        """Get primary screen size (width, height)."""
        mon = self._get_sct().monitors[1]  # Primary monitor
        return mon["width"], mon["height"]

    def capture_full(self, monitor: int = 1, grayscale: bool = False) -> np.ndarray:
        """
        Capture full screen.

        Args:
            monitor: Monitor index (0=all, 1=primary, 2+=secondary)
            grayscale: Convert to grayscale

        Returns:
            numpy array (H, W, C) or (H, W) if grayscale
        """
        sct = self._get_sct()
        mon = sct.monitors[monitor]
        img = np.array(sct.grab(mon))

        # mss returns BGRA, convert to BGR or Gray
        if grayscale:
            return self._to_grayscale(img)
        return img[:, :, :3]  # Remove alpha channel

    def capture_roi(self, roi: ROI, grayscale: bool = False) -> np.ndarray:
        """
        Capture specific region (faster than full + crop).

        Args:
            roi: Region of interest
            grayscale: Convert to grayscale

        Returns:
            numpy array of the region
        """
        sct = self._get_sct()
        region = {
            "left": roi.x,
            "top": roi.y,
            "width": roi.w,
            "height": roi.h,
        }
        img = np.array(sct.grab(region))

        if grayscale:
            return self._to_grayscale(img)
        return img[:, :, :3]

    def _to_grayscale(self, img: np.ndarray) -> np.ndarray:
        """Convert BGRA/BGR to grayscale using OpenCV (optimized)."""
        if img.shape[2] == 4:
            return cv2.cvtColor(img, cv2.COLOR_BGRA2GRAY)
        return cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    def close(self) -> None:
        """Release mss resources."""
        if self._sct is not None:
            self._sct.close()
            self._sct = None

    def __enter__(self) -> "ScreenCapture":
        return self

    def __exit__(self, *args) -> None:  # type: ignore
        self.close()


# Singleton instance for convenience
_capture: ScreenCapture | None = None


def get_capture() -> ScreenCapture:
    """Get singleton screen capture instance."""
    global _capture
    if _capture is None:
        _capture = ScreenCapture()
    return _capture


================================================================================
FILE PATH: vision\matcher.py
LINES: 233
================================================================================

"""
RetroAuto v2 - Template Matcher

OpenCV template matching with ROI optimization.
"""

import time

import cv2
import numpy as np

from core.models import ROI, AssetImage, Match, MatchMethod
from core.templates import TemplateStore
from infra import get_logger
from vision.capture import ScreenCapture, get_capture

logger = get_logger("Matcher")

# OpenCV method mapping
CV_METHODS = {
    MatchMethod.TM_CCOEFF_NORMED: cv2.TM_CCOEFF_NORMED,
    MatchMethod.TM_CCORR_NORMED: cv2.TM_CCORR_NORMED,
    MatchMethod.TM_SQDIFF_NORMED: cv2.TM_SQDIFF_NORMED,
}


class Matcher:
    """
    Template matcher using OpenCV.

    Features:
    - ROI-first matching (faster)
    - Grayscale optimization
    - Multiple match methods
    - Confidence thresholding
    """

    def __init__(
        self,
        templates: TemplateStore,
        capture: ScreenCapture | None = None,
    ) -> None:
        self._templates = templates
        self._capture = capture or get_capture()
        # O1: Screen cache for rapid multi-asset matching (50ms TTL)
        self._screen_cache: dict[str, tuple[float, np.ndarray]] = {}
        self._cache_ttl_ms = 50  # Cache valid for 50ms

    def _get_cached_screen(
        self, roi: ROI | None, grayscale: bool
    ) -> np.ndarray:
        """Get screen with caching (50ms TTL) for rapid multi-asset checks."""
        # Create cache key based on ROI and grayscale
        if roi:
            cache_key = f"{roi.x},{roi.y},{roi.w},{roi.h},{grayscale}"
        else:
            cache_key = f"full,{grayscale}"

        now = time.time() * 1000  # Current time in ms

        # Check if cached version is still valid
        if cache_key in self._screen_cache:
            cached_time, cached_screen = self._screen_cache[cache_key]
            if (now - cached_time) < self._cache_ttl_ms:
                return cached_screen

        # Capture new screen
        if roi:
            screen = self._capture.capture_roi(roi, grayscale=grayscale)
        else:
            screen = self._capture.capture_full(grayscale=grayscale)

        # Cache it (limit cache size to prevent memory leak)
        if len(self._screen_cache) > 10:
            self._screen_cache.clear()
        self._screen_cache[cache_key] = (now, screen)

        return screen

    def clear_cache(self) -> None:
        """Clear screen cache (call after each action for fresh captures)."""
        self._screen_cache.clear()

    def find(
        self,
        asset_id: str,
        roi_override: ROI | None = None,
        adaptive: bool = False,
    ) -> Match | None:
        """
        Find asset on screen.

        Args:
            asset_id: Asset ID from template store
            roi_override: Override asset's default ROI
            adaptive: Allow adaptive thresholding (lower confidence)

        Returns:
            Match if found with confidence >= threshold (or adaptive floor), else None
        """
        # Get template
        tmpl_data = self._templates.get(asset_id)
        if tmpl_data is None:
            logger.warning("Asset not found in store: %s", asset_id)
            return None

        asset: AssetImage = tmpl_data["asset"]
        tmpl_img: np.ndarray = tmpl_data["gray"] if asset.grayscale else tmpl_data["color"]
        tmpl_h, tmpl_w = tmpl_data["shape"]

        # Determine ROI
        roi = roi_override or asset.roi

        # O1: Use cached screen capture if available and fresh (50ms TTL)
        screen = self._get_cached_screen(roi, asset.grayscale)
        if roi:
            offset_x, offset_y = roi.x, roi.y
        else:
            offset_x, offset_y = 0, 0

        # Match
        result = cv2.matchTemplate(screen, tmpl_img, CV_METHODS[asset.method])

        # Get best match
        if asset.method == MatchMethod.TM_SQDIFF_NORMED:
            # For SQDIFF, lower is better
            min_val, _, min_loc, _ = cv2.minMaxLoc(result)
            confidence = 1.0 - min_val
            loc = min_loc
        else:
            _, max_val, _, max_loc = cv2.minMaxLoc(result)
            confidence = max_val
            loc = max_loc

        # Check threshold
        if confidence < asset.threshold:
            bypass = False
            if adaptive and confidence >= 0.6:
                logger.warning(
                    "Adaptive Match: %s found with %.2f (threshold logic bypassed from %.2f)",
                    asset_id,
                    confidence,
                    asset.threshold,
                )
                bypass = True

            if not bypass:
                logger.debug(
                    "Match below threshold: %s (%.2f < %.2f)", asset_id, confidence, asset.threshold
                )
                return None

        # Create match with absolute coordinates
        match = Match(
            x=loc[0] + offset_x,
            y=loc[1] + offset_y,
            w=tmpl_w,
            h=tmpl_h,
            confidence=confidence,
        )

        logger.debug("Found %s at (%d, %d) conf=%.2f", asset_id, match.x, match.y, confidence)
        return match

    def find_all(
        self,
        asset_id: str,
        roi_override: ROI | None = None,
        max_matches: int = 10,
    ) -> list[Match]:
        """
        Find all occurrences of asset on screen.

        Args:
            asset_id: Asset ID
            roi_override: Override default ROI
            max_matches: Maximum matches to return

        Returns:
            List of matches sorted by confidence
        """
        tmpl_data = self._templates.get(asset_id)
        if tmpl_data is None:
            return []

        asset: AssetImage = tmpl_data["asset"]
        tmpl_img: np.ndarray = tmpl_data["gray"] if asset.grayscale else tmpl_data["color"]
        tmpl_h, tmpl_w = tmpl_data["shape"]

        roi = roi_override or asset.roi

        if roi:
            screen = self._capture.capture_roi(roi, grayscale=asset.grayscale)
            offset_x, offset_y = roi.x, roi.y
        else:
            screen = self._capture.capture_full(grayscale=asset.grayscale)
            offset_x, offset_y = 0, 0

        result = cv2.matchTemplate(screen, tmpl_img, CV_METHODS[asset.method])

        # Find all locations above threshold
        if asset.method == MatchMethod.TM_SQDIFF_NORMED:
            locations = np.where(result <= (1.0 - asset.threshold))
            confidences = 1.0 - result[locations]
        else:
            locations = np.where(result >= asset.threshold)
            confidences = result[locations]

        matches = []
        for i, (y, x) in enumerate(zip(locations[0], locations[1], strict=False)):
            if len(matches) >= max_matches:
                break
            matches.append(
                Match(
                    x=int(x) + offset_x,
                    y=int(y) + offset_y,
                    w=tmpl_w,
                    h=tmpl_h,
                    confidence=float(confidences[i]),
                )
            )

        # Sort by confidence descending
        matches.sort(key=lambda m: m.confidence, reverse=True)
        return matches

    def exists(
        self,
        asset_id: str,
        roi_override: ROI | None = None,
    ) -> bool:
        """Quick check if asset exists on screen."""
        return self.find(asset_id, roi_override) is not None


================================================================================
FILE PATH: vision\ocr.py
LINES: 241
================================================================================

"""
OCR Module for Text Recognition.
Wraps pytesseract/Tesseract-OCR.
"""

import logging
import os

import cv2
import numpy as np
from PIL import Image

# Try to import pytesseract
try:
    import pytesseract

    HAS_TESSERACT = True
except ImportError:
    HAS_TESSERACT = False

from core.models import ROI

logger = logging.getLogger(__name__)


class TextReader:
    """
    OCR Reader using Tesseract with result caching for performance.
    """

    def __init__(self, cache_ttl: float = 2.0) -> None:
        self.available = HAS_TESSERACT
        if not self.available:
            logger.warning("pytesseract not installed. OCR features will be disabled.")

        # Performance: Cache OCR results to avoid redundant calls
        # Key: hash of image bytes, Value: (result_text, timestamp)
        self._ocr_cache: dict[int, tuple[str, float]] = {}
        self._cache_ttl = cache_ttl  # Cache time-to-live in seconds
        self._cache_max_size = 50  # Max cached results

    def is_available(self) -> bool:
        """
        Check if OCR is available and working.

        Returns:
            True if Tesseract is installed and accessible
        """
        if not self.available:
            return False

        try:
            # Try to get Tesseract version as a quick check
            import pytesseract

            version = pytesseract.get_tesseract_version()
            return version is not None
        except Exception:
            return False

        # Check for Tesseract binary in common Windows paths if not in PATH
        if HAS_TESSERACT:
            try:
                # Simple check if "tesseract" command is available
                # If shutil.which("tesseract") is None, we might need to look for it.
                # For now, we trust the user has Tesseract in PATH or we set a default.

                # Common defaults for Windows
                known_paths = [
                    r"C:\Program Files\Tesseract-OCR\tesseract.exe",
                    r"C:\Program Files (x86)\Tesseract-OCR\tesseract.exe",
                    os.path.expandvars(r"%LOCALAPPDATA%\Programs\Tesseract-OCR\tesseract.exe"),
                ]

                # Only set if not already set (default is 'tesseract')
                cmd = pytesseract.pytesseract.tesseract_cmd
                if cmd == "tesseract":
                    import shutil

                    if not shutil.which("tesseract"):
                        for p in known_paths:
                            if os.path.exists(p):
                                pytesseract.pytesseract.tesseract_cmd = p
                                logger.info(f"Set Tesseract path to: {p}")
                                break
            except Exception as e:
                logger.warning(f"Error configuring Tesseract: {e}")

    def preprocess_image(
        self, img: Image.Image, scale: float = 1.0, invert: bool = False, binarize: bool = False
    ) -> Image.Image:
        """
        Preprocess image for better OCR.

        Args:
            img: Input PIL Image
            scale: Scaling factor (e.g. 2.0 to double size)
            invert: Invert colors (useful for white text on dark bg)
            binarize: Apply OTSU thresholding

        Returns:
            Processed PIL Image
        """
        try:
            # Convert to numpy for CV2 operations
            # PIL RGB -> CV2 BGR (or Grayscale)
            # Standard conversion:
            open_cv_image = np.array(img)

            # Convert to grayscale if not already
            if len(open_cv_image.shape) == 3:
                open_cv_image = cv2.cvtColor(open_cv_image, cv2.COLOR_RGB2GRAY)

            # Scaling
            if scale != 1.0 and scale > 0:
                width = int(open_cv_image.shape[1] * scale)
                height = int(open_cv_image.shape[0] * scale)
                open_cv_image = cv2.resize(
                    open_cv_image, (width, height), interpolation=cv2.INTER_CUBIC
                )

            # Inversion (White on Black -> Black on White)
            if invert:
                open_cv_image = cv2.bitwise_not(open_cv_image)

            # Binarization (Thresholding)
            if binarize:
                # Otsu's thresholding
                _, open_cv_image = cv2.threshold(
                    open_cv_image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU
                )

            # Convert back to PIL
            return Image.fromarray(open_cv_image)

        except Exception as e:
            logger.error(f"Preprocessing Error: {e}")
            return img

    def read_from_file(self, image_path: str, roi: ROI | None = None, allowlist: str = "") -> str:
        """Read text from an image file."""
        if not self.available:
            logger.error("OCR not available (pytesseract missing)")
            return ""

        try:
            img = Image.open(image_path)
            return self.read_from_image(img, roi, allowlist=allowlist)
        except Exception as e:
            logger.error(f"OCR File Error: {e}")
            return ""

    def read_from_image(
        self,
        img: Image.Image,
        roi: ROI | None = None,
        allowlist: str = "",
        scale: float = 1.0,
        invert: bool = False,
        binarize: bool = False,
    ) -> str:
        """
        Read text from a PIL Image object with options.
        Uses caching to avoid redundant OCR calls.
        """
        if not self.available:
            return ""

        try:
            # Crop to ROI if specified
            if roi:
                # ROI is x, y, w, h
                box = (roi.x, roi.y, roi.x + roi.w, roi.y + roi.h)
                img = img.crop(box)

            # Preprocessing
            img = self.preprocess_image(img, scale, invert, binarize)

            # Performance: Check cache first
            import time
            cache_key = self._compute_image_hash(img, allowlist)
            if cache_key in self._ocr_cache:
                cached_text, cached_time = self._ocr_cache[cache_key]
                if time.time() - cached_time < self._cache_ttl:
                    logger.debug("OCR cache hit (key=%d)", cache_key)
                    return cached_text
                else:
                    # Expired - remove
                    del self._ocr_cache[cache_key]

            # Build config
            # --psm 7 is "Treat the image as a single text line" - good for game stats
            config_opts = ["--psm 7"]

            if allowlist:
                config_opts.append(f"-c tessedit_char_whitelist={allowlist}")

            config_str = " ".join(config_opts)

            text = pytesseract.image_to_string(img, config=config_str)
            result = text.strip()

            # Store in cache
            self._cache_result(cache_key, result)

            return result

        except Exception as e:
            logger.error(f"OCR Execution Error: {e}")
            # If tesseract not found, it raises TesseractNotFoundError
            if "tesseract is not installed" in str(e).lower() or "not found" in str(e).lower():
                self.available = False
                logger.critical("Tesseract binary not found! Please install Tesseract-OCR.")
            return ""

    def _compute_image_hash(self, img: Image.Image, allowlist: str) -> int:
        """Compute hash of image for caching."""
        try:
            # Fast hash using image bytes + config
            img_bytes = img.tobytes()[:4096]  # First 4KB for speed
            return hash((img_bytes, img.size, allowlist))
        except Exception:
            return 0

    def _cache_result(self, key: int, text: str) -> None:
        """Store OCR result in cache with LRU eviction."""
        import time

        # Evict if over size limit
        if len(self._ocr_cache) >= self._cache_max_size:
            # Remove oldest entry
            oldest_key = min(self._ocr_cache, key=lambda k: self._ocr_cache[k][1])
            del self._ocr_cache[oldest_key]

        self._ocr_cache[key] = (text, time.time())

    def clear_cache(self) -> None:
        """Clear the OCR result cache."""
        self._ocr_cache.clear()
        logger.debug("OCR cache cleared")



================================================================================
FILE PATH: vision\pixel_checker.py
LINES: 186
================================================================================

"""
RetroAuto v2 - Pixel Color Checker

Fast pixel color checking for automation triggers.
"""

from __future__ import annotations

import ctypes
from dataclasses import dataclass

from infra import get_logger

logger = get_logger("PixelChecker")

# Windows API
user32 = ctypes.windll.user32
gdi32 = ctypes.windll.gdi32


@dataclass
class PixelResult:
    """Result of pixel color check."""

    x: int
    y: int
    r: int
    g: int
    b: int


class PixelChecker:
    """
    Fast pixel color checking using Windows API.

    Much faster than capturing screen and extracting pixel.
    Uses GetPixel directly from screen DC.

    Usage:
        checker = PixelChecker()
        result = checker.get_pixel(100, 200)
        if result.r > 200 and result.g < 50:
            print("Red detected!")
    """

    def __init__(self) -> None:
        """Initialize pixel checker."""
        self._hdc = user32.GetDC(0)  # Screen DC

    def __del__(self) -> None:
        """Clean up DC."""
        if hasattr(self, "_hdc") and self._hdc:
            user32.ReleaseDC(0, self._hdc)

    def get_pixel(self, x: int, y: int) -> PixelResult:
        """
        Get pixel color at coordinates.

        Args:
            x: X coordinate
            y: Y coordinate

        Returns:
            PixelResult with RGB values
        """
        color = gdi32.GetPixel(self._hdc, x, y)

        # Extract RGB from COLORREF (0x00BBGGRR)
        r = color & 0xFF
        g = (color >> 8) & 0xFF
        b = (color >> 16) & 0xFF

        return PixelResult(x=x, y=y, r=r, g=g, b=b)

    def check_color(
        self,
        x: int,
        y: int,
        r: int,
        g: int,
        b: int,
        tolerance: int = 10,
    ) -> bool:
        """
        Check if pixel matches expected color.

        Args:
            x, y: Coordinates
            r, g, b: Expected RGB values
            tolerance: Allowed difference per channel

        Returns:
            True if color matches within tolerance
        """
        pixel = self.get_pixel(x, y)

        return (
            abs(pixel.r - r) <= tolerance
            and abs(pixel.g - g) <= tolerance
            and abs(pixel.b - b) <= tolerance
        )

    def wait_for_color(
        self,
        x: int,
        y: int,
        r: int,
        g: int,
        b: int,
        tolerance: int = 10,
        timeout_ms: int = 10000,
        poll_ms: int = 100,
        appear: bool = True,
    ) -> bool:
        """
        Wait for pixel color to appear or disappear.

        Args:
            x, y: Coordinates
            r, g, b: Expected RGB values
            tolerance: Allowed difference
            timeout_ms: Maximum wait time
            poll_ms: Time between checks
            appear: True = wait for color, False = wait until color gone

        Returns:
            True if condition met, False if timeout
        """
        import time

        start = time.time()
        timeout_sec = timeout_ms / 1000.0
        poll_sec = poll_ms / 1000.0

        while time.time() - start < timeout_sec:
            matches = self.check_color(x, y, r, g, b, tolerance)

            if appear and matches or not appear and not matches:
                return True

            time.sleep(poll_sec)

        return False

    def find_color_in_region(
        self,
        x1: int,
        y1: int,
        x2: int,
        y2: int,
        r: int,
        g: int,
        b: int,
        tolerance: int = 10,
        step: int = 5,
    ) -> PixelResult | None:
        """
        Find first occurrence of color in region.

        Args:
            x1, y1, x2, y2: Region bounds
            r, g, b: Target color
            tolerance: Color tolerance
            step: Pixel step for faster scanning

        Returns:
            PixelResult if found, None otherwise
        """
        for y in range(y1, y2, step):
            for x in range(x1, x2, step):
                if self.check_color(x, y, r, g, b, tolerance):
                    return self.get_pixel(x, y)

        return None


# Global instance for convenience
_checker: PixelChecker | None = None


def get_pixel_checker() -> PixelChecker:
    """Get global pixel checker instance."""
    global _checker
    if _checker is None:
        _checker = PixelChecker()
    return _checker


================================================================================
FILE PATH: vision\waiter.py
LINES: 201
================================================================================

"""
RetroAuto v2 - Image Waiter

Wait for image to appear or disappear with polling and timeout.
"""

import time
from collections.abc import Callable
from dataclasses import dataclass
from enum import Enum

from core.models import ROI, Match
from infra import get_logger
from vision.matcher import Matcher

logger = get_logger("Waiter")


class WaitResult(Enum):
    """Result of wait operation."""

    SUCCESS = "success"
    TIMEOUT = "timeout"
    CANCELLED = "cancelled"


@dataclass
class WaitOutcome:
    """Outcome of a wait operation."""

    result: WaitResult
    match: Match | None = None
    elapsed_ms: int = 0

    @property
    def found(self) -> bool:
        """Check if wait was successful."""
        return self.result == WaitResult.SUCCESS


class ImageWaiter:
    """
    Wait for image conditions with polling.

    Features:
    - Wait for appear/vanish
    - Configurable poll interval
    - Timeout handling
    - Cancel support
    - Exponential backoff during idle
    """

    def __init__(
        self,
        matcher: Matcher,
        default_poll_ms: int = 100,
        default_timeout_ms: int = 10000,
        backoff_max_ms: int = 500,
    ) -> None:
        self._matcher = matcher
        self._default_poll_ms = default_poll_ms
        self._default_timeout_ms = default_timeout_ms
        self._backoff_max_ms = backoff_max_ms
        self._cancelled = False

    def cancel(self) -> None:
        """Cancel ongoing wait."""
        self._cancelled = True

    def reset(self) -> None:
        """Reset cancel flag."""
        self._cancelled = False

    def wait_appear(
        self,
        asset_id: str,
        timeout_ms: int | None = None,
        poll_ms: int | None = None,
        roi_override: ROI | None = None,
        on_poll: Callable[[int], None] | None = None,
        smart_wait: bool = True,
    ) -> WaitOutcome:
        """
        Wait for image to appear on screen.

        Args:
            asset_id: Asset to wait for
            timeout_ms: Maximum wait time (None = use default)
            poll_ms: Polling interval (None = use default)
            roi_override: Override default ROI
            on_poll: Callback on each poll (elapsed_ms)

        Returns:
            WaitOutcome with result and match if found
        """
        return self._wait(
            asset_id=asset_id,
            appear=True,
            timeout_ms=timeout_ms or self._default_timeout_ms,
            poll_ms=poll_ms or self._default_poll_ms,
            roi_override=roi_override,
            on_poll=on_poll,
            smart_wait=smart_wait,
        )

    def wait_vanish(
        self,
        asset_id: str,
        timeout_ms: int | None = None,
        poll_ms: int | None = None,
        roi_override: ROI | None = None,
        on_poll: Callable[[int], None] | None = None,
        smart_wait: bool = True,
    ) -> WaitOutcome:
        """
        Wait for image to disappear from screen.

        Args:
            asset_id: Asset to wait for disappearance
            timeout_ms: Maximum wait time
            poll_ms: Polling interval
            roi_override: Override default ROI
            on_poll: Callback on each poll

        Returns:
            WaitOutcome (match is None on success since image vanished)
        """
        return self._wait(
            asset_id=asset_id,
            appear=False,
            timeout_ms=timeout_ms or self._default_timeout_ms,
            poll_ms=poll_ms or self._default_poll_ms,
            roi_override=roi_override,
            on_poll=on_poll,
            smart_wait=smart_wait,
        )

    def _wait(
        self,
        asset_id: str,
        appear: bool,
        timeout_ms: int,
        poll_ms: int,
        roi_override: ROI | None,
        on_poll: Callable[[int], None] | None,
        smart_wait: bool,
    ) -> WaitOutcome:
        """Internal wait implementation with exponential backoff."""
        self._cancelled = False
        start_time = time.perf_counter()
        current_poll_ms = poll_ms
        consecutive_misses = 0

        action = "appear" if appear else "vanish"
        logger.info("Waiting for %s to %s (timeout=%dms)", asset_id, action, timeout_ms)

        while True:
            # Check cancellation
            if self._cancelled:
                elapsed = int((time.perf_counter() - start_time) * 1000)
                logger.info("Wait cancelled after %dms", elapsed)
                return WaitOutcome(result=WaitResult.CANCELLED, elapsed_ms=elapsed)

            # Check timeout
            elapsed = int((time.perf_counter() - start_time) * 1000)
            if elapsed >= timeout_ms:
                logger.warning("Wait timeout after %dms", elapsed)
                return WaitOutcome(result=WaitResult.TIMEOUT, elapsed_ms=elapsed)

            # Callback
            if on_poll:
                on_poll(elapsed)

            # Check image
            match = self._matcher.find(asset_id, roi_override, adaptive=smart_wait)

            if appear:
                # Waiting for image to appear
                if match is not None:
                    logger.info(
                        "Found %s after %dms (conf=%.2f)", asset_id, elapsed, match.confidence
                    )
                    return WaitOutcome(result=WaitResult.SUCCESS, match=match, elapsed_ms=elapsed)
                consecutive_misses += 1
            else:
                # Waiting for image to vanish
                if match is None:
                    logger.info("%s vanished after %dms", asset_id, elapsed)
                    return WaitOutcome(result=WaitResult.SUCCESS, elapsed_ms=elapsed)
                consecutive_misses = 0  # Reset - still visible

            # Exponential backoff during idle
            if consecutive_misses > 5:
                current_poll_ms = min(current_poll_ms * 1.5, self._backoff_max_ms)
            else:
                current_poll_ms = poll_ms

            # Sleep
            sleep_ms = min(current_poll_ms, timeout_ms - elapsed)
            if sleep_ms > 0:
                time.sleep(sleep_ms / 1000.0)


================================================================================
END OF PROJECT CONTEXT
Total files: 166
Total lines: 43938
================================================================================
